module Test.Crypto exposing (tests)

{-|-}

import Basics exposing (..)
import Math
import Expect
import Array exposing (..)
import Maybe exposing (Maybe(..))
import Test.Runner.Effectful exposing (describe, concat, test, await, awaitError, run)
import Task exposing ( Task )
import Crypto
import Bytes exposing ( Bytes )
import Bytes.Decode


{-| All tests on the node platform for the `Crypto` module
-}
tests : Test.Runner.Effectful.Test
tests = 
    concat 
        [ await Crypto.getSecureContext 
            "`Crypto.getSecureContext` successfully runs and returns a value" 
            (\secureContext ->
                concat 
                    [ uuidTests secureContext
                    , rsaOaepKeyTests secureContext
                    , aesCtrTestsHelper 
                        secureContext 
                        "AES-CTR" 
                        { aesLength = Crypto.AesLength128 
                        }
                    ]
            )
        , await Bytes.getHostEndianness
            "Get host endianness for required tests" 
            (\endianness ->
                concat 
                    [ randomValueTests endianness
                    ]
            )
        ]



-- Random Value Tests


{-|-}
type alias RandomValueTestsHelper x =
    { label : String
    , generator : Int -> Task x Bytes
    , decoder : Bytes.Endianness -> Bytes.Decode.Decoder Int
    , min : Int
    , max : Int
    , maximumPossibleValues : Int
    }


{-| Tests for all the random value generation functions
-}
randomValueTests : Bytes.Endianness -> Test.Runner.Effectful.Test
randomValueTests endianness =
    concat
        [ randomValueTestsHelper 
            endianness
            { label = "int8"
            , generator = Crypto.getRandomInt8Values
            , decoder = \_ -> Bytes.Decode.signedInt8
            , min = -128
            , max = 128
            , maximumPossibleValues = 65536
            }
        , randomValueTestsHelper 
            endianness
            { label = "uint8"
            , generator = Crypto.getRandomUInt8Values
            , decoder = \_ -> Bytes.Decode.unsignedInt8
            , min = 0
            , max = 256
            , maximumPossibleValues = 65536
            }
        , randomValueTestsHelper 
            endianness
            { label = "int16"
            , generator = Crypto.getRandomInt16Values
            , decoder = Bytes.Decode.signedInt16
            , min = -32767
            , max = 32767
            , maximumPossibleValues = 32768
            }
        , randomValueTestsHelper 
            endianness
            { label = "uint16"
            , generator = Crypto.getRandomUInt16Values
            , decoder = Bytes.Decode.unsignedInt16
            , min = 0
            , max = 65535
            , maximumPossibleValues = 32768
            }
        , randomValueTestsHelper 
            endianness
            { label = "int32"
            , generator = Crypto.getRandomInt32Values
            , decoder = Bytes.Decode.signedInt32
            , min = -2147483648
            , max = 2147483648
            , maximumPossibleValues = 16384
            }
        , randomValueTestsHelper 
            endianness
            { label = "uint32"
            , generator = Crypto.getRandomUInt32Values
            , decoder = Bytes.Decode.unsignedInt32
            , min = 0
            , max = 4294967295
            , maximumPossibleValues = 16384
            }
        ]


{-| A helper for generating tests for the random value functions.
-}
randomValueTestsHelper : Bytes.Endianness -> RandomValueTestsHelper a -> Test.Runner.Effectful.Test
randomValueTestsHelper endianness { label, generator, decoder, min, max, maximumPossibleValues } =
    concat
        [ await
            (generator 1)
            ("Generate a random " ++ label)
            (\values ->
                test 
                    "Generated `Bytes` can be decoded and are within their expected value range"
                    (\_ ->
                        when Bytes.Decode.decode (decoder endianness) values is
                            Just num ->
                                if num >= min && num <= max then
                                    Expect.pass
                                    
                                else
                                    Expect.fail "Generated `Bytes` not within expected values"

                            Nothing ->
                                Expect.fail "Generated `Bytes` were not successfully decoded"
                    )
            )
        , await
            (generator 99999)
            ("Generate the maximum possible values of " ++ label)
            (\values ->
                let
                    maximumValues =
                        maximumPossibleValues

                    arrayDecoder =
                        Bytes.Decode.loop
                            { valuesLeft = maximumValues
                            , arr = []
                            }
                            (\{ valuesLeft, arr } ->
                                if valuesLeft > 0 then
                                    decoder endianness
                                        |> Bytes.Decode.map (\val ->
                                            Bytes.Decode.Loop
                                                { valuesLeft = valuesLeft - 1
                                                , arr = Array.pushLast val arr
                                                }
                                        )
                                else
                                    Bytes.Decode.Done arr
                                        |> Bytes.Decode.succeed
                            )
                in
                test "When passed a number greater than the maximum number of values that can be generated, generates the maxiumum number of values"
                    (\_ ->
                        Bytes.Decode.decode arrayDecoder values
                            |> Maybe.map Array.length
                            |> Expect.equal (Just maximumValues)
                    )
            )
        , await
            (generator -9)
            ("Attempt to generate a negative number of values for " ++ label)
            (\values ->
                test 
                    "When attempting to generate values with a negative number, returns 0 values" 
                    (\_ -> 
                        Bytes.Decode.decode (decoder endianness) values
                            |> Expect.equal Nothing
                    )
            )
        ]



-- UUID Tests


{-|-}
uuidTests : Crypto.SecureContext -> Test.Runner.Effectful.Test
uuidTests secureContext =
    concat
        [ await 
            (Crypto.randomUuidV4 secureContext)
            "Generate a random V4 UUID" 
            (\randomUuid ->
                describe "Tests for generated v4 UUID"
                    [ test 
                        "Successfully generates string of 36 characters"
                        (\_ ->
                            let
                                expectedLength =
                                    36
                            in
                            if String.count randomUuid == expectedLength then
                                Expect.pass
                            
                            else
                                Expect.fail "The generated UUID was not equal to the expected 36 character"
                        )
                    , test
                        "The 15th character is a 4, indicating the generated id is a v4 UUID"
                        (\_ ->
                            if String.slice 14 15 randomUuid == "4" then
                                Expect.pass
                            
                            else
                                Expect.fail "The generated UUID is not valid"
                        )
                    ]
            )
        ]



-- RSA-OAEP Tests


{-|-}
rsaOaepKeyTests secureContext =
    let
        encryptionLabel =
            Just (Bytes.fromString "a")
    in
    concat 
        [ rsaOaepKeyTestHelper 
            secureContext
            { label = "Crypto.Sha256 + 2048"
            , encryptionLabel = encryptionLabel
            , modulusLength = 2048
            , hash = Crypto.Sha256
            }
        , rsaOaepKeyTestHelper 
            secureContext
            { label = "Crypto.Sha384 + 2048"
            , encryptionLabel = encryptionLabel
            , modulusLength = 2048
            , hash = Crypto.Sha384
            }
        , rsaOaepKeyTestHelper 
            secureContext
            { label = "Crypto.Sha512 + 2048"
            , encryptionLabel = encryptionLabel
            , modulusLength = 2048
            , hash = Crypto.Sha512
            }
        , rsaOaepKeyTestHelper 
            secureContext
            { label = "Crypto.Sha256 + 4096"
            , encryptionLabel = encryptionLabel
            , modulusLength = 4096
            , hash = Crypto.Sha256
            }
        , rsaOaepKeyTestHelper 
            secureContext
            { label = "Crypto.Sha384 + 4096"
            , encryptionLabel = encryptionLabel
            , modulusLength = 4096
            , hash = Crypto.Sha384
            }
        , rsaOaepKeyTestHelper 
            secureContext
            { label = "Crypto.Sha512 + 4096"
            , encryptionLabel = encryptionLabel
            , modulusLength = 4096
            , hash = Crypto.Sha512
            }
        ]


{-|-}
rsaOaepKeyTestHelper secureContext { label, encryptionLabel, modulusLength, hash } =
    let
        withLabel string =
            label ++ ": " ++ string

        exportPublicKeyAsSpki label_ publicKey =
            await
                (Crypto.exportRsaOaepPublicKeyAsSpki publicKey)
                (withLabel ("Exporting public key to SPKI " ++ label_))
                (\exportedKey ->
                    concat
                        [ await
                            (Crypto.importRsaOaepPublicKeyFromSpki 
                                exportedKey
                                { hash = hash
                                }
                                Crypto.CanBeExtracted
                                secureContext
                            ) 
                            (withLabel "Importing a successfully extracted public key")
                            (\importedKey ->
                                test "The imported key matches the original key"
                                    (\_ ->
                                        Expect.equal importedKey publicKey
                                    )
                            )
                        , await
                            (Crypto.importRsaOaepPublicKeyFromSpki 
                                exportedKey
                                { hash = shuffleDigestAlgorithm hash
                                }
                                Crypto.CanBeExtracted
                                secureContext
                            ) 
                            (withLabel "Importing a successfully extracted public key with the wrong hash")
                            (\importedKey ->
                                test "The imported key does not equal the original key given the different hash used to generate it"
                                    (\_ ->
                                        Expect.notEqual importedKey publicKey
                                    )
                            )
                        ]
                )

        exportPublicKeyAsJwk label_ publicKey =
            await
                (Crypto.exportRsaOaepPublicKeyAsJwk publicKey)
                (withLabel ("Exporting public key as JWK " ++ label_))
                (\exportedKey ->
                    concat
                        [ await
                            (Crypto.importRsaOaepPublicKeyFromJwk 
                                exportedKey
                                { hash = hash
                                }
                                Crypto.CanBeExtracted
                                secureContext
                            ) 
                            (withLabel "Importing a successfully extracted public key")
                            (\importedKey ->
                                test "The imported key matches the original key"
                                    (\_ ->
                                        Expect.equal importedKey publicKey
                                    )
                            )
                        , awaitError
                            (Crypto.importRsaOaepPublicKeyFromJwk
                                exportedKey
                                { hash = shuffleDigestAlgorithm hash
                                }
                                Crypto.CanBeExtracted
                                secureContext
                            ) 
                            (withLabel "Importing a successfully extracted public key with the wrong hash")
                            (\err ->
                                test "The import fails with the correct error"
                                    (\_ ->
                                        Expect.equal err Crypto.ImportRsaKeyError
                                    )
                            )
                        ]
                )
    in
    concat
        [ await
            (Crypto.generateRsaOaepKeyPair
                { modulusLength = modulusLength
                , hash = hash
                , extractable = Crypto.CannotBeExtracted
                }
                secureContext
            )
            (withLabel "Generating a key pair when that is marked as no extractable")
            (\{ publicKey, privateKey } ->
                concat
                    [ exportPublicKeyAsSpki "When not extractable" publicKey
                    , exportPublicKeyAsJwk "When not extractable" publicKey
                    , awaitError
                        (Crypto.exportRsaOaepPrivateKeyAsPkcs8 privateKey)
                        (withLabel "Exporting private RSA-OAEP key as PKCS8 when not extractable")
                        (\res ->
                            test (withLabel "Fails")
                                (\_ ->
                                    Expect.equal res Crypto.KeyNotExportable
                                )
                        )
                    , awaitError
                        (Crypto.exportRsaOaepPrivateKeyAsJwk privateKey)
                        (withLabel "Exporting private RSA-OAEP key as JWK when not extractable")
                        (\res ->
                            test (withLabel "Fails")
                                (\_ ->
                                    Expect.equal res Crypto.KeyNotExportable
                                )
                        ) 
                    ]
            )
        , await 
            (Crypto.generateRsaOaepKeyPair
                { modulusLength = modulusLength
                , hash = hash
                , extractable = Crypto.CanBeExtracted
                }
                secureContext
            )
            (withLabel "Generating a key pair when that is marked as extractable")
            (\{ publicKey, privateKey } ->
                let
                    encryptionBytes =
                        Bytes.fromString "encryption test string"
                in
                concat
                    [ exportPublicKeyAsSpki "When extractable" publicKey
                    , exportPublicKeyAsJwk "When extractable" publicKey
                    , await
                        (Crypto.exportRsaOaepPrivateKeyAsPkcs8 privateKey)
                        (withLabel "Exporting private RSA-OAEP key as PKCS8 when extractable")
                        (\exportedKey ->
                            concat 
                                [ await
                                    (Crypto.importRsaOaepPrivateKeyFromPkcs8 
                                        exportedKey
                                        { hash = hash
                                        }
                                        Crypto.CanBeExtracted
                                        secureContext
                                    ) 
                                    (withLabel "Importing a successfully extracted private key")
                                    (\importedKey ->
                                        test "The imported key matches the original key"
                                            (\_ ->
                                                Expect.equal importedKey privateKey
                                            )
                                    )
                                , await
                                    (Crypto.importRsaOaepPrivateKeyFromPkcs8 
                                        exportedKey
                                        { hash = shuffleDigestAlgorithm hash
                                        }
                                        Crypto.CanBeExtracted
                                        secureContext
                                    ) 
                                    (withLabel "Importing a successfully extracted private key with the wrong hash")
                                    (\importedKey ->
                                        test "The imported key does not match the original key"
                                            (\_ ->
                                                Expect.notEqual importedKey privateKey
                                            )
                                    )
                                ]
                        )
                    , await
                        (Crypto.exportRsaOaepPrivateKeyAsJwk privateKey)
                        (withLabel "Exporting private RSA-OAEP key as JWK when extractable")
                        (\exportedKey ->
                            concat 
                                [ await
                                    (Crypto.importRsaOaepPrivateKeyFromJwk 
                                        exportedKey
                                        { hash = hash
                                        }
                                        Crypto.CanBeExtracted
                                        secureContext
                                    ) 
                                    (withLabel "Importing a successfully extracted private key")
                                    (\importedKey ->
                                        test "The imported key matches the original key"
                                            (\_ ->
                                                Expect.equal importedKey privateKey
                                            )
                                    )
                                , awaitError
                                    (Crypto.importRsaOaepPrivateKeyFromJwk 
                                        exportedKey
                                        { hash = shuffleDigestAlgorithm hash
                                        }
                                        Crypto.CanBeExtracted
                                        secureContext
                                    ) 
                                    (withLabel "Importing a successfully extracted private key with the wrong hash")
                                    (\err ->
                                        test "The error returned matches the expected error"
                                            (\_ ->
                                                Expect.equal err Crypto.ImportRsaKeyError
                                            )
                                    )
                                ]
                        )
                    , await
                        (Crypto.encryptWithRsaOaep
                            { label = encryptionLabel
                            }
                            publicKey
                            encryptionBytes
                        )
                        "Test encrypting a string with an RSA-OAEP public key and no label"
                        (\encryptedBytes ->
                            concat
                                [ test "The resulting encrypted bytes do not match the original bytes"
                                    (\_ ->
                                        Expect.notEqual encryptionBytes encryptedBytes
                                    )
                                , await
                                    (Crypto.decryptWithRsaOaep
                                        { label = encryptionLabel
                                        }
                                        privateKey
                                        encryptedBytes
                                    )
                                    "Attempt to decrypt the encrypted bytes"
                                    (\decryptedBytes ->
                                        test "Bytes that were encrypted and then decrypted with the same public/prviate key pair equal the origianl value"
                                            (\_ ->
                                                Expect.equal encryptionBytes decryptedBytes
                                            )
                                    )
                                , awaitError
                                    (Crypto.decryptWithRsaOaep
                                        { label = 
                                            when encryptionLabel is
                                                Just _ ->
                                                    Nothing
                                                
                                                Nothing ->
                                                    Just encryptionBytes
                                        }
                                        privateKey
                                        encryptedBytes
                                    )
                                    "When the label does not match the label given, fails"
                                    (\err -> 
                                        test "The error equal the expected error" 
                                            (\_ -> 
                                                Expect.equal err Crypto.RsaOaepDecryptionError
                                            )
                                    )
                                ]
                        )
                    ]
            )
        ]



-- AES-CTR Tests


{-|-}
aesCtrTests =
    Debug.todo "aesCtrTests"


{-|-}
aesCtrTestsHelper secureContext label { aesLength } =
    let
        withLabel string =
            label ++ ": " ++ string
    in
    concat 
        [ await
            (Crypto.generateAesCtrKey
                { length = aesLength
                , extractable = Crypto.CannotBeExtracted 
                }
                secureContext
            )
            (withLabel "Generating a key that is marked as not extractable")
            (\key ->
                test "testing"
                    (\_ ->
                        Expect.pass
                    )
            )
        , await
            (Crypto.generateAesCtrKey
                { length = aesLength
                , extractable = Crypto.CanBeExtracted 
                }
                secureContext
            )
            (withLabel "Generating a key that is marked as extractable")
            (\key ->
                test "testing"
                    (\_ ->
                        Expect.pass
                    )
            )
        ]



-- AES-CBC Tests


{-|-}
aesCbcTests =
    Debug.todo "aesCbcTests"



-- AES-GCM Tests


{-|-}
aesGcmTests =
    Debug.todo "aesGcmTests"



-- RSA-SSAPKCS1v1.5 Tests


{-|-}
rsaSsaPkcs1V1_5KeyTests =
    Debug.todo "rsaSsaPkcs1V1_5KeyTests"



-- RSA-PSS Tests


{-|-}
rsaPssTests =
    Debug.todo "rsaPssTests"



-- ECDSA Tests


{-|-}
ecdsaTests =
    Debug.todo "ecdsaTests"



-- HMAC Tests


{-|-}
hmacTests =
    Debug.todo "hmacTests"



-- SHA Tests


{-|-}
shaTests =
    Debug.todo "shaTests"



-- Utilities


{-| Change the passed `DigestAlgorithm` into another `DigestAlgorithm`.

Used when testing algorithms that use different digest algorithms.
-}
shuffleDigestAlgorithm : Crypto.DigestAlgorithm -> Crypto.DigestAlgorithm
shuffleDigestAlgorithm hash =
    when hash is
        Crypto.Sha256 ->
            Crypto.Sha512

        Crypto.Sha384 ->
            Crypto.Sha256

        Crypto.Sha512 ->
            Crypto.Sha384
