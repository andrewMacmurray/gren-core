module Test.Crypto exposing (tests)

{-|-}

import Basics exposing (..)
import Math
import Expect
import Array exposing (..)
import Maybe exposing (Maybe(..))
import Test.Runner.Effectful exposing (fuzz, describe, concat, test, await, awaitError, run)
import Task exposing ( Task )
import Crypto
import Bytes exposing ( Bytes )
import Bytes.Decode


{-| All tests on the node platform for the `Crypto` module
-}
tests : Test.Runner.Effectful.Test
tests = 
    concat 
        [ await Crypto.getSecureContext 
            "`Crypto.getSecureContext` successfully runs and returns a value" 
            (\secureContext ->
                concat 
                    [ uuidTests secureContext
                    , rsaOaepKeyTests secureContext
                    , aesCtrTests secureContext
                    , aesCbcTests secureContext
                    , aesGcmTests secureContext
                    ]
            )
        , await Bytes.getHostEndianness
            "Get host endianness for required tests" 
            (\endianness ->
                concat 
                    [ randomValueTests endianness
                    ]
            )
        ]



-- Random Value Tests


{-|-}
type alias RandomValueTestsHelper x =
    { label : String
    , generator : Int -> Task x Bytes
    , decoder : Bytes.Endianness -> Bytes.Decode.Decoder Int
    , min : Int
    , max : Int
    , maximumPossibleValues : Int
    }


{-| Tests for all the random value generation functions
-}
randomValueTests : Bytes.Endianness -> Test.Runner.Effectful.Test
randomValueTests endianness =
    concat
        [ randomValueTestsHelper 
            endianness
            { label = "int8"
            , generator = Crypto.getRandomInt8Values
            , decoder = \_ -> Bytes.Decode.signedInt8
            , min = -128
            , max = 128
            , maximumPossibleValues = 65536
            }
        , randomValueTestsHelper 
            endianness
            { label = "uint8"
            , generator = Crypto.getRandomUInt8Values
            , decoder = \_ -> Bytes.Decode.unsignedInt8
            , min = 0
            , max = 256
            , maximumPossibleValues = 65536
            }
        , randomValueTestsHelper 
            endianness
            { label = "int16"
            , generator = Crypto.getRandomInt16Values
            , decoder = Bytes.Decode.signedInt16
            , min = -32767
            , max = 32767
            , maximumPossibleValues = 32768
            }
        , randomValueTestsHelper 
            endianness
            { label = "uint16"
            , generator = Crypto.getRandomUInt16Values
            , decoder = Bytes.Decode.unsignedInt16
            , min = 0
            , max = 65535
            , maximumPossibleValues = 32768
            }
        , randomValueTestsHelper 
            endianness
            { label = "int32"
            , generator = Crypto.getRandomInt32Values
            , decoder = Bytes.Decode.signedInt32
            , min = -2147483648
            , max = 2147483648
            , maximumPossibleValues = 16384
            }
        , randomValueTestsHelper 
            endianness
            { label = "uint32"
            , generator = Crypto.getRandomUInt32Values
            , decoder = Bytes.Decode.unsignedInt32
            , min = 0
            , max = 4294967295
            , maximumPossibleValues = 16384
            }
        ]


{-| A helper for generating tests for the random value functions.
-}
randomValueTestsHelper : Bytes.Endianness -> RandomValueTestsHelper a -> Test.Runner.Effectful.Test
randomValueTestsHelper endianness { label, generator, decoder, min, max, maximumPossibleValues } =
    concat
        [ await
            (generator 1)
            ("Generate a random " ++ label)
            (\values ->
                test 
                    "Generated `Bytes` can be decoded and are within their expected value range"
                    (\_ ->
                        when Bytes.Decode.decode (decoder endianness) values is
                            Just num ->
                                if num >= min && num <= max then
                                    Expect.pass
                                    
                                else
                                    Expect.fail "Generated `Bytes` not within expected values"

                            Nothing ->
                                Expect.fail "Generated `Bytes` were not successfully decoded"
                    )
            )
        , await
            (generator 99999)
            ("Generate the maximum possible values of " ++ label)
            (\values ->
                let
                    maximumValues =
                        maximumPossibleValues

                    arrayDecoder =
                        Bytes.Decode.loop
                            { valuesLeft = maximumValues
                            , arr = []
                            }
                            (\{ valuesLeft, arr } ->
                                if valuesLeft > 0 then
                                    decoder endianness
                                        |> Bytes.Decode.map (\val ->
                                            Bytes.Decode.Loop
                                                { valuesLeft = valuesLeft - 1
                                                , arr = Array.pushLast val arr
                                                }
                                        )
                                else
                                    Bytes.Decode.Done arr
                                        |> Bytes.Decode.succeed
                            )
                in
                test "When passed a number greater than the maximum number of values that can be generated, generates the maxiumum number of values"
                    (\_ ->
                        Bytes.Decode.decode arrayDecoder values
                            |> Maybe.map Array.length
                            |> Expect.equal (Just maximumValues)
                    )
            )
        , await
            (generator -9)
            ("Attempt to generate a negative number of values for " ++ label)
            (\values ->
                test 
                    "When attempting to generate values with a negative number, returns 0 values" 
                    (\_ -> 
                        Bytes.Decode.decode (decoder endianness) values
                            |> Expect.equal Nothing
                    )
            )
        ]



-- UUID Tests


{-|-}
uuidTests : Crypto.SecureContext -> Test.Runner.Effectful.Test
uuidTests secureContext =
    concat
        [ await 
            (Crypto.randomUuidV4 secureContext)
            "Generate a random V4 UUID" 
            (\randomUuid ->
                describe "Tests for generated v4 UUID"
                    [ test 
                        "Successfully generates string of 36 characters"
                        (\_ ->
                            let
                                expectedLength =
                                    36
                            in
                            if String.count randomUuid == expectedLength then
                                Expect.pass
                            
                            else
                                Expect.fail "The generated UUID was not equal to the expected 36 character"
                        )
                    , test
                        "The 15th character is a 4, indicating the generated id is a v4 UUID"
                        (\_ ->
                            if String.slice 14 15 randomUuid == "4" then
                                Expect.pass
                            
                            else
                                Expect.fail "The generated UUID is not valid"
                        )
                    ]
            )
        ]



-- RSA-OAEP Tests


{-|-}
rsaOaepKeyTests secureContext =
    let
        encryptionLabel =
            Just (Bytes.fromString "a")
    in
    concat 
        [ rsaOaepKeyTestHelper 
            secureContext
            { label = "Crypto.Sha256 + 2048"
            , encryptionLabel = encryptionLabel
            , modulusLength = 2048
            , hash = Crypto.Sha256
            }
        , rsaOaepKeyTestHelper 
            secureContext
            { label = "Crypto.Sha384 + 2048"
            , encryptionLabel = encryptionLabel
            , modulusLength = 2048
            , hash = Crypto.Sha384
            }
        , rsaOaepKeyTestHelper 
            secureContext
            { label = "Crypto.Sha512 + 2048"
            , encryptionLabel = encryptionLabel
            , modulusLength = 2048
            , hash = Crypto.Sha512
            }
        , rsaOaepKeyTestHelper 
            secureContext
            { label = "Crypto.Sha256 + 4096"
            , encryptionLabel = encryptionLabel
            , modulusLength = 4096
            , hash = Crypto.Sha256
            }
        , rsaOaepKeyTestHelper 
            secureContext
            { label = "Crypto.Sha384 + 4096"
            , encryptionLabel = encryptionLabel
            , modulusLength = 4096
            , hash = Crypto.Sha384
            }
        , rsaOaepKeyTestHelper 
            secureContext
            { label = "Crypto.Sha512 + 4096"
            , encryptionLabel = encryptionLabel
            , modulusLength = 4096
            , hash = Crypto.Sha512
            }
        ]


{-|-}
rsaOaepKeyTestHelper secureContext { label, encryptionLabel, modulusLength, hash } =
    let
        withLabel string =
            label ++ ": " ++ string

        exportPublicKeyAsSpki label_ publicKey =
            await
                (Crypto.exportRsaOaepPublicKeyAsSpki publicKey)
                (withLabel ("Exporting public key to SPKI " ++ label_))
                (\exportedKey ->
                    concat
                        [ await
                            (Crypto.importRsaOaepPublicKeyFromSpki 
                                exportedKey
                                { hash = hash
                                }
                                Crypto.CanBeExtracted
                                secureContext
                            ) 
                            (withLabel "Importing a successfully extracted public key")
                            (\importedKey ->
                                test "The imported key matches the original key"
                                    (\_ ->
                                        Expect.equal importedKey publicKey
                                    )
                            )
                        , await
                            (Crypto.importRsaOaepPublicKeyFromSpki 
                                exportedKey
                                { hash = shuffleDigestAlgorithm hash
                                }
                                Crypto.CanBeExtracted
                                secureContext
                            ) 
                            (withLabel "Importing a successfully extracted public key with the wrong hash")
                            (\importedKey ->
                                test "The imported key does not equal the original key given the different hash used to generate it"
                                    (\_ ->
                                        Expect.notEqual importedKey publicKey
                                    )
                            )
                        ]
                )

        exportPublicKeyAsJwk label_ publicKey =
            await
                (Crypto.exportRsaOaepPublicKeyAsJwk publicKey)
                (withLabel ("Exporting public key as JWK " ++ label_))
                (\exportedKey ->
                    concat
                        [ await
                            (Crypto.importRsaOaepPublicKeyFromJwk 
                                exportedKey
                                { hash = hash
                                }
                                Crypto.CanBeExtracted
                                secureContext
                            ) 
                            (withLabel "Importing a successfully extracted public key")
                            (\importedKey ->
                                test "The imported key matches the original key"
                                    (\_ ->
                                        Expect.equal importedKey publicKey
                                    )
                            )
                        , awaitError
                            (Crypto.importRsaOaepPublicKeyFromJwk
                                exportedKey
                                { hash = shuffleDigestAlgorithm hash
                                }
                                Crypto.CanBeExtracted
                                secureContext
                            ) 
                            (withLabel "Importing a successfully extracted public key with the wrong hash")
                            (\err ->
                                test "The import fails with the correct error"
                                    (\_ ->
                                        Expect.equal err Crypto.ImportRsaKeyError
                                    )
                            )
                        ]
                )
    in
    concat
        [ await
            (Crypto.generateRsaOaepKeyPair
                { modulusLength = modulusLength
                , hash = hash
                , extractable = Crypto.CannotBeExtracted
                }
                secureContext
            )
            (withLabel "Generating a key pair when that is marked as no extractable")
            (\{ publicKey, privateKey } ->
                concat
                    [ exportPublicKeyAsSpki "When not extractable" publicKey
                    , exportPublicKeyAsJwk "When not extractable" publicKey
                    , awaitError
                        (Crypto.exportRsaOaepPrivateKeyAsPkcs8 privateKey)
                        (withLabel "Exporting private RSA-OAEP key as PKCS8 when not extractable")
                        (\res ->
                            test (withLabel "Fails")
                                (\_ ->
                                    Expect.equal res Crypto.KeyNotExportable
                                )
                        )
                    , awaitError
                        (Crypto.exportRsaOaepPrivateKeyAsJwk privateKey)
                        (withLabel "Exporting private RSA-OAEP key as JWK when not extractable")
                        (\res ->
                            test (withLabel "Fails")
                                (\_ ->
                                    Expect.equal res Crypto.KeyNotExportable
                                )
                        ) 
                    ]
            )
        , await 
            (Crypto.generateRsaOaepKeyPair
                { modulusLength = modulusLength
                , hash = hash
                , extractable = Crypto.CanBeExtracted
                }
                secureContext
            )
            (withLabel "Generating a key pair when that is marked as extractable")
            (\{ publicKey, privateKey } ->
                let
                    encryptionBytes =
                        Bytes.fromString "encryption test string"
                in
                concat
                    [ exportPublicKeyAsSpki "When extractable" publicKey
                    , exportPublicKeyAsJwk "When extractable" publicKey
                    , await
                        (Crypto.exportRsaOaepPrivateKeyAsPkcs8 privateKey)
                        (withLabel "Exporting private RSA-OAEP key as PKCS8 when extractable")
                        (\exportedKey ->
                            concat 
                                [ await
                                    (Crypto.importRsaOaepPrivateKeyFromPkcs8 
                                        exportedKey
                                        { hash = hash
                                        }
                                        Crypto.CanBeExtracted
                                        secureContext
                                    ) 
                                    (withLabel "Importing a successfully extracted private key")
                                    (\importedKey ->
                                        test "The imported key matches the original key"
                                            (\_ ->
                                                Expect.equal importedKey privateKey
                                            )
                                    )
                                , await
                                    (Crypto.importRsaOaepPrivateKeyFromPkcs8 
                                        exportedKey
                                        { hash = shuffleDigestAlgorithm hash
                                        }
                                        Crypto.CanBeExtracted
                                        secureContext
                                    ) 
                                    (withLabel "Importing a successfully extracted private key with the wrong hash")
                                    (\importedKey ->
                                        test "The imported key does not match the original key"
                                            (\_ ->
                                                Expect.notEqual importedKey privateKey
                                            )
                                    )
                                ]
                        )
                    , await
                        (Crypto.exportRsaOaepPrivateKeyAsJwk privateKey)
                        (withLabel "Exporting private RSA-OAEP key as JWK when extractable")
                        (\exportedKey ->
                            concat 
                                [ await
                                    (Crypto.importRsaOaepPrivateKeyFromJwk 
                                        exportedKey
                                        { hash = hash
                                        }
                                        Crypto.CanBeExtracted
                                        secureContext
                                    ) 
                                    (withLabel "Importing a successfully extracted private key")
                                    (\importedKey ->
                                        test "The imported key matches the original key"
                                            (\_ ->
                                                Expect.equal importedKey privateKey
                                            )
                                    )
                                , awaitError
                                    (Crypto.importRsaOaepPrivateKeyFromJwk 
                                        exportedKey
                                        { hash = shuffleDigestAlgorithm hash
                                        }
                                        Crypto.CanBeExtracted
                                        secureContext
                                    ) 
                                    (withLabel "Importing a successfully extracted private key with the wrong hash")
                                    (\err ->
                                        test "The error returned matches the expected error"
                                            (\_ ->
                                                Expect.equal err Crypto.ImportRsaKeyError
                                            )
                                    )
                                ]
                        )
                    , await
                        (Crypto.encryptWithRsaOaep
                            { label = encryptionLabel
                            }
                            publicKey
                            encryptionBytes
                        )
                        "Test encrypting a string with an RSA-OAEP public key and no label"
                        (\encryptedBytes ->
                            concat
                                [ test "The resulting encrypted bytes do not match the original bytes"
                                    (\_ ->
                                        Expect.notEqual encryptionBytes encryptedBytes
                                    )
                                , await
                                    (Crypto.decryptWithRsaOaep
                                        { label = encryptionLabel
                                        }
                                        privateKey
                                        encryptedBytes
                                    )
                                    "Attempt to decrypt the encrypted bytes"
                                    (\decryptedBytes ->
                                        test "Bytes that were encrypted and then decrypted with the same public/prviate key pair equal the origianl value"
                                            (\_ ->
                                                Expect.equal encryptionBytes decryptedBytes
                                            )
                                    )
                                , awaitError
                                    (Crypto.decryptWithRsaOaep
                                        { label = 
                                            when encryptionLabel is
                                                Just _ ->
                                                    Nothing
                                                
                                                Nothing ->
                                                    Just encryptionBytes
                                        }
                                        privateKey
                                        encryptedBytes
                                    )
                                    "When the label does not match the label given, fails"
                                    (\err -> 
                                        test "The error equal the expected error" 
                                            (\_ -> 
                                                Expect.equal err Crypto.RsaOaepDecryptionError
                                            )
                                    )
                                ]
                        )
                    ]
            )
        ]



-- AES-CTR Tests


{-| All the tests for the AES-CTR algorithm.

These tests cover all possible `AesCtrLength` values with varying used when 
encrypting values. The passed length should not affect the outcome of the 
test, given the value is always clamped to what is acceptable, but want to
have some tests to make sure that remains true.
-}
aesCtrTests secureContext =
    concat
        [ aesCtrTestsHelper 
            secureContext 
            "AesLength128 - length 128" 
            { aesLength = Crypto.AesLength128 
            , encryptionLength = 128
            }
        , aesCtrTestsHelper 
            secureContext 
            "AesLength192 - length 128" 
            { aesLength = Crypto.AesLength192 
            , encryptionLength = 128
            }
        , aesCtrTestsHelper 
            secureContext 
            "AesLength256 - length 128" 
            { aesLength = Crypto.AesLength256 
            , encryptionLength = 128
            }
        , aesCtrTestsHelper 
            secureContext 
            "AesLength128 - length 13040313" 
            { aesLength = Crypto.AesLength128 
            , encryptionLength = 13040313
            }
        , aesCtrTestsHelper 
            secureContext 
            "AesLength192 - length 13040313" 
            { aesLength = Crypto.AesLength192 
            , encryptionLength = 13040313
            }
        , aesCtrTestsHelper 
            secureContext 
            "AesLength256 - length 13040313" 
            { aesLength = Crypto.AesLength256 
            , encryptionLength = 13040313
            }
        , aesCtrTestsHelper 
            secureContext 
            "AesLength128 - length 1" 
            { aesLength = Crypto.AesLength128 
            , encryptionLength = 1
            }
        , aesCtrTestsHelper 
            secureContext 
            "AesLength192 - length 1" 
            { aesLength = Crypto.AesLength192 
            , encryptionLength = 1
            }
        , aesCtrTestsHelper 
            secureContext 
            "AesLength256 - length 1" 
            { aesLength = Crypto.AesLength256 
            , encryptionLength = 1
            }
        ]


{-|-}
aesCtrTestsHelper secureContext label { aesLength, encryptionLength } =
    let
        withLabel string =
            label ++ ": " ++ string
    in
    concat 
        [ await
            (Crypto.generateAesCtrKey
                { length = aesLength
                , extractable = Crypto.CannotBeExtracted 
                }
                secureContext
            )
            (withLabel "Generating a key that is marked as not extractable")
            (\key ->
                concat
                    [ awaitError
                        (Crypto.exportAesCtrKeyAsRaw key)
                        "Exporting the generated key as RAW"
                        (\err ->
                            test "When exporting non-extractable key, fails with the correct error"
                                (\_ ->
                                    Expect.equal err Crypto.KeyNotExportable
                                )
                        )
                    , awaitError
                        (Crypto.exportAesCtrKeyAsJwk key)
                        "Exporting the generated key as JWK"
                        (\err ->
                            test "When exporting non-extractable key, fails with the correct error"
                                (\_ ->
                                    Expect.equal err Crypto.KeyNotExportable
                                )
                        )
                    ]
            )
        , await
            (Crypto.generateAesCtrKey
                { length = aesLength
                , extractable = Crypto.CanBeExtracted 
                }
                secureContext
            )
            (withLabel "Generating a key that is marked as extractable")
            (\key ->
                let
                    encryptionBytes =
                        Bytes.fromString "encryption test string"
                in
                concat [
                    await
                        (Crypto.exportAesCtrKeyAsRaw key)
                        "Exporting the generated key as RAW"
                        (\exportedKey ->
                            await
                                (Crypto.importAesCtrKeyFromRaw
                                    exportedKey
                                    Crypto.CanBeExtracted
                                    secureContext
                                )
                                "Importing the exported key"
                                (\importedKey ->
                                    test "When importing an exported key, the imported key matches the original"
                                        (\_ ->
                                            Expect.equal importedKey key
                                        )
                                )
                        )
                    , await
                        (Crypto.exportAesCtrKeyAsJwk key)
                        "Exporting the generated key as JWK"
                        (\exportedKey ->
                            await
                                (Crypto.importAesCtrKeyFromJwk
                                    exportedKey
                                    Crypto.CanBeExtracted
                                    secureContext
                                )
                                "Importing the exported key"
                                (\importedKey ->
                                    test "When importing an exported key, the imported key matches the original"
                                        (\_ ->
                                            Expect.equal importedKey key
                                        )
                                )
                        )
                    , await
                        (Crypto.getRandomUInt32Values 4)
                        "Generating 16 bytes of randomness for use as the counter"
                        (\counter ->
                            concat 
                                [ await
                                    (Crypto.encryptWithAesCtr 
                                        { counter = counter
                                        , length = encryptionLength
                                        }
                                        key
                                        encryptionBytes
                                    )
                                    "Encrypting some bytes"
                                    (\encryptedBytes ->
                                        concat 
                                            [ test "The encrypted bytes do not match the original bytes"
                                                (\_ ->
                                                    Expect.notEqual encryptedBytes encryptionBytes
                                                )
                                            , await
                                                (Crypto.decryptWithAesCtr
                                                    { counter = counter
                                                    , length = encryptionLength
                                                    }
                                                    key
                                                    encryptedBytes
                                                )
                                                "Decrypting the encrypted bytes with the same counter and length"
                                                (\decryptedBytes ->
                                                    test "The decrypted bytes equal the original bytes"
                                                        (\_ ->
                                                            Expect.equal decryptedBytes encryptionBytes
                                                        )
                                                )
                                            ]
                                    )
                                ]
                        )
                    , await
                        (Crypto.getRandomUInt32Values 16)
                        "Generating more than 16 bytes of data for the counter"
                        (\counter ->
                            awaitError
                                (Crypto.encryptWithAesCtr 
                                    { counter = counter
                                    , length = encryptionLength
                                    }
                                    key
                                    encryptionBytes
                                )
                                "Encrypting some bytes"
                                (\err ->
                                    test "Encryption fails with the correct error when the counter is wrong"
                                        (\_ ->
                                            Expect.equal err Crypto.AesCtrEncryptionErrorCounterTooLong
                                        )
                                )
                        )
                    , await
                        (Crypto.getRandomUInt32Values 1)
                        "Generating less than 16 bytes for the counter"
                        (\counter ->
                            awaitError
                                (Crypto.encryptWithAesCtr 
                                    { counter = counter
                                    , length = encryptionLength
                                    }
                                    key
                                    encryptionBytes
                                )
                                "Encrypting some bytes"
                                (\err ->
                                    test "Encryption fails with the correct error when the counter is wrong"
                                        (\_ ->
                                            Expect.equal err Crypto.AesCtrEncryptionErrorCounterTooLong
                                        )
                                )
                        )
                ]
            )
        ]



-- AES-CBC Tests


{-|-}
aesCbcTests secureContext =
    concat 
        [ aesCbcTestHelper 
            secureContext 
            "AES-CBC : AesLength128" 
            { aesLength = Crypto.AesLength128
            }
        , aesCbcTestHelper 
            secureContext 
            "AES-CBC : AesLength192" 
            { aesLength = Crypto.AesLength192
            }
        , aesCbcTestHelper 
            secureContext 
            "AES-CBC : AesLength256" 
            { aesLength = Crypto.AesLength256
            }
        ]


{-|-}
aesCbcTestHelper secureContext label { aesLength } =
    let
        withLabel string =
            label ++ ": " ++ string
    in
    concat
        [ await
            (Crypto.generateAesCbcKey
                { length = aesLength
                , extractable = Crypto.CannotBeExtracted 
                }
                secureContext
            )
            (withLabel "Generating a key that is marked as not extractable")
            (\key ->
                concat
                    [ awaitError
                        (Crypto.exportAesCbcKeyAsRaw key)
                        "Exporting the generated key as RAW"
                        (\err ->
                            test "When exporting non-extractable key, fails with the correct error"
                                (\_ ->
                                    Expect.equal err Crypto.KeyNotExportable
                                )
                        )
                    , awaitError
                        (Crypto.exportAesCbcKeyAsJwk key)
                        "Exporting the generated key as JWK"
                        (\err ->
                            test "When exporting non-extractable key, fails with the correct error"
                                (\_ ->
                                    Expect.equal err Crypto.KeyNotExportable
                                )
                        )
                    ]
            )
        , await
            (Crypto.generateAesCbcKey
                { length = aesLength
                , extractable = Crypto.CanBeExtracted 
                }
                secureContext
            )
            (withLabel "Generating a key that is marked as extractable")
            (\key ->
                let
                    encryptionBytes =
                        Bytes.fromString "encryption test string"
                in
                concat 
                    [ await
                        (Crypto.exportAesCbcKeyAsRaw key)
                        "Exporting the generated key as RAW"
                        (\exportedKey ->
                            await
                                (Crypto.importAesCbcKeyFromRaw
                                    exportedKey
                                    Crypto.CanBeExtracted
                                    secureContext
                                )
                                "Importing the exported key"
                                (\importedKey ->
                                    test "When importing an exported key, the imported key matches the original"
                                        (\_ ->
                                            Expect.equal importedKey key
                                        )
                                )
                        )
                    , await
                        (Crypto.exportAesCbcKeyAsJwk key)
                        "Exporting the generated key as JWK"
                        (\exportedKey ->
                            await
                                (Crypto.importAesCbcKeyFromJwk
                                    exportedKey
                                    Crypto.CanBeExtracted
                                    secureContext
                                )
                                "Importing the exported key"
                                (\importedKey ->
                                    test "When importing an exported key, the imported key matches the original"
                                        (\_ ->
                                            Expect.equal importedKey key
                                        )
                                )
                        )
                    , await
                        (Crypto.getRandomUInt32Values 4)
                        "Generating 16 bytes for the iv value"
                        (\generatedBytes ->
                            concat 
                                [ await
                                    (Crypto.encryptWithAesCbc 
                                        { iv = generatedBytes
                                        }
                                        key
                                        encryptionBytes
                                    )
                                    "Encrypting some bytes"
                                    (\encryptedBytes ->
                                        concat 
                                            [ test "The encrypted bytes do not match the original bytes"
                                                (\_ ->
                                                    Expect.notEqual encryptedBytes encryptionBytes
                                                )
                                            , await
                                                (Crypto.decryptWithAesCbc
                                                    { iv = generatedBytes
                                                    }
                                                    key
                                                    encryptedBytes
                                                )
                                                "Decrypting the encrypted bytes with the same iv"
                                                (\decryptedBytes ->
                                                    test "The decrypted bytes equal the original bytes"
                                                        (\_ ->
                                                            Expect.equal decryptedBytes encryptionBytes
                                                        )
                                                )
                                            , await
                                                (Crypto.getRandomUInt32Values 4)
                                                "Generating 16 different bytes for the iv"
                                                (\generatedNewBytes ->
                                                    await
                                                        (Crypto.decryptWithAesCbc
                                                            { iv = generatedNewBytes
                                                            }
                                                            key
                                                            encryptedBytes
                                                        )
                                                        "Decrypting the encrypted bytes with a different iv than used to encrypt"
                                                        (\decryptedBytes ->
                                                            test "When the decryption bytes are different than encryption bytes, the original bytes do not match the decrypted bytes"
                                                                (\_ ->
                                                                    Expect.notEqual decryptedBytes encryptedBytes
                                                                )
                                                        )
                                                )
                                            , await
                                                (Crypto.getRandomUInt32Values 8)
                                                "Generating too many bytes for the iv value"
                                                (\generatedTooMayBytes ->
                                                    awaitError
                                                        (Crypto.decryptWithAesCbc
                                                            { iv = generatedTooMayBytes
                                                            }
                                                            key
                                                            encryptedBytes
                                                        )
                                                        "Decrypting the encrypted bytes with not enough bytes for the iv"
                                                        (\err ->
                                                            test "When decrypting without enough bytes, produces the correct error"
                                                                (\_ ->
                                                                    Expect.equal err Crypto.AesCtrDecryptionErrorIvTooLong
                                                                )
                                                        )
                                                )
                                            , await
                                                (Crypto.getRandomUInt32Values 2)
                                                "Generating too little bytes for the iv value"
                                                (\generatdTooLittleBytes ->
                                                    awaitError
                                                        (Crypto.decryptWithAesCbc
                                                            { iv = generatdTooLittleBytes
                                                            }
                                                            key
                                                            encryptedBytes
                                                        )
                                                        "Decrypting the encrypted bytes with too many bytes for the iv"
                                                        (\err ->
                                                            test "When decrypting with too many bytes, produces the correct error"
                                                                (\_ ->
                                                                    Expect.equal err Crypto.AesCtrDecryptionErrorIvTooLong
                                                                )
                                                        )
                                                )
                                            ]
                                    )
                                ]
                        )
                    , await
                        (Crypto.getRandomUInt32Values 8)
                        "Generating too many bytes of data for the iv value"
                        (\generatedBytes ->
                            awaitError
                                (Crypto.encryptWithAesCbc 
                                    { iv = generatedBytes
                                    }
                                    key
                                    encryptionBytes
                                )
                                "Encrypting some bytes"
                                (\err ->
                                    test "Encryption fails with the correct error when the iv is wrong"
                                        (\_ ->
                                            Expect.equal err Crypto.AesCbcEncryptionErrorIvTooLong
                                        )
                                )
                        )
                    , await
                        (Crypto.getRandomUInt32Values 2)
                        "Generating too little bytes of data for the iv value"
                        (\generatedBytes ->
                            awaitError
                                (Crypto.encryptWithAesCbc 
                                    { iv = generatedBytes
                                    }
                                    key
                                    encryptionBytes
                                )
                                "Encrypting some bytes"
                                (\err ->
                                    test "Encryption fails with the correct error when the iv is wrong"
                                        (\_ ->
                                            Expect.equal err Crypto.AesCbcEncryptionErrorIvTooLong
                                        )
                                )
                        )
                    ]
            )
        ]



-- AES-GCM Tests


{-|-}
aesGcmTests secureContext =
    concat
        [ aesGcmTestsHelper
            secureContext 
            "AES-GCM : AesLength128" 
            { aesLength = Crypto.AesLength128
            , tagLength = Nothing
            }
        , aesGcmTestsHelper
            secureContext 
            "AES-GCM : AesLength128 AesGcmTagLength96" 
            { aesLength = Crypto.AesLength128
            , tagLength = Just Crypto.AesGcmTagLength96
            }
        , aesGcmTestsHelper
            secureContext 
            "AES-GCM : AesLength128, AesGcmTagLength104" 
            { aesLength = Crypto.AesLength128
            , tagLength = Just Crypto.AesGcmTagLength104
            }
        , aesGcmTestsHelper
            secureContext 
            "AES-GCM : AesLength128 AesGcmTagLength112" 
            { aesLength = Crypto.AesLength128
            , tagLength = Just Crypto.AesGcmTagLength112
            }
        , aesGcmTestsHelper
            secureContext 
            "AES-GCM : AesLength128 AesGcmTagLength120" 
            { aesLength = Crypto.AesLength128
            , tagLength = Just Crypto.AesGcmTagLength120
            }
        , aesGcmTestsHelper
            secureContext 
            "AES-GCM : AesLength128 AesGcmTagLength128" 
            { aesLength = Crypto.AesLength128
            , tagLength = Just Crypto.AesGcmTagLength128
            }
        , aesGcmTestsHelper 
            secureContext 
            "AES-GCM : AesLength192" 
            { aesLength = Crypto.AesLength192
            , tagLength = Nothing
            }
        , aesGcmTestsHelper 
            secureContext 
            "AES-GCM : AesLength192 AesGcmTagLength96" 
            { aesLength = Crypto.AesLength192
            , tagLength = Just Crypto.AesGcmTagLength96
            }
        , aesGcmTestsHelper 
            secureContext 
            "AES-GCM : AesLength192 AesGcmTagLength104" 
            { aesLength = Crypto.AesLength192
            , tagLength = Just Crypto.AesGcmTagLength104
            }
        , aesGcmTestsHelper 
            secureContext 
            "AES-GCM : AesLength192 AesGcmTagLength112" 
            { aesLength = Crypto.AesLength192
            , tagLength = Just Crypto.AesGcmTagLength112
            }
        , aesGcmTestsHelper 
            secureContext 
            "AES-GCM : AesLength192 AesGcmTagLength120" 
            { aesLength = Crypto.AesLength192
            , tagLength = Just Crypto.AesGcmTagLength120
            }
        , aesGcmTestsHelper 
            secureContext 
            "AES-GCM : AesLength192 AesGcmTagLength128" 
            { aesLength = Crypto.AesLength192
            , tagLength = Just Crypto.AesGcmTagLength128
            }
        , aesGcmTestsHelper 
            secureContext 
            "AES-GCM : AesLength256" 
            { aesLength = Crypto.AesLength256
            , tagLength = Nothing
            }
        , aesGcmTestsHelper 
            secureContext 
            "AES-GCM : AesLength256 AesGcmTagLength96" 
            { aesLength = Crypto.AesLength256
            , tagLength = Just Crypto.AesGcmTagLength96
            }
        , aesGcmTestsHelper 
            secureContext 
            "AES-GCM : AesLength256 AesGcmTagLength104" 
            { aesLength = Crypto.AesLength256
            , tagLength = Just Crypto.AesGcmTagLength104
            }
        , aesGcmTestsHelper 
            secureContext 
            "AES-GCM : AesLength256 AesGcmTagLength112" 
            { aesLength = Crypto.AesLength256
            , tagLength = Just Crypto.AesGcmTagLength112
            }
        , aesGcmTestsHelper 
            secureContext 
            "AES-GCM : AesLength256 AesGcmTagLength120" 
            { aesLength = Crypto.AesLength256
            , tagLength = Just Crypto.AesGcmTagLength120
            }
        , aesGcmTestsHelper 
            secureContext 
            "AES-GCM : AesLength256 AesGcmTagLength128" 
            { aesLength = Crypto.AesLength256
            , tagLength = Just Crypto.AesGcmTagLength128
            }
        ]


{-|-}
aesGcmTestsHelper secureContext label { aesLength, tagLength } =
    let
        withLabel string =
            label ++ ": " ++ string
    in
    concat 
        [ await
            (Crypto.generateAesGcmKey
                { length = aesLength
                , extractable = Crypto.CannotBeExtracted 
                }
                secureContext
            )
            (withLabel "Generating a key that is marked as not extractable")
            (\key ->
                concat
                    [ awaitError
                        (Crypto.exportAesGcmKeyAsRaw key)
                        "Exporting the generated key as RAW"
                        (\err ->
                            test "When exporting non-extractable key, fails with the correct error"
                                (\_ ->
                                    Expect.equal err Crypto.KeyNotExportable
                                )
                        )
                    , awaitError
                        (Crypto.exportAesGcmKeyAsJwk key)
                        "Exporting the generated key as JWK"
                        (\err ->
                            test "When exporting non-extractable key, fails with the correct error"
                                (\_ ->
                                    Expect.equal err Crypto.KeyNotExportable
                                )
                        )
                    ]
            )
        , await
            (Crypto.generateAesGcmKey
                { length = aesLength
                , extractable = Crypto.CanBeExtracted 
                }
                secureContext
            )
            (withLabel "Generating a key that is marked as extractable")
            (\key ->
                let
                    encryptionBytes =
                        Bytes.fromString "encryption test string that is longer..."
                in
                concat
                    [ await
                        (Crypto.exportAesGcmKeyAsRaw key)
                        "Exporting the generated key as RAW"
                        (\exportedKey ->
                            await
                                (Crypto.importAesGcmKeyFromRaw
                                    exportedKey
                                    Crypto.CanBeExtracted
                                    secureContext
                                )
                                "Importing the exported key"
                                (\importedKey ->
                                    test "When importing an exported key, the imported key matches the original"
                                        (\_ ->
                                            Expect.equal importedKey key
                                        )
                                )
                        )
                    , await
                        (Crypto.exportAesGcmKeyAsJwk key)
                        "Exporting the generated key as JWK"
                        (\exportedKey ->
                            await
                                (Crypto.importAesGcmKeyFromJwk
                                    exportedKey
                                    Crypto.CanBeExtracted
                                    secureContext
                                )
                                "Importing the exported key"
                                (\importedKey ->
                                    test "When importing an exported key, the imported key matches the original"
                                        (\_ ->
                                            Expect.equal importedKey key
                                        )
                                )
                        )
                    -- Can, in the future, fuzz the bytes generated to test random values between 12 and 132 bytes
                    , await
                        (Crypto.getRandomUInt32Values 32)
                        "Generating 128 bytes for the iv value"
                        (\generatedBytes ->
                            concat
                                [ await
                                    (Crypto.encryptWithAesGcm 
                                        { iv = generatedBytes
                                        , tagLength = tagLength
                                        , additionalData = Nothing
                                        }
                                        key
                                        encryptionBytes
                                    )
                                    "Encrypting some bytes without additional data"
                                    (\encryptedBytes ->
                                        concat
                                            [ await
                                                (Crypto.decryptWithAesGcm 
                                                    { iv = generatedBytes
                                                    , tagLength = tagLength
                                                    , additionalData = Nothing
                                                    }
                                                    key
                                                    encryptedBytes
                                                )
                                                "Decrypting the bytes with the same additional data"
                                                (\decryptedBytes ->
                                                    test "The decrypted bytes are equal to the original bytes"
                                                        (\_ ->
                                                            Expect.equal encryptionBytes decryptedBytes
                                                        )
                                                )
                                            , await
                                                (Crypto.getRandomUInt32Values 32)
                                                "Generating different additional data"
                                                    (\differentAdditionalData ->
                                                        awaitError
                                                            (Crypto.decryptWithAesGcm 
                                                                { iv = generatedBytes
                                                                , tagLength = tagLength
                                                                , additionalData = Just differentAdditionalData
                                                                }
                                                                key
                                                                encryptedBytes
                                                            )
                                                            "Decrypting the bytes with the different additional data"
                                                            (\err ->
                                                                test "The error equals the expected error"
                                                                    (\_ ->
                                                                        Expect.equal err Crypto.AesGcmDecryptionError
                                                                    )
                                                            )
                                                    )
                                            ]
                                    )
                                ]
                        )
                    , await
                        (Crypto.getRandomUInt32Values 200)
                        "Generating too many bytes of data for the iv value"
                        (\generatedBytes ->
                            concat
                                [ awaitError
                                    (Crypto.encryptWithAesGcm 
                                        { iv = generatedBytes
                                        , tagLength = tagLength
                                        , additionalData = Nothing
                                        }
                                        key
                                        encryptionBytes
                                    )
                                    "Encrypting some bytes without additional data with "
                                    (\err ->
                                        test "Encryption fails with the correct error when the iv is wrong"
                                            (\_ ->
                                                Expect.equal err Crypto.AesGcmEncryptionErrorInvalidIvByteLegth
                                            )
                                    )
                                , awaitError
                                    (Crypto.encryptWithAesGcm 
                                        { iv = generatedBytes
                                        , tagLength = tagLength
                                        , additionalData = Just generatedBytes
                                        }
                                        key
                                        encryptionBytes
                                    )
                                    "Encrypting some bytes with additional data"
                                    (\err ->
                                        test "Encryption fails with the correct error when the iv is wrong"
                                            (\_ ->
                                                Expect.equal err Crypto.AesGcmEncryptionErrorInvalidIvByteLegth
                                            )
                                    )
                                , await
                                    (Crypto.getRandomUInt32Values 5)
                                    "Generating different additional data..."
                                    (\differentAdditionalData ->
                                        awaitError
                                            (Crypto.encryptWithAesGcm 
                                                { iv = generatedBytes
                                                , tagLength = tagLength
                                                , additionalData = Just differentAdditionalData
                                                }
                                                key
                                                encryptionBytes
                                            )
                                            "Encrypting some bytes with additional data that's different..."
                                            (\err ->
                                                test "Encryption fails with the correct error when the iv is wrong"
                                                    (\_ ->
                                                        Expect.equal err Crypto.AesGcmEncryptionErrorInvalidIvByteLegth
                                                    )
                                            )
                                    )
                                ]
                        )
                    , await
                        (Crypto.getRandomUInt32Values 2)
                        "Generating too little bytes of data for the iv value"
                        (\generatedBytes ->
                            concat
                                [ awaitError
                                    (Crypto.encryptWithAesGcm 
                                        { iv = generatedBytes
                                        , tagLength = tagLength
                                        , additionalData = Nothing
                                        }
                                        key
                                        encryptionBytes
                                    )
                                    "Encrypting some bytes without additional data"
                                    (\err ->
                                        test "Encryption fails with the correct error when the iv is wrong"
                                            (\_ ->
                                                Expect.equal err Crypto.AesGcmEncryptionErrorInvalidIvByteLegth
                                            )
                                    )
                                , awaitError
                                    (Crypto.encryptWithAesGcm 
                                        { iv = generatedBytes
                                        , tagLength = tagLength
                                        , additionalData = Just generatedBytes
                                        }
                                        key
                                        encryptionBytes
                                    )
                                    "Encrypting some bytes with additional data"
                                    (\err ->
                                        test "Encryption fails with the correct error when the iv is wrong"
                                            (\_ ->
                                                Expect.equal err Crypto.AesGcmEncryptionErrorInvalidIvByteLegth
                                            )
                                    )
                                , await
                                    (Crypto.getRandomUInt32Values 5)
                                    "Generating different additional data"
                                    (\differentAdditionalData ->
                                        awaitError
                                            (Crypto.encryptWithAesGcm 
                                                { iv = generatedBytes
                                                , tagLength = tagLength
                                                , additionalData = Just differentAdditionalData
                                                }
                                                key
                                                encryptionBytes
                                            )
                                            "Encrypting some bytes with additional data that's different"
                                            (\err ->
                                                test "Encryption fails with the correct error when the iv is wrong"
                                                    (\_ ->
                                                        Expect.equal err Crypto.AesGcmEncryptionErrorInvalidIvByteLegth
                                                    )
                                            )
                                    )
                                ]
                        )
                    ]
            )
        ]



-- RSA-SSAPKCS1v1.5 Tests


{-|-}
rsaSsaPkcs1V1_5KeyTests =
    Debug.todo "rsaSsaPkcs1V1_5KeyTests"



-- RSA-PSS Tests


{-|-}
rsaPssTests =
    Debug.todo "rsaPssTests"



-- ECDSA Tests


{-|-}
ecdsaTests =
    Debug.todo "ecdsaTests"



-- HMAC Tests


{-|-}
hmacTests =
    Debug.todo "hmacTests"



-- SHA Tests


{-|-}
shaTests =
    Debug.todo "shaTests"



-- Utilities


{-| Change the passed `DigestAlgorithm` into another `DigestAlgorithm`.

Used when testing algorithms that use different digest algorithms.
-}
shuffleDigestAlgorithm : Crypto.DigestAlgorithm -> Crypto.DigestAlgorithm
shuffleDigestAlgorithm hash =
    when hash is
        Crypto.Sha256 ->
            Crypto.Sha512

        Crypto.Sha384 ->
            Crypto.Sha256

        Crypto.Sha512 ->
            Crypto.Sha384
