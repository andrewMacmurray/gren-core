module Crypto exposing 
    ( getRandomInt8Values, getRandomUInt8Values
    , getRandomInt16Values, getRandomUInt16Values
    , getRandomInt32Values, getRandomUInt32Values
    , SecureContext, isSecureContext
    , randomUuid
    , Key, PublicKey, PrivateKey, KeyPair
    , Extractable(..)
    , RsaOaepKey, RsaPssKey, RsaSsaPkcs1V1_5Key, RsaKeyParams, PublicExponent(..), RsaKeyGenerationError(..)
    , generateRsaOaepKeyPair, generateRsaPssKeyPair, generateRsaSsaPkcs1V1_5KeyPair
    , AesLength(..)
    , generateAesCtrKey, generateAesCbcKey, generateAesGcmKey
    , EcNamedCurve(..)
    , generateEcdsaKeyPair, generateEcdhKeyPair
    , HmacKeyParams
    , generateHmacKey
    , ExportKeyError(..)
    , exportRsaOaepPublicKeyAsSpki, exportRsaOaepPublicKeyAsJwk
    , exportRsaOaepPrivateKeyAsPkcs8, exportRsaOaepPrivateKeyAsJwk
    , exportRsaPssPublicKeyAsSpki, exportRsaPssPublicKeyAsJwk
    , exportRsaPssPrivateKeyAsPkcs8, exportRsaPssPrivateKeyAsJwk
    , exportRsaSsaPkcs1V1_5PublicKeyAsSpki, exportRsaSsaPkcs1V1_5PublicKeyAsJwk
    , exportRsaSsaPkcs1V1_5PrivateKeyAsPkcs8, exportRsaSsaPkcs1V1_5PrivateKeyAsJwk
    , exportAesCtrKeyAsRaw, exportAesCtrKeyAsJwk
    , exportAesCbcKeyAsRaw, exportAesCbcKeyAsJwk
    , exportAesGcmKeyAsRaw, exportAesGcmKeyAsJwk
    , exportEcdsaPublicKeyAsRaw, exportEcdsaPublicKeyAsSpki, exportEcdsaPublicKeyAsJwt
    , exportEcdsaPrivateKeyAsPkcs8, exportEcdsaPrivateKeyAsJwt
    , exportEcdhPublicKeyAsRaw, exportEcdhPublicKeyAsSpki, exportEcdhPublicKeyAsJwt
    , exportEcdhPrivateKeyAsPkcs8, exportEcdhPrivateKeyAsJwt
    , exportHmacKeyAsRaw, exportHmacKeyAsJwk
    , ImportRsaKeyError(..)
    , importRsaOaepPublicKeyFromJwk
    , DigestAlgorithm(..)
    )


{-| 

This module gives access to various cryptograhic functions provided by the Web 
Crypto API on both `browser` and `node` platforms.

## Generate Random Values

Generate random values of 8, 16, or 32 bits long (signed and unsigned).

All functions for generating random values take an `Int` as the single parameter. 
This value is clamped to a minimum of `0` and a maximum of however many values can
be generated.

The maximum number of values that can be generated depends on the amount of bytes
the values you're generating are. 65536 is the maximum number of bytes that can be
generated. For example, when using `getRandomInt16Values`, each value is 16 bits 
(or 2 bytes), so the maximum number of values that `getRandomInt16Values` can generate
is 32768 values.

@docs getRandomInt8Values, getRandomUInt8Values

@docs getRandomInt16Values, getRandomUInt16Values

@docs getRandomInt32Values, getRandomUInt32Values

## Secure Context

Most functions in this module must be run in a secure context to operate safely
and correctly. Before you use any functions, it's likely you'll need to obtain
and store in your model the `SecureContext` value which can only be generated by
the successfull completion of a `Task` returned by the `isSecureContext` function.

@docs SecureContext, isSecureContext

## Generate Random UUIDs

@docs randomUuid

## Generate Keys

Generate, import, export, and derive keys for completing cryptographic operations. 
Each section covers a different sets of keys that use the same underlying algorithm. 
Each key can be only be used for specific cryptographic operations.

@docs Key, PublicKey, PrivateKey, KeyPair

@docs Extractable

### Generate RSA Keys

Generate keys to use with RSA (Rivest-Shamir-Adleman) algorithm.

@docs RsaOaepKey, RsaPssKey, RsaSsaPkcs1V1_5Key

@docs RsaKeyParams, PublicExponent, RsaKeyGenerationError

@docs generateRsaOaepKeyPair, generateRsaPssKeyPair, generateRsaSsaPkcs1V1_5KeyPair

### Generate AES Keys

@docs AesLength

@docs generateAesCtrKey, generateAesCbcKey, generateAesGcmKey

### Generate ECD Keys

@docs EcNamedCurve

@docs generateEcdsaKeyPair, generateEcdhKeyPair

### Generate HMAC Keys 

@docs HmacKeyParams

@docs generateHmacKey

## Derive Keys

Create keys from other keys.

...

## Export Keys

Export keys in various formats. Available formats depend on the key being exported.

For more information on exporting keys, check out the [MDN web docs](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)
for the Web Crypto API.

@docs ExportKeyError

### Export RSA Keys

@docs exportRsaOaepPublicKeyAsSpki, exportRsaOaepPublicKeyAsJwk

@docs exportRsaOaepPrivateKeyAsPkcs8, exportRsaOaepPrivateKeyAsJwk

@docs exportRsaPssPublicKeyAsSpki, exportRsaPssPublicKeyAsJwk

@docs exportRsaPssPrivateKeyAsPkcs8, exportRsaPssPrivateKeyAsJwk

@docs exportRsaSsaPkcs1V1_5PublicKeyAsSpki, exportRsaSsaPkcs1V1_5PublicKeyAsJwk

@docs exportRsaSsaPkcs1V1_5PrivateKeyAsPkcs8, exportRsaSsaPkcs1V1_5PrivateKeyAsJwk

### Export AES Keys

@docs exportAesCtrKeyAsRaw, exportAesCtrKeyAsJwk

@docs exportAesCbcKeyAsRaw, exportAesCbcKeyAsJwk

@docs exportAesGcmKeyAsRaw, exportAesGcmKeyAsJwk

### Export ECD Keys

@docs exportEcdsaPublicKeyAsRaw, exportEcdsaPublicKeyAsSpki, exportEcdsaPublicKeyAsJwt

@docs exportEcdsaPrivateKeyAsPkcs8, exportEcdsaPrivateKeyAsJwt

@docs exportEcdhPublicKeyAsRaw, exportEcdhPublicKeyAsSpki, exportEcdhPublicKeyAsJwt

@docs exportEcdhPrivateKeyAsPkcs8, exportEcdhPrivateKeyAsJwt

### Export HMAC Keys 

@docs exportHmacKeyAsRaw, exportHmacKeyAsJwk

## Import Keys

Import exported keys.

For more information on exporting keys, check out the [MDN web docs](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey)
for the Web Crypto API.

### Import RSA Keys

Importing RSA keys can fail in the following ways:

- The `DigestAlgorithm` passed does not match the `DigestAlgorithm` of the passed key.
- A `PublicKey` is imported as a `PrivateKey` and vice-versa
- ...

@docs importRsaOaepPublicKeyFromJwk

...

## Encryption

Encrypt some `Bytes`.

## Decryption

Decrypt some `Bytes`.

## Signing

Sign some `Bytes`.

## Verifying

Verify signed `Bytes`.

## Digest

@docs DigestAlgorithm

-}


import Array exposing ( Array )
import Basics exposing ( Never, Bool(..), Int, (>), (<), (<=), (==) )
import Gren.Kernel.Crypto
import String exposing ( String )
import Task exposing ( Task )
import Debug
import Bytes exposing ( Bytes )
import Maybe exposing ( Maybe(..) )
import Result exposing ( Result(..) )
import Set exposing ( Set )
import Bitwise
import Math
import Json.Encode
import Gren.Kernel.Json


-- RANDOM UUID


{-| Generate a random UUID using the UUID v4 algorithm.
-}
randomUuid : SecureContext -> Task x String
randomUuid _context =
    Gren.Kernel.Crypto.randomUUID


-- RANDOM VALUES


{-| Get a `Array` of random, signed, 8-bit values equal to the length of the passed `Int`
with a maximum of 65536 values.
-}
getRandomInt8Values : Int -> Task Never (Array Int)
getRandomInt8Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 65536 int) "int8"


{-| Get a `Array` of random, unsigned, 8-bit values equal to the length of the passed `Int`
with a maximum of 65536 values.
-}
getRandomUInt8Values : Int -> Task Never (Array Int)
getRandomUInt8Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 65536 int) "uint8"


{-| Get a `Array` of random, signed, 16-bit values equal to the length of the passed `Int`.
with a maximum of 32768 values.
-}
getRandomInt16Values : Int -> Task Never (Array Int)
getRandomInt16Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 32768 int) "int16"


{-| Get a `Array` of random, unsigned, 16-bit values equal to the length of the passed `Int`.
with a maximum of 32768 values.
-}
getRandomUInt16Values : Int -> Task Never (Array Int)
getRandomUInt16Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 32768 int) "uint16"


{-| Get a `Array` of random, signed, 32-bit values equal to the length of the passed `Int`
with a maximum of 16384 values.
-}
getRandomInt32Values : Int -> Task Never (Array Int)
getRandomInt32Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 16384 int) "int32"


{-| Get a `Array` of random, unsigned, 32-bit values equal to the length of the passed `Int`
with a maximum of 16384 values.
-}
getRandomUInt32Values : Int -> Task Never (Array Int)
getRandomUInt32Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 16384 int) "uint32"


-- ENVIRONMENT


{-| Represents the platform being considered secure. This type can be generated 
using the `isSecureContext` function and is required for some functions to be 
run in this package.
-}
type SecureContext
    = SecureContext


{-| A `Task` that succeeds with `SecureContext` if the code is being run in a 
secure context. If this `Task` fails, most of the functions within this module
will not be able to run.

While running this function on the `node` platform, it should always succeed.

While running this function on the `browser` platform, it will succeed if the
application being run is [considered as being in a secure context](https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts).
-}
isSecureContext : Task {} SecureContext
isSecureContext =
    Gren.Kernel.Crypto.getContext


-- KEYS


{-| Denotes if a key can be exported using the `exportKey` or `exportKeyPair`
functions. If a key is not marked as exportable when it is created or imported, 
any attempts to export the key will fail.
-}
type Extractable
    = CanBeExtracted
    | CannotBeExtracted


{-| A generated key. Can only be created by running a key generation function.
-}
type Key algorithm
    = Key 
        { key : algorithm
        , algorithm : String
        , keyType : String
        , extractable : Bool
        , usages : Array String 
        }


{-| Represents a public key which can only be used for specific actions.
-}
type PublicKey a
    = PublicKey (Key a)


{-| Represents a private key which can only be used for specific actions.
-}
type PrivateKey a
    = PrivateKey (Key a)


{-| A pair of public and private keys.
-}
type alias KeyPair a =
    { publicKey : PublicKey a
    , privateKey : PrivateKey a
    }


-- RSA KEYS


{-| Represents a key generated and for use with the RSA-OAEP algorithm used to 
encrypt and decrypt values.
-}
type RsaOaepKey
    = RsaOaepKey


{-| A key generated for use with the RSA-PSS algorithm. Used to sign and verify 
values.
-}
type RsaPssKey =
    RsaPssKey


{-| A key generated for use with the RSASSA-PKCS1-v1_5 algorithm. Used to sign 
and verify values.
-}
type RsaSsaPkcs1V1_5Key
    = RsaSsaPkcs1V1_5Key


{-| Parameters required to generate a key for uses with the RSA algorithm.

`modulusLength` is clamped be at least 2048 and no greater than 16384. If the
`Int` used is outside of that range, it will be corrected.
-}
type alias RsaKeyParams =
    { modulusLength : Int
    , hash : DigestAlgorithm
    , publicExponent : PublicExponent
    }


{-| The public exponent allowed for the RSA algorithm in the Web Crypto API. The
only two values allowed are `3` and `65537`.
-}
type PublicExponent
    = PublicExponent3
    | PublicExponent65537


{-| Errors that can happen when generating a key for use with the RSA algorithm.

- `ModulusLengthNotDivisibleByEight` happens when the passed `modulusLength` is
not divisible by 8, as is required by the algorithm.
-}
type RsaKeyGenerationError
    = ModulusLengthNotDivisibleByEight


{-| Generate a new key pair using the RSA-OAEP (Optimal Asymmetric Encryption 
Padding) algorithm.

Produces a `KeyPair` that can be used to encrypt and decrypt data.
-}
generateRsaOaepKeyPair : SecureContext -> RsaKeyParams -> Extractable -> Task RsaKeyGenerationError (KeyPair RsaOaepKey)
generateRsaOaepKeyPair _context =
    generateRsaKeyHelper 
        "RSA-OAEP" 
        [ "encrypt", "decrypt" ]


{-| Generate a new key using the RSA-PSS algorithm.

Produces a `KeyPair` that can be used to sign and verify data.
-}
generateRsaPssKeyPair : SecureContext -> RsaKeyParams -> Extractable -> Task RsaKeyGenerationError (KeyPair RsaPssKey)
generateRsaPssKeyPair _context =
    generateRsaKeyHelper 
        "RSA-PSS"
        [ "sign", "verify" ]


{-| Generate a new key using the RSASSA-PKCS1-v1_5 algorithm.

Produces a `KeyPair` that can be used to sign and verify data.
-}
generateRsaSsaPkcs1V1_5KeyPair : SecureContext -> RsaKeyParams -> Extractable -> Task RsaKeyGenerationError (KeyPair RsaSsaPkcs1V1_5Key)
generateRsaSsaPkcs1V1_5KeyPair _context =
    generateRsaKeyHelper 
        "RSASSA-PKCS1-v1_5"
        [ "sign", "verify" ]


{-|-}
generateRsaKeyHelper : String -> Array String -> RsaKeyParams -> Extractable -> Task RsaKeyGenerationError a
generateRsaKeyHelper name permissions { modulusLength, hash, publicExponent } extractable =
    let
        clampedModulusLength = 
            clamp 2048 16384 modulusLength

        publicExponentValue =
            case publicExponent of
                PublicExponent3 ->
                    [ 3 ]
                    
                PublicExponent65537 ->
                    [ 1, 0, 1 ]
    in
    if Math.remainderBy 8 clampedModulusLength == 0 then
        Gren.Kernel.Crypto.generateRsaKey 
            name
            clampedModulusLength
            publicExponentValue
            (digestAlgorithmToString hash)
            (extractableToBool extractable)
            permissions
    else
        Task.fail ModulusLengthNotDivisibleByEight


-- AES KEYS


{-| Represents a key generated and for use with the AES-CTR algorithm used to
encrypt and decrypt values.
-}
type AesCtrKey
    = AesCtrKey


{-| Represents a key generated and for use with the AES-CBC algorithm used to
encrypt and decrypt values.
-}
type AesCbcKey
    = AesCbcKey


{-| Represents a key generated and for use with the AES-GCM algorithm used to
encrypt and decrypt values.
-}
type AesGcmKey
    = AesGcmKey


{-| The length of bits of the key that is being generated using the AES 
algorithm. These are the only values that can be chosen.
-}
type AesLength
    = AesLength128
    | AesLength192
    | AesLength256


{-| Generate a new key using the AES-CTR algorithm.
-}
generateAesCtrKey : SecureContext -> AesLength -> Extractable -> Task {} (Key AesCtrKey)
generateAesCtrKey _context length extractable =
    Gren.Kernel.Crypto.generateKey
        { name = "AES-CTR"
        , length = aesLengthToInt length
        }
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-| Generate a new key using the AES-CTR algorithm.
-}
generateAesCbcKey : SecureContext -> AesLength -> Extractable -> Task {} (Key AesCbcKey)
generateAesCbcKey _context length extractable =
    Gren.Kernel.Crypto.generateKey
        { name = "AES-CBC"
        , length = aesLengthToInt length
        }
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-| Generate a new key using the AES-GCM algorithm.
-}
generateAesGcmKey : SecureContext -> AesLength -> Extractable -> Task {} (Key AesGcmKey)
generateAesGcmKey _context length extractable =
    Gren.Kernel.Crypto.generateKey
        { name = "AES-GCM"
        , length = aesLengthToInt length
        }
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


-- ECD KEYS


{-| Represents a key generated and for use with the ECDSA algorithm used to
sign and verify values.
-}
type EcdsaKey
    = EcdsaKey


{-| Represents a key generated and for use with the ECDH algorithm used to
derive keys and bits.
-}
type EcdhKey
    = EcdhKey


{-| The name of the elliptic curve to use for the generated key.
-}
type EcNamedCurve
    = P256
    | P384
    | P521


{-| Generate a new key using the ECDSA algorithm.
-}
generateEcdsaKeyPair : SecureContext -> EcNamedCurve -> Extractable -> Task x (KeyPair EcdsaKey)
generateEcdsaKeyPair _context namedCurve extractable =
    Gren.Kernel.Crypto.generateKey
        { name = "ECDSA"
        , namedCurve = ecNamedCurveToString namedCurve
        }
        (extractableToBool extractable)
        [ "sign", "verify" ]


{-| Generate a new key using the ECDH algorithm.
-}
generateEcdhKeyPair : SecureContext -> EcNamedCurve -> Extractable -> Task x (KeyPair EcdhKey)
generateEcdhKeyPair _context namedCurve extractable =
    Gren.Kernel.Crypto.generateKey
        { name = "ECDH"
        , namedCurve = ecNamedCurveToString namedCurve
        }
        (extractableToBool extractable)
        [ "deriveKey", "deriveBits" ]


-- HMAC KEYS


{-| Represents a key generated and for use with the HMAC algorithm used to
sign and verify values.
-}
type HmacKey =
    HmacKey


{-| Parameters required to generate a key for uses with the HMAC algorithm.

The passed `length` will be the length of the resulting key in bits. If
`Nothing`, the key will be equal in bits to the passed `DigestAlgorithm`. 
It's recommended to pass `Nothing` and let the length of the key be equal 
to the hash function (`DigestAlgorithm`).
-}
type alias HmacKeyParams =
    { length : Maybe Int
    , hash : DigestAlgorithm
    }


{-|Generate a new key using the HMAC algorithm.
-}
generateHmacKey : SecureContext -> HmacKeyParams -> Extractable -> Task x (Key HmacKey)
generateHmacKey _context { hash, length } extractable =
    case length of
        Just passedLength ->
            Gren.Kernel.Crypto.generateKey
                { name = "HMAC"
                , hash = digestAlgorithmToString hash
                , length = passedLength
                }
                (extractableToBool extractable)
                [ "sign", "verify" ]

        Nothing ->
            Gren.Kernel.Crypto.generateKey
                { name = "HMAC"
                , hash = digestAlgorithmToString hash
                }
                (extractableToBool extractable)
                [ "sign", "verify" ]


-- ENCRYPT / DECRYPT DATA


{-| The available algorithms that can be used to encrypt values. 

Each algorithm requires a cooresponding key that must be generated using a 
key generation function available in this module.
-}
type EncryptionAlgorithm
    = EncryptWithAesCtr (Key AesCtrKey)
        { counter : Bytes
        , length : Int
        }
    -- The `iv` value _must_ be unique for each encryption operation with the same key
    | EncryptWithAesCbc (Key AesCbcKey)
        { iv : Bytes
        }
    | EncryptWithAesGcm (Key AesGcmKey) -- https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams
        { iv : Bytes
        , additionalData : Maybe Bytes -- The bit length of additionalData must be smaller than 2^64 - 1
        , tagLength : Maybe Int -- Must be one of: 96, 104, 112, 120 or 128 - fill in with type later
        }


{-|-}
type DecryptionAlgorithm
    = DecryptWithRsaOaep (PrivateKey RsaOaepKey)
        { label : Maybe Bytes
        }
    | DecryptWithAesCtr (Key AesCtrKey)
        { counter : Bytes
        , length : Int
        }
    -- The `iv` value _must_ be unique for each encryption operation with the same key
    | DecryptWithAesCbc (Key AesCbcKey)
        { iv : Bytes
        }
    | DecryptWithAesGcm (Key AesGcmKey) -- https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams
        { iv : Bytes
        , additionalData : Maybe Bytes -- The bit length of additionalData must be smaller than 2^64 - 1
        , tagLength : Maybe Int -- Must be one of: 96, 104, 112, 120 or 128 - fill in with type later
        }


{-|-}
type alias EncryptWithRsaOaepParams =
    { label : Maybe Bytes
    }


{-| Encrypt some passed `Bytes` with the RSA-OAEP algorithm.
-}
encryptWithRsaOaep : SecureContext -> EncryptWithRsaOaepParams -> PublicKey RsaOaepKey -> Bytes -> Task {} Bytes
encryptWithRsaOaep _context params (PublicKey (Key publicKey)) data =
    case params.label of
        Just label ->
            Gren.Kernel.Crypto.encrypt
                { name = "RSA-OAEP"
                , label = label
                }
                publicKey
                data

        Nothing ->
            Gren.Kernel.Crypto.encrypt
                { name = "RSA-OAEP"
                }
                publicKey
                data
                

{-| Encrypt some `Bytes` with a provided algorithm.
-}
encrypt : SecureContext -> EncryptionAlgorithm -> Bytes -> Task {} Bytes
encrypt _context algorithm data =
    case algorithm of
        EncryptWithAesCtr key { counter, length } ->
            Task.fail {}
        
        EncryptWithAesCbc key { iv } ->
            Task.fail {}

        EncryptWithAesGcm key { iv, additionalData = Just unwrappedAdditionalData, tagLength = Just unwrappedTagLength } ->
            Task.fail {}

        EncryptWithAesGcm key { iv, additionalData = Nothing, tagLength = Just unwrappedTagLength } ->
            Task.fail {}

        EncryptWithAesGcm key { iv, additionalData = Just unwrappedAdditionalData, tagLength = Nothing } ->
            Task.fail {}

        EncryptWithAesGcm key { iv, additionalData = Nothing, tagLength = Nothing } ->
            Task.fail {}


{-|-}
decrypt : SecureContext -> DecryptionAlgorithm -> Bytes -> Task {} Bytes
decrypt _context algorithm data =
    case algorithm of
        DecryptWithRsaOaep (PrivateKey (Key unwrappedPublicKey)) { label = Nothing } ->
            Gren.Kernel.Crypto.decrypt
                unwrappedPublicKey.key
                { name = unwrappedPublicKey.algorithm
                }
                data

        DecryptWithRsaOaep (PrivateKey (Key unwrappedPublicKey)) { label = Just label } ->
            Gren.Kernel.Crypto.decrypt
                unwrappedPublicKey.key
                { name = unwrappedPublicKey.algorithm
                , label = label
                }
                data

        DecryptWithAesCtr key { counter, length } ->
            Task.fail {}

        DecryptWithAesCbc key { iv } ->
            Task.fail {}

        DecryptWithAesGcm key { iv, additionalData = Just unwrappedAdditionalData, tagLength = Just unwrappedTagLength } ->
            Task.fail {}

        DecryptWithAesGcm key { iv, additionalData = Nothing, tagLength = Just unwrappedTagLength } ->
            Task.fail {}

        DecryptWithAesGcm key { iv, additionalData = Just unwrappedAdditionalData, tagLength = Nothing } ->
            Task.fail {}

        DecryptWithAesGcm key { iv, additionalData = Nothing, tagLength = Nothing } ->
            Task.fail {}


-- SIGN / VERIFY DATA


{-|-}
type SigningAlgorithm
    = SignWithRsassaPkcs1V1_5 (PrivateKey RsaSsaPkcs1V1_5Key)
    | SignWithRsaPss (PrivateKey RsaPssKey)
        { saltLength : Int -- longinteger
        }
    | SignWithEcdsa (PrivateKey EcdsaKey)
        { hash : DigestAlgorithm
        }
    | SignWithHmac (Key HmacKey)


{-|-}
type VerifyingAlgorithm
    = VerifyWithRsassaPkcs1V1_5 (PublicKey RsaSsaPkcs1V1_5Key)
    | VerifyWithRsaPss (PublicKey RsaPssKey)
        { saltLength : Int -- longinteger
        }
    | VerifyWithEcdsa (PublicKey EcdsaKey)
        { hash : DigestAlgorithm
        }
    | VerifyWithHmac (Key HmacKey)


{-|-}
sign : SecureContext -> SigningAlgorithm -> Bytes -> Task {} Bytes
sign _context algorithm data =
    case algorithm of
        SignWithRsassaPkcs1V1_5 key ->
            Task.fail {}
        
        SignWithRsaPss key { saltLength } ->
            Task.fail {}
        
        SignWithEcdsa key { hash } ->
            Task.fail {}

        SignWithHmac key ->
            Task.fail {}


{-|-}
verify : SecureContext -> VerifyingAlgorithm -> Bytes -> Task {} Bytes
verify _context algorithm data =
    case algorithm of
        VerifyWithRsassaPkcs1V1_5 key ->
            Task.fail {}
        
        VerifyWithRsaPss key { saltLength } ->
            Task.fail {}
        
        VerifyWithEcdsa key { hash } ->
            Task.fail {}

        VerifyWithHmac key ->
            Task.fail {}


-- DIGEST


{-| Supported algorithms suitable for digesting data.

Note: The algorithm `SHA1` is supported by the WebCrypto API, but not available 
in this package due to known security vunerabilities.
-}
type DigestAlgorithm
    = Sha256
    | Sha384
    | Sha512


{-|-}
digest : SecureContext -> DigestAlgorithm -> Bytes -> Task {} Bytes
digest _context algorithm data =
    Gren.Kernel.Crypto.digest
        (digestAlgorithmToString algorithm)
        data


-- DERIVE


{-|-}
type DeriveAlgorithm a
    = Ecdh 
        { publicKey : Key a
        }
    | Hkdf
        { hash : DigestAlgorithm
        , salt : Bytes
        , info : Bytes
        }
    | Pbkdf2
        { hash : DigestAlgorithm
        , salt : Bytes
        , iterations : Int
        }


{-|-}
deriveBits : SecureContext -> DeriveAlgorithm a -> Int -> Task x Bytes
deriveBits _context algorithm length =
    -- Note: length should be divisible by 8
    Debug.todo ""


{-| Derive a `Key HmacKey` from an existing key value.
-}
deriveHmacKey : SecureContext -> DeriveAlgorithm a -> Key a -> DigestAlgorithm -> Maybe Int -> Extractable -> Task String (Key HmacKey)
deriveHmacKey _context algorithm key digestAlgorithm length extractable =
    case algorithm of
        Ecdh { publicKey } ->
            Gren.Kernel.Crypto.deriveKey
                publicKey
                key
                { name = "HMAC"
                , hash = digestAlgorithmToString digestAlgorithm
                , length = length -- todo
                }
                extractable
                [ "deriveKey", "deriveBytes" ]
        
        Hkdf { hash, salt, info } ->
            Gren.Kernel.Crypto.deriveKey
                {}
        
        Pbkdf2 { hash, salt, iterations } ->
            Gren.Kernel.Crypto.deriveKey
                {}


{-|-}
deriveAesCtrKey =
    Debug.todo ""


{-|-}
deriveAesCbcKey =
    Debug.todo ""


{-|-}
deriveAesGcmKey =
    Debug.todo ""


{-|-}
deriveHkdfKey =
    Debug.todo ""


{-| Generate a key for [...]

The only use for this key is to derive other keys using the `deriveKey` 
function.
-}
derivePbkdf2Key =
    Debug.todo ""


-- EXPORT KEYS


{-| Errors that can arise when exporting keys.

- `NotExportable` happens when trying to export a key that was not made
`Extractable` during creation or import.
-}
type ExportKeyError
    = KeyNotExportable


{-| Export a `RsaOaepKey` as a [SubjectPublicKeyInfo](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#subjectpublickeyinfo).

The result `Bytes` can be imported again using the `importRsaOaepPublicKey` function.
-}
exportRsaOaepPublicKeyAsSpki : SecureContext -> PublicKey RsaOaepKey -> Task ExportKeyError Bytes
exportRsaOaepPublicKeyAsSpki _context (PublicKey key) =
    exportKeyAsSpki key


{-| Export a `RsaOaepKey` as a [JSON Web Key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#json_web_key).

The resulting `Json.Encode.Value` can be imported again using the `importRsaOaepPublicKey` function.
-}
exportRsaOaepPublicKeyAsJwk : SecureContext -> PublicKey RsaOaepKey -> Task ExportKeyError Json.Encode.Value
exportRsaOaepPublicKeyAsJwk _context (PublicKey key) =
    exportKeyAsJwk key


{-| Export a `RsaOaepKey` as [PKCS #8](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#pkcs_8)
-}
exportRsaOaepPrivateKeyAsPkcs8 : SecureContext -> PrivateKey RsaOaepKey -> Task ExportKeyError Bytes
exportRsaOaepPrivateKeyAsPkcs8 _context (PrivateKey key) =
    exportKeyAsPkcs8 key


{-| Export a private `RsaOaepKey` as a [JSON Web Key]() 
-}
exportRsaOaepPrivateKeyAsJwk : SecureContext -> PrivateKey RsaOaepKey -> Task ExportKeyError Json.Encode.Value
exportRsaOaepPrivateKeyAsJwk _context (PrivateKey key) =
    exportKeyAsJwk key


{-|-}
exportRsaPssPublicKeyAsSpki : SecureContext -> PublicKey RsaOaepKey -> Task ExportKeyError Bytes
exportRsaPssPublicKeyAsSpki _context (PublicKey key)=
    exportKeyAsSpki key


{-|-}
exportRsaPssPublicKeyAsJwk : SecureContext -> PublicKey RsaOaepKey -> Task ExportKeyError Json.Encode.Value
exportRsaPssPublicKeyAsJwk _context (PublicKey key) =
    exportKeyAsJwk key


{-|-}
exportRsaPssPrivateKeyAsPkcs8 : SecureContext -> PrivateKey RsaOaepKey -> Task ExportKeyError Bytes
exportRsaPssPrivateKeyAsPkcs8 _context (PrivateKey key) =
    exportKeyAsPkcs8 key


{-|-}
exportRsaPssPrivateKeyAsJwk : SecureContext -> PrivateKey RsaOaepKey -> Task ExportKeyError Json.Encode.Value
exportRsaPssPrivateKeyAsJwk _context (PrivateKey key) =
    exportKeyAsJwk key


{-|-}
exportRsaSsaPkcs1V1_5PublicKeyAsSpki : SecureContext -> PublicKey RsaSsaPkcs1V1_5Key -> Task ExportKeyError Bytes
exportRsaSsaPkcs1V1_5PublicKeyAsSpki _context (PublicKey key) =
    exportKeyAsSpki key


{-|-}
exportRsaSsaPkcs1V1_5PublicKeyAsJwk : SecureContext -> PublicKey RsaSsaPkcs1V1_5Key -> Task ExportKeyError Json.Encode.Value
exportRsaSsaPkcs1V1_5PublicKeyAsJwk _context (PublicKey key) =
    exportKeyAsJwk key


{-|-}
exportRsaSsaPkcs1V1_5PrivateKeyAsPkcs8 : SecureContext -> PrivateKey RsaSsaPkcs1V1_5Key -> Task ExportKeyError Bytes
exportRsaSsaPkcs1V1_5PrivateKeyAsPkcs8 _context (PrivateKey key)=
    exportKeyAsPkcs8 key


{-|-}
exportRsaSsaPkcs1V1_5PrivateKeyAsJwk : SecureContext -> PrivateKey RsaSsaPkcs1V1_5Key -> Task ExportKeyError Json.Encode.Value
exportRsaSsaPkcs1V1_5PrivateKeyAsJwk _context (PrivateKey key) =
    exportKeyAsJwk key


{-|-}
exportAesCtrKeyAsRaw : SecureContext -> Key AesCtrKey -> Task ExportKeyError Bytes
exportAesCtrKeyAsRaw _context =
    exportKeyAsRaw


{-|-}
exportAesCtrKeyAsJwk : SecureContext -> Key AesCtrKey -> Task ExportKeyError Json.Encode.Value
exportAesCtrKeyAsJwk _context =
    exportKeyAsJwk


{-|-}
exportAesCbcKeyAsRaw : SecureContext -> Key AesCbcKey -> Task ExportKeyError Bytes
exportAesCbcKeyAsRaw _context =
    exportKeyAsRaw


{-|-}
exportAesCbcKeyAsJwk : SecureContext -> Key AesCbcKey -> Task ExportKeyError Json.Encode.Value
exportAesCbcKeyAsJwk _context =
    exportKeyAsJwk


{-|-}
exportAesGcmKeyAsRaw : SecureContext -> Key AesGcmKey -> Task ExportKeyError Bytes
exportAesGcmKeyAsRaw _context =
    exportKeyAsRaw


{-|-}
exportAesGcmKeyAsJwk : SecureContext -> Key AesGcmKey -> Task ExportKeyError Json.Encode.Value
exportAesGcmKeyAsJwk _context =
    exportKeyAsJwk


{-|-}
exportEcdsaPublicKeyAsRaw : SecureContext -> PublicKey EcdsaKey -> Task ExportKeyError Bytes
exportEcdsaPublicKeyAsRaw _context (PublicKey key)=
    exportKeyAsRaw key


{-|-}
exportEcdsaPublicKeyAsSpki : SecureContext -> PublicKey EcdsaKey -> Task ExportKeyError Bytes
exportEcdsaPublicKeyAsSpki _context (PublicKey key)=
    exportKeyAsSpki key


{-|-}
exportEcdsaPublicKeyAsJwt : SecureContext -> PublicKey EcdsaKey -> Task ExportKeyError Json.Encode.Value
exportEcdsaPublicKeyAsJwt _context (PublicKey key)=
    exportKeyAsJwk key


{-|-}
exportEcdsaPrivateKeyAsPkcs8 : SecureContext -> PrivateKey EcdsaKey -> Task ExportKeyError Bytes
exportEcdsaPrivateKeyAsPkcs8 _context (PrivateKey key)=
    exportKeyAsPkcs8 key


{-|-}
exportEcdsaPrivateKeyAsJwt : SecureContext -> PrivateKey EcdsaKey -> Task ExportKeyError Json.Encode.Value
exportEcdsaPrivateKeyAsJwt _context (PrivateKey key)=
    exportKeyAsJwk key


{-|-}
exportEcdhPublicKeyAsRaw : SecureContext -> PublicKey EcdhKey -> Task ExportKeyError Bytes
exportEcdhPublicKeyAsRaw _context (PublicKey key)=
    exportKeyAsRaw key


{-|-}
exportEcdhPublicKeyAsSpki : SecureContext -> PublicKey EcdhKey -> Task ExportKeyError Bytes
exportEcdhPublicKeyAsSpki _context (PublicKey key)=
    exportKeyAsSpki key


{-|-}
exportEcdhPublicKeyAsJwt : SecureContext -> PublicKey EcdhKey -> Task ExportKeyError Json.Encode.Value
exportEcdhPublicKeyAsJwt _context (PublicKey key)=
    exportKeyAsJwk key


{-|-}
exportEcdhPrivateKeyAsPkcs8 : SecureContext -> PrivateKey EcdhKey -> Task ExportKeyError Bytes
exportEcdhPrivateKeyAsPkcs8 _context (PrivateKey key)=
    exportKeyAsPkcs8 key


{-|-}
exportEcdhPrivateKeyAsJwt : SecureContext -> PrivateKey EcdhKey -> Task ExportKeyError Json.Encode.Value
exportEcdhPrivateKeyAsJwt _context (PrivateKey key)=
    exportKeyAsJwk key


{-|-}
exportHmacKeyAsRaw : SecureContext -> Key HmacKey -> Task ExportKeyError Bytes
exportHmacKeyAsRaw _context =
    exportKeyAsRaw


{-|-}
exportHmacKeyAsJwk : SecureContext -> Key HmacKey -> Task ExportKeyError Json.Encode.Value
exportHmacKeyAsJwk _context =
    exportKeyAsJwk


{-|-}
exportKeyHelper : String -> Key a -> Task ExportKeyError b
exportKeyHelper keyType (Key { extractable, key }) =
    if extractable then
        Gren.Kernel.Crypto.exportKey keyType key

    else
        Task.fail KeyNotExportable


{-|-}
exportKeyAsRaw : Key a -> Task ExportKeyError Bytes
exportKeyAsRaw =
    exportKeyHelper "raw"


{-|-}
exportKeyAsPkcs8 : Key a -> Task ExportKeyError Bytes
exportKeyAsPkcs8 =
    exportKeyHelper "pkcs8"


{-|-}
exportKeyAsSpki : Key a -> Task ExportKeyError Bytes
exportKeyAsSpki =
    exportKeyHelper "spki"


{-|-}
exportKeyAsJwk : Key a -> Task ExportKeyError Json.Encode.Value
exportKeyAsJwk key =
    Task.map Gren.Kernel.Json.wrap (exportKeyHelper "jwk" key)


-- IMPORT KEYS


{-| Available options for importing keys for RAS algorithms.
-}
type ImportRsaPublicKeyFormat
    = ImportRsaPublicKeyUsingSubjectPublicKeyInfo Bytes
    | ImportRsaPublicKeyUsingJsonWebKey Json.Encode.Value


{-|-}
type alias ImportRsaKeyParams =
    { hash : DigestAlgorithm
    }


{-|-}
type ImportRsaKeyError
    = HashMismatch


{-|-}
importRsaOaepPublicKeyFromJwk : SecureContext -> Json.Encode.Value -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PublicKey RsaOaepKey)
importRsaOaepPublicKeyFromJwk _context jwk { hash } extractable =
    -- Note that there can be an error if you try to import a key with a different hash than the
    -- exported key... Not sure how to identify in Gren before calling kernel code... todo
    Gren.Kernel.Crypto.importKey
        "public"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        { name = "RSA-OAEP"
        , hash = digestAlgorithmToString hash
        }
        (extractableToBool extractable)
        [ "encrypt" ]


{-|-}
importRsaOaepPublicKeyFromSpki =
    Debug.todo ""


{-|-}
importRsaPssPublicKey : SecureContext -> ImportRsaPublicKeyFormat -> Extractable -> Task x (PublicKey RsaPssKey)
importRsaPssPublicKey _context =
    Debug.todo ""


{-|-}
importRsassaPkcs1V1_5PublicKey : SecureContext -> ImportRsaPublicKeyFormat -> Extractable -> Task x (PublicKey RsaSsaPkcs1V1_5Key)
importRsassaPkcs1V1_5PublicKey _context =
    Debug.todo ""


{-| Available options for importing keys for RAS algorithms.
-}
type ImportRsaPrivateKeyFormat
    = ImportRsaPrivateKeyUsingPkcs8 Bytes
    | ImportRsaPrivateKeyUsingJsonWebKey Json.Encode.Value


{-|-}
importRsaOaepPrivateKey : SecureContext -> ImportRsaPrivateKeyFormat -> Extractable -> Task x (PrivateKey RsaOaepKey)
importRsaOaepPrivateKey _context =
    Debug.todo ""


{-|-}
importRsaPssPrivateKey : SecureContext -> ImportRsaPrivateKeyFormat -> Extractable -> Task x (PrivateKey RsaPssKey)
importRsaPssPrivateKey _context =
    Debug.todo ""


{-|-}
importRsassaPkcs1V1_5PrivateKey : SecureContext -> ImportRsaPrivateKeyFormat -> Extractable -> Task x (PrivateKey RsaSsaPkcs1V1_5Key)
importRsassaPkcs1V1_5PrivateKey _context =
    Debug.todo ""


{-| Available options for importing keys for AES algorithms.
-}
type ImportAesFormat
    = ImportAesUsingRaw Bytes
    | ImportAesUsingJsonWebKey Json.Encode.Value


{-|-}
importAesCtrKey : SecureContext -> Extractable -> ImportAesFormat -> Task x (Key AesCtrKey)
importAesCtrKey _context extractable format =
    case format of
        ImportAesUsingRaw bytes ->
            Gren.Kernel.Crypto.importKey
                "raw"
                bytes
                { name = "AES-CTR" }
                extractable
                [ "encrypt", "decrypt" ]
        
        ImportAesUsingJsonWebKey json ->
            Gren.Kernel.Crypto.importKey
                "jwk"
                json
                { name = "AES-CTR" }
                extractable
                [ "encrypt", "decrypt" ]



{-|-}
importAesCbcKey : SecureContext -> AesLength -> Extractable -> Task x (Key AesCbcKey)
importAesCbcKey =
    Debug.todo ""


{-|-}
importAesGcmKey : SecureContext -> AesLength -> Extractable -> Task x (Key AesGcmKey)
importAesGcmKey =
    Debug.todo ""


{-| Available options for importing public keys for ECDSA algorithms.
-}
type ImportEcPublicKeyFormat
    = ImportEcPublicKeyUsingRaw Bytes
    | ImportEcPublicKeyUsingSubjectPublicKeyInfo Bytes
    | ImportEcPublicKeyUsingJsonWebKey Json.Encode.Value


{-|-}
importEcdsaPublicKey : SecureContext -> EcNamedCurve -> Extractable -> Task x (PublicKey EcdsaKey)
importEcdsaPublicKey _context =
    Debug.todo ""


{-|-}
importEcdhPublicKey : SecureContext -> EcNamedCurve -> Extractable -> Task x (PublicKey EcdhKey)
importEcdhPublicKey _context =
    Debug.todo ""


{-| Available options for importing private keys for ECDSA algorithms.
-}
type ImportEcPrivateKeyFormat
    = ImportEcPrivateKeyUsingPkcs Bytes
    | ImportEcPrivateKeyUsingSubjectPublicKeyInfo Bytes
    | ImportEcPrivateKeyUsingJsonWebKey Json.Encode.Value


{-|-}
importEcdsaPrivateKey : SecureContext -> EcNamedCurve -> Extractable -> Task x (PrivateKey EcdsaKey)
importEcdsaPrivateKey _context =
    Debug.todo ""


{-|-}
importEcdhPrivateKey : SecureContext -> EcNamedCurve -> Extractable -> Task x (PrivateKey EcdhKey)
importEcdhPrivateKey _context =
    Debug.todo ""


{-|-}
type ImportHmacFormat
    = ImportHmacUsingRaw Bytes
    | ImportHmacUsingJsonWebKey Json.Encode.Value


{-|-}
importHmacKey =
    Debug.todo ""


-- UTILITIES


{-|-}
clamp : Int -> Int -> Int -> Int
clamp min max number =
    if number < min then
    
        min
    else if number > max then
        max

    else
        number


{-|-}
ecNamedCurveToString : EcNamedCurve -> String
ecNamedCurveToString namedCurve =
    case namedCurve of
        P256 ->
            "P-256"

        P384 ->
            "P-384"

        P521 ->
            "P-521"


{-|-}
aesLengthToInt : AesLength -> Int
aesLengthToInt length =
    case length of
        AesLength128 ->
            128

        AesLength192 ->
            192

        AesLength256 ->
            256


{-|-}
extractableToBool : Extractable -> Bool
extractableToBool extractable =
    case extractable of
        CanBeExtracted ->
            True
            
        CannotBeExtracted ->
            False


{-|-}
digestAlgorithmToString : DigestAlgorithm -> String
digestAlgorithmToString digestAlgorithm =
    case digestAlgorithm of
        Sha256 ->
            "SHA-256"

        Sha384 ->
            "SHA-384"

        Sha512 ->
            "SHA-512"
