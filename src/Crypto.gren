module Crypto exposing 
    ( getRandomInt8Values, getRandomUInt8Values
    , getRandomInt16Values, getRandomUInt16Values
    , getRandomInt32Values, getRandomUInt32Values
    , SecureContext, isSecureContext
    , randomUuid
    , Key, KeyPair
    , Extractable(..)
    , RsaKeyParams, PublicExponent(..), RsaKeyGenerationError(..)
    , generateRsaOaepKey, generateRsaPssKey, generateRsassaPkcs1V1_5Key
    , AesLength
    , generateAesCtrKey, generateAesCbcKey, generateAesGcmKey
    , DigestAlgorithm(..)
    )


{-| 

This module gives access to various cryptograhic functions provided by the Web 
Crypto API on both `browser` and `node` platforms.

### Generate Random Values

Generate random values of 8, 16, or 32 bits long (signed and unsigned).

All functions for generating random values take an `Int` as the single parameter. 
This value is clamped to a minimum of `0` and a maximum of however many values can
be generated.

The maximum number of values that can be generated depends on the amount of bytes
the values you're generating are. 65536 is the maximum number of bytes that can be
generated. For example, when using `getRandomInt16Values`, each value is 16 bits 
(or 2 bytes), so the maximum number of values that `getRandomInt16Values` can generate
is 32768 values.

@docs getRandomInt8Values, getRandomUInt8Values

@docs getRandomInt16Values, getRandomUInt16Values

@docs getRandomInt32Values, getRandomUInt32Values

### Secure Context

Most functions in this module must be run in a secure context to operate safely
and correctly. Before you use any functions, it's likely you'll need to obtain
and store in your model the `SecureContext` value which can only be generated by
the successfull completion of a `Task` returned by the `isSecureContext` function.

@docs SecureContext, isSecureContext

### Generate Random UUIDs

@docs randomUuid

### Key Management

Functions for managing keys used to complete cryptographic operations.

@docs Key, KeyPair

@docs Extractable

#### Generate Keys

Generate keys for completing cryptographic operations.

@docs RsaKeyParams, PublicExponent, RsaKeyGenerationError

@docs generateRsaOaepKey, generateRsaPssKey, generateRsassaPkcs1V1_5Key

@docs AesLength

@docs generateAesCtrKey, generateAesCbcKey, generateAesGcmKey

#### Derive Keys

...

#### Export Keys

...

#### Import Keys

...

### Encryption

### Decryption

### Signing

### Verifying

### Digest

@docs DigestAlgorithm

-}


import Array exposing ( Array )
import Basics exposing ( Never, Bool(..), Int, (>), (<), (<=), (==) )
import Gren.Kernel.Crypto
import String exposing ( String )
import Task exposing ( Task )
import Debug
import Bytes exposing ( Bytes )
import Maybe exposing ( Maybe(..) )
import Result exposing ( Result(..) )
import Set exposing ( Set )
import Bitwise
import Math


-- RANDOM UUID


{-| Generate a random UUID using the UUID v4 algorithm. This function must be run
in a secure context.
-}
randomUuid : SecureContext -> Task x String
randomUuid _context =
    Gren.Kernel.Crypto.randomUUID


-- RANDOM VALUES


{-| Get a `Array` of random, signed, 8-bit values equal to the length of the passed `Int`
with a maximum of 65536 values.
-}
getRandomInt8Values : Int -> Task Never (Array Int)
getRandomInt8Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 65536 int) "int8"


{-| Get a `Array` of random, unsigned, 8-bit values equal to the length of the passed `Int`
with a maximum of 65536 values.
-}
getRandomUInt8Values : Int -> Task Never (Array Int)
getRandomUInt8Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 65536 int) "uint8"


{-| Get a `Array` of random, signed, 16-bit values equal to the length of the passed `Int`.
with a maximum of 32768 values.
-}
getRandomInt16Values : Int -> Task Never (Array Int)
getRandomInt16Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 32768 int) "int16"


{-| Get a `Array` of random, unsigned, 16-bit values equal to the length of the passed `Int`.
with a maximum of 32768 values.
-}
getRandomUInt16Values : Int -> Task Never (Array Int)
getRandomUInt16Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 32768 int) "uint16"


{-| Get a `Array` of random, signed, 32-bit values equal to the length of the passed `Int`
with a maximum of 16384 values.
-}
getRandomInt32Values : Int -> Task Never (Array Int)
getRandomInt32Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 16384 int) "int32"


{-| Get a `Array` of random, unsigned, 32-bit values equal to the length of the passed `Int`
with a maximum of 16384 values.
-}
getRandomUInt32Values : Int -> Task Never (Array Int)
getRandomUInt32Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 16384 int) "uint32"


-- ENVIRONMENT


{-| Represents the platform being considered secure. This type can be generated 
using the `isSecureContext` function and is required for some functions to be 
run in this package.
-}
type SecureContext
    = SecureContext


{-| A `Task` that succeeds with `SecureContext` if the code is being run in a 
secure context. If this `Task` fails, most of the functions within this module
will not be able to run.

While running this function on the `node` platform, it should always succeed.

While running this function on the `browser` platform, it will succeed if the
application is being run with HTTPS.
-}
isSecureContext : Task {} SecureContext
isSecureContext =
    Gren.Kernel.Crypto.getContext


-- KEYS


{-| Denotes if a key can be exported using the `exportKey` or `exportKeyPair`
functions. If a key is not marked as exportable when it is created, any attempts
to export the key will fail.
-}
type Extractable
    = CanBeExtracted
    | CannotBeExtracted


{-| A generated key. Can only be created by running a key generation function.
-}
type Key algorithm
    = Key 
        { key : algorithm
        , algorithm : String
        , keyType : String
        , extractable : Bool
        , usages : Array String 
        }


{-| A pair (public and private) of keys.
-}
type KeyPair a =
    KeyPair
        { publicKey : Key a
        , privateKey : Key a
        }


-- RSA KEYS


{-| Represents a key generated and for use with the RSA-OAEP algorithm used to 
encrypt and decrypt values.
-}
type RsaOaepKey
    = RsaOaepKey


{-| Represents a key generated and for use with the RSA-PSS algorithm used to 
sign and verify values.
-}
type RsaPssKey =
    RsaPssKey


{-| A key generated for and for use with the RSASSA-PKCS1-v1_5 algorithm. Used
to sign and verify values.
-}
type RsassaPkcs1V1_5Key
    = RsassaPkcs1V1_5Key


{-| Parameters required to generate a key with any RSA algorithm.

`modulusLength` is clamped be at least 2048 and no greater than 16384. If the
`Int` used is outside of that range, it will be corrected.
-}
type alias RsaKeyParams =
    { modulusLength : Int
    , hash : DigestAlgorithm
    , publicExponent : PublicExponent
    }


{-| The public exponent allowed for RSA algorithms in the Web Crypto API. The
only two values allowed are `3` and `65537`.
-}
type PublicExponent
    = PublicExponent3
    | PublicExponent65537


{-| Errors that can happen when generating a key with an RSA algorithm.

The possible errors and their descriptions are below:

- `ModulusLengthNotDivisibleByEight` happens when the passed `modulusLength` is
not divisible by 8, as is required by the algorithm.
-}
type RsaKeyGenerationError
    = ModulusLengthNotDivisibleByEight


{-| Generate a new key pair using the RSA-OAEP algorithm.

Produces a `KeyPair` consisting of a private and public key. This `KeyPair` can 
be used to encrypt and decrypt `Bytes`.
-}
generateRsaOaepKey : SecureContext -> RsaKeyParams -> Extractable -> Task RsaKeyGenerationError (KeyPair RsaOaepKey)
generateRsaOaepKey _context =
    generateRsaKeyHelper 
        "RSA-OAEP" 
        [ "encrypt", "decrypt" ]


{-| Generate a new key using the RSA-PSS algorithm.

Produces a `Key` that can be used to sign and verify `Bytes`.
-}
generateRsaPssKey : SecureContext -> RsaKeyParams -> Extractable -> Task RsaKeyGenerationError (Key RsaPssKey)
generateRsaPssKey _context =
    generateRsaKeyHelper 
        "RSA-PSS"
        [ "sign", "verify" ]


{-| Generate a new key using the RSASSA-PKCS1-v1_5 algorithm.

Produces a `Key` that can be used to sign and verify `Bytes`.
-}
generateRsassaPkcs1V1_5Key : SecureContext -> RsaKeyParams -> Extractable -> Task RsaKeyGenerationError (Key RsassaPkcs1V1_5Key)
generateRsassaPkcs1V1_5Key _context =
    generateRsaKeyHelper 
        "RSASSA-PKCS1-v1_5"
        [ "sign", "verify" ]


{-|-}
generateRsaKeyHelper : String -> Array String -> RsaKeyParams -> Extractable -> Task RsaKeyGenerationError a
generateRsaKeyHelper name permissions { modulusLength, hash, publicExponent } extractable =
    let
        clampedModulusLength = 
            clamp 2048 16384 modulusLength
    in
    if Math.remainderBy 8 clampedModulusLength == 0 then
        Gren.Kernel.Crypto.generateKey 
            { name = name
            , modulusLength = clampedModulusLength
            , publicExponent = 
                case publicExponent of
                    PublicExponent3 ->
                        [ 3 ]
                    PublicExponent65537 ->
                        [ 1, 0, 1 ]
            , hash = digestAlgorithmToString hash
            }
            (extractableToBool extractable)
            permissions
    else
        Task.fail ModulusLengthNotDivisibleByEight


-- AES KEYS


{-| Represents a key generated and for use with the AES-CTR algorithm used to
encrypt and decrypt values.
-}
type AesCtrKey
    = AesCtrKey


{-| Represents a key generated and for use with the AES-CBC algorithm used to
encrypt and decrypt values.
-}
type AesCbcKey
    = AesCbcKey


{-| Represents a key generated and for use with the AES-GCM algorithm used to
encrypt and decrypt values.
-}
type AesGcmKey
    = AesGcmKey


{-| The length of bits of the key that is being generated using the AES 
algorithm. These are the only values that can be chosen.
-}
type AesLength
    = AesLength128
    | AesLength192
    | AesLength256


{-| Generate a new key using the AES-CTR algorithm.
-}
generateAesCtrKey : SecureContext -> AesLength -> Extractable -> Task Never (Key AesCtrKey)
generateAesCtrKey _context length extractable =
    Gren.Kernel.Crypto.generateKey
        { name = "AES-CTR"
        , length = aesLengthToInt length
        }
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-| Generate a new key using the AES-CTR algorithm.
-}
generateAesCbcKey : SecureContext -> AesLength -> Extractable -> Task Never (Key AesCbcKey)
generateAesCbcKey _context length extractable =
    Gren.Kernel.Crypto.generateKey
        { name = "AES-CBC"
        , length = aesLengthToInt length
        }
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-| Generate a new key using the AES-GCM algorithm.
-}
generateAesGcmKey : SecureContext -> AesLength -> Extractable -> Task Never (Key AesGcmKey)
generateAesGcmKey _context length extractable =
    Gren.Kernel.Crypto.generateKey
        { name = "AES-GCM"
        , length = aesLengthToInt length
        }
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


-- EC KEYS


{-|-}
type EcNamedCurve
    = P256
    | P384
    | P521


{-|-}
type EcdsaKey
    = EcdsaKey


{-|-}
type EcdhKey
    = EcdhKey


{-|-}
generateEcdsaKey : SecureContext -> EcNamedCurve -> Extractable -> Task x (Key EcdsaKey)
generateEcdsaKey _context namedCurve extractable =
    Gren.Kernel.Crypto.generateKey
        { name = "ECDSA"
        , namedCurve = ecNamedCurveToString namedCurve
        }
        (extractableToBool extractable)
        [ "sign", "verify" ]


{-|-}
generateEcdhKey : SecureContext -> EcNamedCurve -> Extractable -> Task x (Key EcdhKey)
generateEcdhKey _context namedCurve extractable =
    Gren.Kernel.Crypto.generateKey
        { name = "ECDH"
        , namedCurve = ecNamedCurveToString namedCurve
        }
        (extractableToBool extractable)
        [ "deriveKey", "deriveBytes" ]


-- HMAC KEYS


{-|-}
type HmacKey =
    HmacKey


{-|-}
generateHmacKey : SecureContext -> DigestAlgorithm -> Maybe Int -> Extractable -> Task x (Key HmacKey)
generateHmacKey _context hash passedLength extractable =
    case passedLength of
        Just length ->
            Gren.Kernel.Crypto.generateKey
                { name = "HMAC"
                , hash = digestAlgorithmToString hash
                , length = length
                }
                (extractableToBool extractable)
                [ "sign", "verify" ]

        Nothing ->
            Gren.Kernel.Crypto.generateKey
                { name = "HMAC"
                , hash = digestAlgorithmToString hash
                }
                (extractableToBool extractable)
                [ "sign", "verify" ]


-- ENCRYPT / DECRYPT DATA


{-|-}
type EncryptionAlgorithm
    = RsaOaep (KeyPair RsaOaepKey)
        { label : Maybe Bytes
        }
    | AesCtr (Key AesCtrKey)
        { counter : Bytes
        , length : Int
        }
    -- The `iv` value _must_ be unique for each encryption operation with the same key
    | AesCbc (Key AesCbcKey)
        { iv : Bytes
        }
    | AesGcm (Key AesGcmKey) -- https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams
        { iv : Bytes
        , additionalData : Maybe Bytes -- The bit length of additionalData must be smaller than 2^64 - 1
        , tagLength : Maybe Int -- Must be one of: 96, 104, 112, 120 or 128 - fill in with type later
        }


{-|-}
type alias DecryptionAlgorithm =
    EncryptionAlgorithm


{-| Encrypt some `Bytes` with a provided algorithm.
-}
encrypt : SecureContext -> EncryptionAlgorithm -> Bytes -> Task {} Bytes
encrypt _context algorithm data =
    case algorithm of
        RsaOaep (KeyPair { publicKey = Key unwrappedPublicKey }) { label = Nothing } ->
            Gren.Kernel.Crypto.encrypt
                unwrappedPublicKey.key
                { name = unwrappedPublicKey.algorithm
                }
                data

        RsaOaep (KeyPair { publicKey = Key unwrappedPublicKey }) { label = Just label } ->
            Gren.Kernel.Crypto.encrypt
                unwrappedPublicKey.key
                { name = unwrappedPublicKey.algorithm
                , label = label
                }
                data

        AesCtr key { counter, length } ->
            Task.fail {}
        
        AesCbc key { iv } ->
            Task.fail {}

        AesGcm key { iv, additionalData = Just unwrappedAdditionalData, tagLength = Just unwrappedTagLength } ->
            Task.fail {}

        AesGcm key { iv, additionalData = Nothing, tagLength = Just unwrappedTagLength } ->
            Task.fail {}

        AesGcm key { iv, additionalData = Just unwrappedAdditionalData, tagLength = Nothing } ->
            Task.fail {}

        AesGcm key { iv, additionalData = Nothing, tagLength = Nothing } ->
            Task.fail {}


{-|-}
decrypt : SecureContext -> DecryptionAlgorithm -> Bytes -> Task {} Bytes
decrypt _context algorithm data =
    case algorithm of
        RsaOaep (KeyPair { publicKey = Key unwrappedPublicKey }) { label = Nothing } ->
            Gren.Kernel.Crypto.decrypt
                unwrappedPublicKey.key
                { name = unwrappedPublicKey.algorithm
                }
                data

        RsaOaep (KeyPair { publicKey = Key unwrappedPublicKey }) { label = Just label } ->
            Gren.Kernel.Crypto.decrypt
                unwrappedPublicKey.key
                { name = unwrappedPublicKey.algorithm
                , label = label
                }
                data

        AesCtr key { counter, length } ->
            Task.fail {}

        AesCbc key { iv } ->
            Task.fail {}

        AesGcm key { iv, additionalData = Just unwrappedAdditionalData, tagLength = Just unwrappedTagLength } ->
            Task.fail {}

        AesGcm key { iv, additionalData = Nothing, tagLength = Just unwrappedTagLength } ->
            Task.fail {}

        AesGcm key { iv, additionalData = Just unwrappedAdditionalData, tagLength = Nothing } ->
            Task.fail {}

        AesGcm key { iv, additionalData = Nothing, tagLength = Nothing } ->
            Task.fail {}


-- SIGN / VERIFY DATA


{-|-}
type SigningAlgorithm
    = RsassaPkcs1V1_5 (Key RsassaPkcs1V1_5Key)
    | RsaPss (Key RsaPssKey)
        { saltLength : Int -- longinteger
        }
    | Ecdsa (Key EcdsaKey)
        { hash : DigestAlgorithm
        }
    | Hmac (Key HmacKey)


{-|-}
type alias VerifyingAlgorithm
    = SigningAlgorithm


{-|-}
sign : SecureContext -> SigningAlgorithm -> Bytes -> Task {} Bytes
sign _context algorithm data =
    case algorithm of
        RsassaPkcs1V1_5 key ->
            Task.fail {}
        
        RsaPss key { saltLength } ->
            Task.fail {}
        
        Ecdsa key { hash } ->
            Task.fail {}

        Hmac key ->
            Task.fail {}


{-|-}
verify : SecureContext -> VerifyingAlgorithm -> Bytes -> Task {} Bytes
verify _context algorithm data =
    case algorithm of
        RsassaPkcs1V1_5 key ->
            Task.fail {}
        
        RsaPss key { saltLength } ->
            Task.fail {}
        
        Ecdsa key { hash } ->
            Task.fail {}

        Hmac key ->
            Task.fail {}


-- DIGEST


{-| Supported algorithms suitable for digesting data.

Note: The algorithm `SHA1` is supported by the WebCrypto API, but not available 
in this package due to known security vunerabilities.
-}
type DigestAlgorithm
    = Sha256
    | Sha384
    | Sha512


{-|-}
digest : SecureContext -> DigestAlgorithm -> Bytes -> Task {} Bytes
digest _context algorithm data =
    Gren.Kernel.Crypto.digest
        (digestAlgorithmToString algorithm)
        data


-- DERIVE


{-|-}
type DeriveAlgorithm a
    = Ecdh 
        { publicKey : Key a
        }
    | Hkdf
        { hash : DigestAlgorithm
        , salt : Bytes
        , info : Bytes
        }
    | Pbkdf2
        { hash : DigestAlgorithm
        , salt : Bytes
        , iterations : Int
        }


{-|-}
deriveBits : SecureContext -> DeriveAlgorithm a -> Int -> Task x Bytes
deriveBits _context algorithm length =
    -- Note: length should be divisible by 8
    Debug.todo ""


{-| Derive a `Key HmacKey` from an existing key value.
-}
deriveHmacKey : SecureContext -> DeriveAlgorithm a -> Key a -> DigestAlgorithm -> Maybe Int -> Extractable -> Task String (Key HmacKey)
deriveHmacKey _context algorithm key digestAlgorithm length extractable =
    case algorithm of
        Ecdh { publicKey } ->
            Gren.Kernel.Crypto.deriveKey
                publicKey
                key
                { name = "HMAC"
                , hash = digestAlgorithmToString digestAlgorithm
                , length = length -- todo
                }
                extractable
                [ "deriveKey", "deriveBytes" ]
        
        Hkdf { hash, salt, info } ->
            Gren.Kernel.Crypto.deriveKey
                {}
        
        Pbkdf2 { hash, salt, iterations } ->
            Gren.Kernel.Crypto.deriveKey
                {}


{-|-}
deriveAesCtrKey =
    Debug.todo ""


{-|-}
deriveAesCbcKey =
    Debug.todo ""


{-|-}
deriveAesGcmKey =
    Debug.todo ""


{-|-}
deriveHkdfKey =
    Debug.todo ""


{-| Generate a key for [...]

The only use for this key is to derive other keys using the `deriveKey` 
function.
-}
derivePbkdf2Key =
    Debug.todo ""


-- EXPORT / IMPORT KEYS


{-|-}
exportKeyPair : SecureContext -> KeyPair a -> Task x { publicKey : Bytes, privateKey : Bytes }
exportKeyPair context (KeyPair { privateKey, publicKey }) =
    Task.map2 (\exportedPublicKey exportedPrivateKey ->
            { publicKey = exportedPublicKey
            , privateKey = exportedPrivateKey
            }
        )
        (exportKeyHelper context "spki" publicKey)
        (exportKeyHelper context "pkcs8" privateKey)


{-|-}
exportKey : SecureContext -> Key a -> Task x Bytes
exportKey _context key =
    Debug.todo ""


{-|-}
importRsaOaepKeyPair : SecureContext -> { publicKey : Bytes, privateKey : Bytes } -> Task x (KeyPair RsaOaepKey)
importRsaOaepKeyPair _context =
    Debug.todo ""


{-|-}
importRsaPssKey : SecureContext -> RsaKeyParams -> Extractable -> Task x (Key RsaPssKey)
importRsaPssKey _context =
    Debug.todo ""


{-|-}
importRsassaPkcs1V1_5Key : SecureContext -> RsaKeyParams -> Extractable -> Task x (Key RsassaPkcs1V1_5Key)
importRsassaPkcs1V1_5Key _context =
    Debug.todo ""


{-|-}
importAesCtrKey : SecureContext -> AesLength -> Extractable -> Task x (Key AesCtrKey)
importAesCtrKey =
    Debug.todo ""


{-|-}
importAesCbcKey : SecureContext -> AesLength -> Extractable -> Task x (Key AesCbcKey)
importAesCbcKey =
    Debug.todo ""


{-|-}
importAesGcmKey : SecureContext -> AesLength -> Extractable -> Task x (Key AesGcmKey)
importAesGcmKey =
    Debug.todo ""


{-|-}
importEcdsaKey : SecureContext -> EcNamedCurve -> Extractable -> Task x (Key EcdsaKey)
importEcdsaKey _context =
    Debug.todo ""


{-|-}
importEcdhKey : SecureContext -> EcNamedCurve -> Extractable -> Task x (Key EcdhKey)
importEcdhKey _context =
    Debug.todo ""


{-|-}
importHmacKey =
    Debug.todo ""


-- UTILITIES


{-|-}
clamp : Int -> Int -> Int -> Int
clamp min max number =
    if number < min then
    
        min
    else if number > max then
        max

    else
        number


{-|-}
ecNamedCurveToString : EcNamedCurve -> String
ecNamedCurveToString namedCurve =
    case namedCurve of
        P256 ->
            "P-256"

        P384 ->
            "P-384"

        P521 ->
            "P-521"


{-|-}
aesLengthToInt : AesLength -> Int
aesLengthToInt length =
    case length of
        AesLength128 ->
            128

        AesLength192 ->
            192

        AesLength256 ->
            256


{-|-}
exportKeyHelper : SecureContext -> String -> Key a -> Task x Bytes
exportKeyHelper _context format (Key { key }) =
    Gren.Kernel.Crypto.exportKey format key


{-|-}
extractableToBool : Extractable -> Bool
extractableToBool extractable =
    case extractable of
        CanBeExtracted ->
            True
            
        CannotBeExtracted ->
            False


{-|-}
digestAlgorithmToString : DigestAlgorithm -> String
digestAlgorithmToString digestAlgorithm =
    case digestAlgorithm of
        Sha256 ->
            "SHA-256"

        Sha384 ->
            "SHA-384"

        Sha512 ->
            "SHA-512"
