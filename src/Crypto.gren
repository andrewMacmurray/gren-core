module Crypto exposing 
    ( getRandomInt8Values, getRandomUInt8Values
    , getRandomInt16Values, getRandomUInt16Values
    , getRandomInt32Values, getRandomUInt32Values
    , SecureContext, isSecureContext
    , randomUuid
    , Key, PublicKey, PrivateKey, KeyPair
    , Extractable(..)
    , RsaOaepKey, RsaPssKey, RsaSsaPkcs1V1_5Key, RsaKeyParams, PublicExponent(..), RsaKeyGenerationError(..)
    , generateRsaOaepKeyPair, generateRsaPssKeyPair, generateRsaSsaPkcs1V1_5KeyPair
    , AesLength(..)
    , generateAesCtrKey, generateAesCbcKey, generateAesGcmKey
    , EcNamedCurve(..)
    , generateEcdsaKeyPair, generateEcdhKeyPair
    , HmacKeyParams, HmacKeyGenerationError(..)
    , generateHmacKey
    , ExportKeyError(..)
    , exportRsaOaepPublicKeyAsSpki, exportRsaOaepPublicKeyAsJwk
    , exportRsaOaepPrivateKeyAsPkcs8, exportRsaOaepPrivateKeyAsJwk
    , exportRsaPssPublicKeyAsSpki, exportRsaPssPublicKeyAsJwk
    , exportRsaPssPrivateKeyAsPkcs8, exportRsaPssPrivateKeyAsJwk
    , exportRsaSsaPkcs1V1_5PublicKeyAsSpki, exportRsaSsaPkcs1V1_5PublicKeyAsJwk
    , exportRsaSsaPkcs1V1_5PrivateKeyAsPkcs8, exportRsaSsaPkcs1V1_5PrivateKeyAsJwk
    , exportAesCtrKeyAsRaw, exportAesCtrKeyAsJwk
    , exportAesCbcKeyAsRaw, exportAesCbcKeyAsJwk
    , exportAesGcmKeyAsRaw, exportAesGcmKeyAsJwk
    , exportEcdsaPublicKeyAsRaw, exportEcdsaPublicKeyAsSpki, exportEcdsaPublicKeyAsJwk
    , exportEcdsaPrivateKeyAsPkcs8, exportEcdsaPrivateKeyAsJwk
    , exportEcdhPublicKeyAsRaw, exportEcdhPublicKeyAsSpki, exportEcdhPublicKeyAsJwk
    , exportEcdhPrivateKeyAsPkcs8, exportEcdhPrivateKeyAsJwk
    , exportHmacKeyAsRaw, exportHmacKeyAsJwk
    , ImportRsaKeyError(..)
    , importRsaOaepPublicKeyFromJwk, importRsaOaepPublicKeyFromSpki
    , importRsaOaepPrivateKeyFromJwk, importRsaOaepPrivateKeyFromPkcs8
    , importRsaPssPublicKeyFromJwk, importRsaPssPublicKeyFromSpki
    , importRsaPssPrivateKeyFromJwk, importRsaPssPrivateKeyFromPkcs8
    , importRsaSsaPkcs1V1_5PublicKeyFromJwk, importRsaSsaPkcs1V1_5PublicKeyFromSpki
    , importRsaSsaPkcs1V1_5PrivateKeyFromJwk, importRsaSsaPkcs1V1_5PrivateKeyFromPkcs8
    , ImportAesKeyError(..)
    , importAesCtrKeyFromRaw, importAesCtrKeyFromJwk
    , importAesCbcKeyFromRaw, importAesCbcKeyFromJwk
    , importAesGcmKeyFromRaw, importAesGcmKeyFromJwk
    , ImportHmacKeyError(..)
    , importHmacKeyFromJwk, importHmacKeyFromRaw
    , DigestAlgorithm(..)
    )


{-| 

This module gives access to various cryptograhic functions provided by the Web 
Crypto API on both `browser` and `node` platforms.

## Generate Random Values

Generate random values of 8, 16, or 32 bits long (signed and unsigned).

All functions for generating random values take an `Int` as the single parameter. 
This value is clamped to a minimum of `0` and a maximum of however many values can
be generated.

The maximum number of values that can be generated depends on the amount of bytes
the values you're generating are. 65536 is the maximum number of bytes that can be
generated. For example, when using `getRandomInt16Values`, each value is 16 bits 
(or 2 bytes), so the maximum number of values that `getRandomInt16Values` can generate
is 32768 values.

@docs getRandomInt8Values, getRandomUInt8Values

@docs getRandomInt16Values, getRandomUInt16Values

@docs getRandomInt32Values, getRandomUInt32Values

## Secure Context

Most functions in this module must be run in a secure context to operate safely
and correctly. Before you use any functions, it's likely you'll need to obtain
and store in your model the `SecureContext` value which can only be generated by
the successfull completion of a `Task` returned by the `isSecureContext` function.

@docs SecureContext, isSecureContext

## Generate Random UUIDs

@docs randomUuid

## Generate Keys

Generate, import, export, and derive keys for completing cryptographic operations. 
Each section covers a different sets of keys that use the same underlying algorithm. 
Each key can be only be used for specific cryptographic operations.

@docs Key, PublicKey, PrivateKey, KeyPair

@docs Extractable

### Generate RSA Keys

Generate keys to use with RSA (Rivest-Shamir-Adleman) algorithm.

@docs RsaOaepKey, RsaPssKey, RsaSsaPkcs1V1_5Key

@docs RsaKeyParams, PublicExponent, RsaKeyGenerationError

@docs generateRsaOaepKeyPair, generateRsaPssKeyPair, generateRsaSsaPkcs1V1_5KeyPair

### Generate AES Keys

@docs AesLength

@docs generateAesCtrKey, generateAesCbcKey, generateAesGcmKey

### Generate ECD Keys

@docs EcNamedCurve

@docs generateEcdsaKeyPair, generateEcdhKeyPair

### Generate HMAC Keys 

@docs HmacKeyParams

@docs generateHmacKey

## Derive Keys

Create keys from other keys.

...

## Export Keys

Export keys in various formats. Available formats depend on the key being exported.

For more information on exporting keys, check out the [MDN web docs](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)
for the Web Crypto API.

@docs ExportKeyError

### Export RSA Keys

@docs exportRsaOaepPublicKeyAsSpki, exportRsaOaepPublicKeyAsJwk

@docs exportRsaOaepPrivateKeyAsPkcs8, exportRsaOaepPrivateKeyAsJwk

@docs exportRsaPssPublicKeyAsSpki, exportRsaPssPublicKeyAsJwk

@docs exportRsaPssPrivateKeyAsPkcs8, exportRsaPssPrivateKeyAsJwk

@docs exportRsaSsaPkcs1V1_5PublicKeyAsSpki, exportRsaSsaPkcs1V1_5PublicKeyAsJwk

@docs exportRsaSsaPkcs1V1_5PrivateKeyAsPkcs8, exportRsaSsaPkcs1V1_5PrivateKeyAsJwk

### Export AES Keys

@docs exportAesCtrKeyAsRaw, exportAesCtrKeyAsJwk

@docs exportAesCbcKeyAsRaw, exportAesCbcKeyAsJwk

@docs exportAesGcmKeyAsRaw, exportAesGcmKeyAsJwk

### Export ECD Keys

@docs exportEcdsaPublicKeyAsRaw, exportEcdsaPublicKeyAsSpki, exportEcdsaPublicKeyAsJwk

@docs exportEcdsaPrivateKeyAsPkcs8, exportEcdsaPrivateKeyAsJwk

@docs exportEcdhPublicKeyAsRaw, exportEcdhPublicKeyAsSpki, exportEcdhPublicKeyAsJwk

@docs exportEcdhPrivateKeyAsPkcs8, exportEcdhPrivateKeyAsJwk

### Export HMAC Keys 

@docs exportHmacKeyAsRaw, exportHmacKeyAsJwk

## Import Keys

Import exported keys.

For more information on exporting keys, check out the [MDN web docs](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey)
for the Web Crypto API.

### Import RSA Keys

@docs ImportRsaKeyError

@docs importRsaOaepPublicKeyFromJwk, importRsaOaepPublicKeyFromSpki

@docs importRsaOaepPrivateKeyFromJwk, importRsaOaepPrivateKeyFromPkcs8

### Import AES Keys

...

### Import ECD Keys

...

### Import HMAC Keys 

...

...

## Encryption

Encrypt some `Bytes`.

## Decryption

Decrypt some `Bytes`.

## Signing

Sign some `Bytes`.

## Verifying

Verify signed `Bytes`.

## Digest

@docs DigestAlgorithm

-}


import Array exposing ( Array )
import Basics exposing ( Never, Bool(..), Int, (>), (<), (<=), (==) )
import Gren.Kernel.Crypto
import String exposing ( String )
import Task exposing ( Task )
import Debug
import Bytes exposing ( Bytes )
import Maybe exposing ( Maybe(..) )
import Result exposing ( Result(..) )
import Set exposing ( Set )
import Bitwise
import Math
import Json.Encode
import Gren.Kernel.Json


-- RANDOM UUID


{-| Generate a random UUID using the UUID v4 algorithm.
-}
randomUuid : SecureContext -> Task x String
randomUuid _context =
    Gren.Kernel.Crypto.randomUUID


-- RANDOM VALUES


{-| Get a `Array` of random, signed, 8-bit values equal to the length of the passed `Int`
with a maximum of 65536 values.
-}
getRandomInt8Values : Int -> Task Never (Array Int)
getRandomInt8Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 65536 int) "int8"


{-| Get a `Array` of random, unsigned, 8-bit values equal to the length of the passed `Int`
with a maximum of 65536 values.
-}
getRandomUInt8Values : Int -> Task Never (Array Int)
getRandomUInt8Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 65536 int) "uint8"


{-| Get a `Array` of random, signed, 16-bit values equal to the length of the passed `Int`.
with a maximum of 32768 values.
-}
getRandomInt16Values : Int -> Task Never (Array Int)
getRandomInt16Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 32768 int) "int16"


{-| Get a `Array` of random, unsigned, 16-bit values equal to the length of the passed `Int`.
with a maximum of 32768 values.
-}
getRandomUInt16Values : Int -> Task Never (Array Int)
getRandomUInt16Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 32768 int) "uint16"


{-| Get a `Array` of random, signed, 32-bit values equal to the length of the passed `Int`
with a maximum of 16384 values.
-}
getRandomInt32Values : Int -> Task Never (Array Int)
getRandomInt32Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 16384 int) "int32"


{-| Get a `Array` of random, unsigned, 32-bit values equal to the length of the passed `Int`
with a maximum of 16384 values.
-}
getRandomUInt32Values : Int -> Task Never (Array Int)
getRandomUInt32Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 16384 int) "uint32"


-- ENVIRONMENT


{-| Represents the platform being considered secure. This type can be generated 
using the `isSecureContext` function and is required for some functions to be 
run in this package.
-}
type SecureContext
    = SecureContext


{-| A `Task` that succeeds with `SecureContext` if the code is being run in a 
secure context. If this `Task` fails, most of the functions within this module
will not be able to run.

While running this function on the `node` platform, it should always succeed.

While running this function on the `browser` platform, it will succeed if the
application being run is [considered as being in a secure context](https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts).
-}
isSecureContext : Task {} SecureContext
isSecureContext =
    Gren.Kernel.Crypto.getContext


-- KEYS


{-| Denotes if a key can be exported using the `exportKey` or `exportKeyPair`
functions. If a key is not marked as exportable when it is created or imported, 
any attempts to export the key will fail.
-}
type Extractable
    = CanBeExtracted
    | CannotBeExtracted


{-| A generated key. Can only be created by running a key generation function.
-}
type Key algorithm
    = Key 
        { key : algorithm
        , algorithm : String
        , keyType : String
        , extractable : Bool
        , usages : Array String 
        }


{-| Represents a public key which can only be used for specific actions.
-}
type PublicKey a
    = PublicKey (Key a)


{-| Represents a private key which can only be used for specific actions.
-}
type PrivateKey a
    = PrivateKey (Key a)


{-| A pair of public and private keys.
-}
type alias KeyPair a =
    { publicKey : PublicKey a
    , privateKey : PrivateKey a
    }


-- RSA KEYS


{-| Represents a key generated and for use with the RSA-OAEP algorithm used to 
encrypt and decrypt values.
-}
type RsaOaepKey
    = RsaOaepKey


{-| A key generated for use with the RSA-PSS algorithm. Used to sign and verify 
values.
-}
type RsaPssKey =
    RsaPssKey


{-| A key generated for use with the RSASSA-PKCS1-v1_5 algorithm. Used to sign 
and verify values.
-}
type RsaSsaPkcs1V1_5Key
    = RsaSsaPkcs1V1_5Key


{-| Parameters required to generate a key for uses with the RSA algorithm.

`modulusLength` is clamped be at least 2048 and no greater than 16384. If the
`Int` used is outside of that range, it will be corrected.
-}
type alias RsaKeyParams =
    { modulusLength : Int
    , hash : DigestAlgorithm
    , publicExponent : PublicExponent
    }


{-| The public exponent allowed for the RSA algorithm in the Web Crypto API. The
only two values allowed are `3` and `65537`.
-}
type PublicExponent
    = PublicExponent3
    | PublicExponent65537


{-| Errors that can happen when generating a key for use with the RSA algorithm.

- `ModulusLengthNotDivisibleByEight` happens when the passed `modulusLength` is
not divisible by 8, as is required by the algorithm.
-}
type RsaKeyGenerationError
    = ModulusLengthNotDivisibleByEight


{-| Generate a new key pair using the RSA-OAEP (Optimal Asymmetric Encryption 
Padding) algorithm.

Produces a `KeyPair` that can be used to encrypt and decrypt data.
-}
generateRsaOaepKeyPair : SecureContext -> RsaKeyParams -> Extractable -> Task RsaKeyGenerationError (KeyPair RsaOaepKey)
generateRsaOaepKeyPair _context =
    generateRsaKeyHelper 
        "RSA-OAEP" 
        [ "encrypt", "decrypt" ]


{-| Generate a new key using the RSA-PSS algorithm.

Produces a `KeyPair` that can be used to sign and verify data.
-}
generateRsaPssKeyPair : SecureContext -> RsaKeyParams -> Extractable -> Task RsaKeyGenerationError (KeyPair RsaPssKey)
generateRsaPssKeyPair _context =
    generateRsaKeyHelper 
        "RSA-PSS"
        [ "sign", "verify" ]


{-| Generate a new key using the RSASSA-PKCS1-v1_5 algorithm.

Produces a `KeyPair` that can be used to sign and verify data.
-}
generateRsaSsaPkcs1V1_5KeyPair : SecureContext -> RsaKeyParams -> Extractable -> Task RsaKeyGenerationError (KeyPair RsaSsaPkcs1V1_5Key)
generateRsaSsaPkcs1V1_5KeyPair _context =
    generateRsaKeyHelper 
        "RSASSA-PKCS1-v1_5"
        [ "sign", "verify" ]


{-|-}
generateRsaKeyHelper : String -> Array String -> RsaKeyParams -> Extractable -> Task RsaKeyGenerationError a
generateRsaKeyHelper name permissions { modulusLength, hash, publicExponent } extractable =
    let
        clampedModulusLength = 
            clamp 2048 16384 modulusLength

        publicExponentValue =
            case publicExponent of
                PublicExponent3 ->
                    [ 3 ]
                    
                PublicExponent65537 ->
                    [ 1, 0, 1 ]
    in
    if Math.remainderBy 8 clampedModulusLength == 0 then
        Gren.Kernel.Crypto.generateRsaKey 
            name
            clampedModulusLength
            publicExponentValue
            (digestAlgorithmToString hash)
            (extractableToBool extractable)
            permissions
    else
        Task.fail ModulusLengthNotDivisibleByEight


-- AES KEYS


{-| Represents a key generated and for use with the AES-CTR algorithm used to
encrypt and decrypt values.
-}
type AesCtrKey
    = AesCtrKey


{-| Represents a key generated and for use with the AES-CBC algorithm used to
encrypt and decrypt values.
-}
type AesCbcKey
    = AesCbcKey


{-| Represents a key generated and for use with the AES-GCM algorithm used to
encrypt and decrypt values.
-}
type AesGcmKey
    = AesGcmKey


{-| The length of bits of the key that is being generated using the AES 
algorithm. These are the only values that can be chosen.

The Web Crypto API supports a length of 192, but some browsers do not implement
this. To keep compatability across browser, the option is not provided.
-}
type AesLength
    = AesLength128
    -- | AesLength192
    | AesLength256


{-| Generate a new key using the AES-CTR algorithm.
-}
generateAesCtrKey : SecureContext -> AesLength -> Extractable -> Task {} (Key AesCtrKey)
generateAesCtrKey _context length extractable =
    Gren.Kernel.Crypto.generateAesKey
        "AES-CTR"
        (aesLengthToInt length)
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-| Generate a new key using the AES-CTR algorithm.
-}
generateAesCbcKey : SecureContext -> AesLength -> Extractable -> Task {} (Key AesCbcKey)
generateAesCbcKey _context length extractable =
    Gren.Kernel.Crypto.generateAesKey
        "AES-CBC"
        (aesLengthToInt length)
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-| Generate a new key using the AES-GCM algorithm.
-}
generateAesGcmKey : SecureContext -> AesLength -> Extractable -> Task {} (Key AesGcmKey)
generateAesGcmKey _context length extractable =
    Gren.Kernel.Crypto.generateAesKey
        "AES-GCM"
        (aesLengthToInt length)
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


-- ECD KEYS


{-| Represents a key generated and for use with the ECDSA algorithm used to
sign and verify values.
-}
type EcdsaKey
    = EcdsaKey


{-| Represents a key generated and for use with the ECDH algorithm used to
derive keys and bits.
-}
type EcdhKey
    = EcdhKey


{-| The name of the elliptic curve to use for the generated key.
-}
type EcNamedCurve
    = P256
    | P384
    | P521


{-| Generate a new key using the ECDSA algorithm.
-}
generateEcdsaKeyPair : SecureContext -> EcNamedCurve -> Extractable -> Task x (KeyPair EcdsaKey)
generateEcdsaKeyPair _context namedCurve extractable =
    Gren.Kernel.Crypto.generateEcKey
        "ECDSA"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        [ "sign", "verify" ]


{-| Generate a new key using the ECDH algorithm.
-}
generateEcdhKeyPair : SecureContext -> EcNamedCurve -> Extractable -> Task x (KeyPair EcdhKey)
generateEcdhKeyPair _context namedCurve extractable =
    Gren.Kernel.Crypto.generateEcKey
        "ECDH"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        [ "deriveKey", "deriveBits" ]


-- HMAC KEYS


{-| Represents a key generated and for use with the HMAC algorithm used to
sign and verify values.
-}
type HmacKey =
    HmacKey


{-| Errors that can happen when generating a key for use with the RSA algorithm.

- `ModulusLengthNotDivisibleByEight` happens when the passed `modulusLength` is
not divisible by 8, as is required by the algorithm.
-}
type HmacKeyGenerationError
    = LengthNotDivisibleByEight


{-| Parameters required to generate a key for uses with the HMAC algorithm.

The passed `length` will be the length of the resulting key in bits. If
`Nothing`, the key will be equal in bits to the passed `DigestAlgorithm`. 
It's recommended to pass `Nothing` and let the length of the key be equal 
to the hash function (`DigestAlgorithm`).

If passed, the `length` is clamped be at least 8 and no greater than 2048. 
If the `Int` used is outside of that range, it will be corrected.
-}
type alias HmacKeyParams =
    { length : Maybe Int
    , hash : DigestAlgorithm
    }


{-| Generate a new key using the HMAC algorithm.
-}
generateHmacKey : SecureContext -> HmacKeyParams -> Extractable -> Task HmacKeyGenerationError (Key HmacKey)
generateHmacKey _context { hash, length } extractable =
    case length of
        Just passedLength ->
            let
                clampedLength =
                    clamp 8 2048 passedLength
            in
            if Math.remainderBy 8 clampedLength == 0 then
                Gren.Kernel.Crypto.generateHmacKey
                    "HMAC"
                    (digestAlgorithmToString hash)
                    clampedLength
                    (extractableToBool extractable)
                    [ "sign", "verify" ]
            
            else
                Task.fail LengthNotDivisibleByEight

        Nothing ->
            Gren.Kernel.Crypto.generateHmacKey
                "HMAC"
                (digestAlgorithmToString hash)
                ""
                (extractableToBool extractable)
                [ "sign", "verify" ]


-- ENCRYPT / DECRYPT DATA


{-| The available algorithms that can be used to encrypt values. 

Each algorithm requires a cooresponding key that must be generated using a 
key generation function available in this module.
-}
type EncryptionAlgorithm
    = EncryptWithAesCtr (Key AesCtrKey)
        { counter : Bytes
        , length : Int
        }
    -- The `iv` value _must_ be unique for each encryption operation with the same key
    | EncryptWithAesCbc (Key AesCbcKey)
        { iv : Bytes
        }
    | EncryptWithAesGcm (Key AesGcmKey) -- https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams
        { iv : Bytes
        , additionalData : Maybe Bytes -- The bit length of additionalData must be smaller than 2^64 - 1
        , tagLength : Maybe Int -- Must be one of: 96, 104, 112, 120 or 128 - fill in with type later
        }


{-|-}
type DecryptionAlgorithm
    = DecryptWithRsaOaep (PrivateKey RsaOaepKey)
        { label : Maybe Bytes
        }
    | DecryptWithAesCtr (Key AesCtrKey)
        { counter : Bytes
        , length : Int
        }
    -- The `iv` value _must_ be unique for each encryption operation with the same key
    | DecryptWithAesCbc (Key AesCbcKey)
        { iv : Bytes
        }
    | DecryptWithAesGcm (Key AesGcmKey) -- https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams
        { iv : Bytes
        , additionalData : Maybe Bytes -- The bit length of additionalData must be smaller than 2^64 - 1
        , tagLength : Maybe Int -- Must be one of: 96, 104, 112, 120 or 128 - fill in with type later
        }


{-|-}
type alias EncryptWithRsaOaepParams =
    { label : Maybe Bytes
    }


{-| Encrypt some passed `Bytes` with the RSA-OAEP algorithm.
-}
encryptWithRsaOaep : SecureContext -> EncryptWithRsaOaepParams -> PublicKey RsaOaepKey -> Bytes -> Task {} Bytes
encryptWithRsaOaep _context params (PublicKey (Key publicKey)) data =
    case params.label of
        Just label ->
            Gren.Kernel.Crypto.encrypt
                { name = "RSA-OAEP"
                , label = label
                }
                publicKey
                data

        Nothing ->
            Gren.Kernel.Crypto.encrypt
                { name = "RSA-OAEP"
                }
                publicKey
                data
                

{-| Encrypt some `Bytes` with a provided algorithm.
-}
encrypt : SecureContext -> EncryptionAlgorithm -> Bytes -> Task {} Bytes
encrypt _context algorithm data =
    case algorithm of
        EncryptWithAesCtr key { counter, length } ->
            Task.fail {}
        
        EncryptWithAesCbc key { iv } ->
            Task.fail {}

        EncryptWithAesGcm key { iv, additionalData = Just unwrappedAdditionalData, tagLength = Just unwrappedTagLength } ->
            Task.fail {}

        EncryptWithAesGcm key { iv, additionalData = Nothing, tagLength = Just unwrappedTagLength } ->
            Task.fail {}

        EncryptWithAesGcm key { iv, additionalData = Just unwrappedAdditionalData, tagLength = Nothing } ->
            Task.fail {}

        EncryptWithAesGcm key { iv, additionalData = Nothing, tagLength = Nothing } ->
            Task.fail {}


{-|-}
decrypt : SecureContext -> DecryptionAlgorithm -> Bytes -> Task {} Bytes
decrypt _context algorithm data =
    case algorithm of
        DecryptWithRsaOaep (PrivateKey (Key unwrappedPublicKey)) { label = Nothing } ->
            Gren.Kernel.Crypto.decrypt
                unwrappedPublicKey.key
                { name = unwrappedPublicKey.algorithm
                }
                data

        DecryptWithRsaOaep (PrivateKey (Key unwrappedPublicKey)) { label = Just label } ->
            Gren.Kernel.Crypto.decrypt
                unwrappedPublicKey.key
                { name = unwrappedPublicKey.algorithm
                , label = label
                }
                data

        DecryptWithAesCtr key { counter, length } ->
            Task.fail {}

        DecryptWithAesCbc key { iv } ->
            Task.fail {}

        DecryptWithAesGcm key { iv, additionalData = Just unwrappedAdditionalData, tagLength = Just unwrappedTagLength } ->
            Task.fail {}

        DecryptWithAesGcm key { iv, additionalData = Nothing, tagLength = Just unwrappedTagLength } ->
            Task.fail {}

        DecryptWithAesGcm key { iv, additionalData = Just unwrappedAdditionalData, tagLength = Nothing } ->
            Task.fail {}

        DecryptWithAesGcm key { iv, additionalData = Nothing, tagLength = Nothing } ->
            Task.fail {}


-- SIGN / VERIFY DATA


{-|-}
type SigningAlgorithm
    = SignWithRsassaPkcs1V1_5 (PrivateKey RsaSsaPkcs1V1_5Key)
    | SignWithRsaPss (PrivateKey RsaPssKey)
        { saltLength : Int -- longinteger
        }
    | SignWithEcdsa (PrivateKey EcdsaKey)
        { hash : DigestAlgorithm
        }
    | SignWithHmac (Key HmacKey)


{-|-}
type VerifyingAlgorithm
    = VerifyWithRsassaPkcs1V1_5 (PublicKey RsaSsaPkcs1V1_5Key)
    | VerifyWithRsaPss (PublicKey RsaPssKey)
        { saltLength : Int -- longinteger
        }
    | VerifyWithEcdsa (PublicKey EcdsaKey)
        { hash : DigestAlgorithm
        }
    | VerifyWithHmac (Key HmacKey)


{-|-}
sign : SecureContext -> SigningAlgorithm -> Bytes -> Task {} Bytes
sign _context algorithm data =
    case algorithm of
        SignWithRsassaPkcs1V1_5 key ->
            Task.fail {}
        
        SignWithRsaPss key { saltLength } ->
            Task.fail {}
        
        SignWithEcdsa key { hash } ->
            Task.fail {}

        SignWithHmac key ->
            Task.fail {}


{-|-}
verify : SecureContext -> VerifyingAlgorithm -> Bytes -> Task {} Bytes
verify _context algorithm data =
    case algorithm of
        VerifyWithRsassaPkcs1V1_5 key ->
            Task.fail {}
        
        VerifyWithRsaPss key { saltLength } ->
            Task.fail {}
        
        VerifyWithEcdsa key { hash } ->
            Task.fail {}

        VerifyWithHmac key ->
            Task.fail {}


-- DIGEST


{-| Supported algorithms suitable for digesting data.

Note: The algorithm `SHA1` is supported by the WebCrypto API, but not available 
in this package due to known security vunerabilities.
-}
type DigestAlgorithm
    = Sha256
    | Sha384
    | Sha512


{-|-}
digest : SecureContext -> DigestAlgorithm -> Bytes -> Task {} Bytes
digest _context algorithm data =
    Gren.Kernel.Crypto.digest
        (digestAlgorithmToString algorithm)
        data


-- DERIVE


{-|-}
type DeriveAlgorithm a
    = Ecdh 
        { publicKey : Key a
        }
    | Hkdf
        { hash : DigestAlgorithm
        , salt : Bytes
        , info : Bytes
        }
    | Pbkdf2
        { hash : DigestAlgorithm
        , salt : Bytes
        , iterations : Int
        }


{-|-}
deriveBits : SecureContext -> DeriveAlgorithm a -> Int -> Task x Bytes
deriveBits _context algorithm length =
    -- Note: length should be divisible by 8
    Debug.todo ""


{-| Derive a `Key HmacKey` from an existing key value.
-}
deriveHmacKey : SecureContext -> DeriveAlgorithm a -> Key a -> DigestAlgorithm -> Maybe Int -> Extractable -> Task String (Key HmacKey)
deriveHmacKey _context algorithm key digestAlgorithm length extractable =
    case algorithm of
        Ecdh { publicKey } ->
            Gren.Kernel.Crypto.deriveKey
                publicKey
                key
                { name = "HMAC"
                , hash = digestAlgorithmToString digestAlgorithm
                , length = length -- todo
                }
                extractable
                [ "deriveKey", "deriveBytes" ]
        
        Hkdf { hash, salt, info } ->
            Gren.Kernel.Crypto.deriveKey
                {}
        
        Pbkdf2 { hash, salt, iterations } ->
            Gren.Kernel.Crypto.deriveKey
                {}


{-|-}
deriveAesCtrKey =
    Debug.todo ""


{-|-}
deriveAesCbcKey =
    Debug.todo ""


{-|-}
deriveAesGcmKey =
    Debug.todo ""


{-|-}
deriveHkdfKey =
    Debug.todo ""


{-| Generate a key for [...]

The only use for this key is to derive other keys using the `deriveKey` 
function.
-}
derivePbkdf2Key =
    Debug.todo ""


-- EXPORT KEYS


{-| Errors that can arise when exporting keys.

- `NotExportable` happens when trying to export a key that was not made
`Extractable` during creation or import.
-}
type ExportKeyError
    = KeyNotExportable


{-| Export a `RsaOaepKey` as a [SubjectPublicKeyInfo](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#subjectpublickeyinfo).

The result `Bytes` can be imported again using the `importRsaOaepPublicKey` function.
-}
exportRsaOaepPublicKeyAsSpki : SecureContext -> PublicKey RsaOaepKey -> Task ExportKeyError Bytes
exportRsaOaepPublicKeyAsSpki _context (PublicKey key) =
    exportKeyAsSpki key


{-| Export a `RsaOaepKey` as a [JSON Web Key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#json_web_key).

The resulting `Json.Encode.Value` can be imported again using the `importRsaOaepPublicKey` function.
-}
exportRsaOaepPublicKeyAsJwk : SecureContext -> PublicKey RsaOaepKey -> Task ExportKeyError Json.Encode.Value
exportRsaOaepPublicKeyAsJwk _context (PublicKey key) =
    exportKeyAsJwk key


{-| Export a `RsaOaepKey` as [PKCS #8](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#pkcs_8)
-}
exportRsaOaepPrivateKeyAsPkcs8 : SecureContext -> PrivateKey RsaOaepKey -> Task ExportKeyError Bytes
exportRsaOaepPrivateKeyAsPkcs8 _context (PrivateKey key) =
    exportKeyAsPkcs8 key


{-| Export a private `RsaOaepKey` as a [JSON Web Key]() 
-}
exportRsaOaepPrivateKeyAsJwk : SecureContext -> PrivateKey RsaOaepKey -> Task ExportKeyError Json.Encode.Value
exportRsaOaepPrivateKeyAsJwk _context (PrivateKey key) =
    exportKeyAsJwk key


{-|-}
exportRsaPssPublicKeyAsSpki : SecureContext -> PublicKey RsaPssKey -> Task ExportKeyError Bytes
exportRsaPssPublicKeyAsSpki _context (PublicKey key)=
    exportKeyAsSpki key


{-|-}
exportRsaPssPublicKeyAsJwk : SecureContext -> PublicKey RsaPssKey -> Task ExportKeyError Json.Encode.Value
exportRsaPssPublicKeyAsJwk _context (PublicKey key) =
    exportKeyAsJwk key


{-|-}
exportRsaPssPrivateKeyAsPkcs8 : SecureContext -> PrivateKey RsaPssKey -> Task ExportKeyError Bytes
exportRsaPssPrivateKeyAsPkcs8 _context (PrivateKey key) =
    exportKeyAsPkcs8 key


{-|-}
exportRsaPssPrivateKeyAsJwk : SecureContext -> PrivateKey RsaPssKey -> Task ExportKeyError Json.Encode.Value
exportRsaPssPrivateKeyAsJwk _context (PrivateKey key) =
    exportKeyAsJwk key


{-|-}
exportRsaSsaPkcs1V1_5PublicKeyAsSpki : SecureContext -> PublicKey RsaSsaPkcs1V1_5Key -> Task ExportKeyError Bytes
exportRsaSsaPkcs1V1_5PublicKeyAsSpki _context (PublicKey key) =
    exportKeyAsSpki key


{-|-}
exportRsaSsaPkcs1V1_5PublicKeyAsJwk : SecureContext -> PublicKey RsaSsaPkcs1V1_5Key -> Task ExportKeyError Json.Encode.Value
exportRsaSsaPkcs1V1_5PublicKeyAsJwk _context (PublicKey key) =
    exportKeyAsJwk key


{-|-}
exportRsaSsaPkcs1V1_5PrivateKeyAsPkcs8 : SecureContext -> PrivateKey RsaSsaPkcs1V1_5Key -> Task ExportKeyError Bytes
exportRsaSsaPkcs1V1_5PrivateKeyAsPkcs8 _context (PrivateKey key)=
    exportKeyAsPkcs8 key


{-|-}
exportRsaSsaPkcs1V1_5PrivateKeyAsJwk : SecureContext -> PrivateKey RsaSsaPkcs1V1_5Key -> Task ExportKeyError Json.Encode.Value
exportRsaSsaPkcs1V1_5PrivateKeyAsJwk _context (PrivateKey key) =
    exportKeyAsJwk key


{-|-}
exportAesCtrKeyAsRaw : SecureContext -> Key AesCtrKey -> Task ExportKeyError Bytes
exportAesCtrKeyAsRaw _context =
    exportKeyAsRaw


{-|-}
exportAesCtrKeyAsJwk : SecureContext -> Key AesCtrKey -> Task ExportKeyError Json.Encode.Value
exportAesCtrKeyAsJwk _context =
    exportKeyAsJwk


{-|-}
exportAesCbcKeyAsRaw : SecureContext -> Key AesCbcKey -> Task ExportKeyError Bytes
exportAesCbcKeyAsRaw _context =
    exportKeyAsRaw


{-|-}
exportAesCbcKeyAsJwk : SecureContext -> Key AesCbcKey -> Task ExportKeyError Json.Encode.Value
exportAesCbcKeyAsJwk _context =
    exportKeyAsJwk


{-|-}
exportAesGcmKeyAsRaw : SecureContext -> Key AesGcmKey -> Task ExportKeyError Bytes
exportAesGcmKeyAsRaw _context =
    exportKeyAsRaw


{-|-}
exportAesGcmKeyAsJwk : SecureContext -> Key AesGcmKey -> Task ExportKeyError Json.Encode.Value
exportAesGcmKeyAsJwk _context =
    exportKeyAsJwk


{-|-}
exportEcdsaPublicKeyAsRaw : SecureContext -> PublicKey EcdsaKey -> Task ExportKeyError Bytes
exportEcdsaPublicKeyAsRaw _context (PublicKey key) =
    exportKeyAsRaw key


{-|-}
exportEcdsaPublicKeyAsSpki : SecureContext -> PublicKey EcdsaKey -> Task ExportKeyError Bytes
exportEcdsaPublicKeyAsSpki _context (PublicKey key) =
    exportKeyAsSpki key


{-|-}
exportEcdsaPublicKeyAsJwk : SecureContext -> PublicKey EcdsaKey -> Task ExportKeyError Json.Encode.Value
exportEcdsaPublicKeyAsJwk _context (PublicKey key) =
    exportKeyAsJwk key


{-|-}
exportEcdsaPrivateKeyAsPkcs8 : SecureContext -> PrivateKey EcdsaKey -> Task ExportKeyError Bytes
exportEcdsaPrivateKeyAsPkcs8 _context (PrivateKey key) =
    exportKeyAsPkcs8 key


{-|-}
exportEcdsaPrivateKeyAsJwk : SecureContext -> PrivateKey EcdsaKey -> Task ExportKeyError Json.Encode.Value
exportEcdsaPrivateKeyAsJwk _context (PrivateKey key)=
    exportKeyAsJwk key


{-|-}
exportEcdhPublicKeyAsRaw : SecureContext -> PublicKey EcdhKey -> Task ExportKeyError Bytes
exportEcdhPublicKeyAsRaw _context (PublicKey key) =
    exportKeyAsRaw key


{-|-}
exportEcdhPublicKeyAsSpki : SecureContext -> PublicKey EcdhKey -> Task ExportKeyError Bytes
exportEcdhPublicKeyAsSpki _context (PublicKey key) =
    exportKeyAsSpki key


{-|-}
exportEcdhPublicKeyAsJwk : SecureContext -> PublicKey EcdhKey -> Task ExportKeyError Json.Encode.Value
exportEcdhPublicKeyAsJwk _context (PublicKey key) =
    exportKeyAsJwk key


{-|-}
exportEcdhPrivateKeyAsPkcs8 : SecureContext -> PrivateKey EcdhKey -> Task ExportKeyError Bytes
exportEcdhPrivateKeyAsPkcs8 _context (PrivateKey key) =
    exportKeyAsPkcs8 key


{-|-}
exportEcdhPrivateKeyAsJwk : SecureContext -> PrivateKey EcdhKey -> Task ExportKeyError Json.Encode.Value
exportEcdhPrivateKeyAsJwk _context (PrivateKey key) =
    exportKeyAsJwk key


{-|-}
exportHmacKeyAsRaw : SecureContext -> Key HmacKey -> Task ExportKeyError Bytes
exportHmacKeyAsRaw _context =
    exportKeyAsRaw


{-|-}
exportHmacKeyAsJwk : SecureContext -> Key HmacKey -> Task ExportKeyError Json.Encode.Value
exportHmacKeyAsJwk _context =
    exportKeyAsJwk


{-|-}
exportKeyHelper : String -> Key a -> Task ExportKeyError b
exportKeyHelper keyType (Key { extractable, key }) =
    if extractable then
        Gren.Kernel.Crypto.exportKey keyType key

    else
        Task.fail KeyNotExportable


{-|-}
exportKeyAsRaw : Key a -> Task ExportKeyError Bytes
exportKeyAsRaw =
    exportKeyHelper "raw"


{-|-}
exportKeyAsPkcs8 : Key a -> Task ExportKeyError Bytes
exportKeyAsPkcs8 =
    exportKeyHelper "pkcs8"


{-|-}
exportKeyAsSpki : Key a -> Task ExportKeyError Bytes
exportKeyAsSpki =
    exportKeyHelper "spki"


{-|-}
exportKeyAsJwk : Key a -> Task ExportKeyError Json.Encode.Value
exportKeyAsJwk key =
    Task.map Gren.Kernel.Json.wrap (exportKeyHelper "jwk" key)


-- IMPORT KEYS


{-| Parameters required for importing a key using an RSA algorithm.
-}
type alias ImportRsaKeyParams =
    { hash : DigestAlgorithm
    }


{-| Appears if there's an error when importing a key using an RSA algorithm.

There are two possible reasons this error happens:

1. The passed key value (either `Json.Encode.Value` or `Bytes`) is not 
a valid key and cannot be imported.
2. The `hash` passed to the function does not match the `hash` of the imported key. This only 
happens when importing a JSON Web Key. It is recommended to _always_ match the hash of the 
imported key or you will get different results when using the imported key.
-}
type ImportRsaKeyError
    = ImportRsaKeyError


{-|-}
importRsaOaepPublicKeyFromJwk : SecureContext -> Json.Encode.Value -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PublicKey RsaOaepKey)
importRsaOaepPublicKeyFromJwk _context jwk { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "public"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "RSA-OAEP"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "encrypt" ]


{-|-}
importRsaOaepPublicKeyFromSpki : SecureContext -> Bytes -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PublicKey RsaOaepKey)
importRsaOaepPublicKeyFromSpki _context bytes { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "public"
        "spki"
        bytes
        "RSA-OAEP"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "encrypt" ]


{-|-}
importRsaPssPublicKeyFromJwk : SecureContext -> Json.Encode.Value -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PublicKey RsaPssKey)
importRsaPssPublicKeyFromJwk _context jwk { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "public"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "RSA-PSS"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "verify" ]


{-|-}
importRsaPssPublicKeyFromSpki : SecureContext -> Bytes -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PublicKey RsaPssKey)
importRsaPssPublicKeyFromSpki _context bytes { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "public"
        "spki"
        bytes
        "RSA-PSS"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "verify" ]


{-|-}
importRsaOaepPrivateKeyFromJwk : SecureContext -> Json.Encode.Value -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PrivateKey RsaOaepKey)
importRsaOaepPrivateKeyFromJwk _context jwk { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "private"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "RSA-OAEP"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "decrypt" ]


{-|-}
importRsaOaepPrivateKeyFromPkcs8 : SecureContext -> Bytes -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PrivateKey RsaOaepKey)
importRsaOaepPrivateKeyFromPkcs8 _context bytes { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "private"
        "pkcs8"
        bytes
        "RSA-OAEP"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "decrypt" ]


{-|-}
importRsaPssPrivateKeyFromJwk : SecureContext -> Json.Encode.Value -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PrivateKey RsaPssKey)
importRsaPssPrivateKeyFromJwk _context jwk { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "private"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "RSA-PSS"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "sign" ]


{-|-}
importRsaPssPrivateKeyFromPkcs8 : SecureContext -> Bytes -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PrivateKey RsaPssKey)
importRsaPssPrivateKeyFromPkcs8 _context bytes { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "private"
        "pkcs8"
        bytes
        "RSA-PSS"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "sign" ]


{-|-}
importRsaSsaPkcs1V1_5PublicKeyFromJwk : SecureContext -> Json.Encode.Value -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PrivateKey RsaSsaPkcs1V1_5Key)
importRsaSsaPkcs1V1_5PublicKeyFromJwk _context jwk { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "public"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "RSASSA-PKCS1-v1_5"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "sign" ]


{-|-}
importRsaSsaPkcs1V1_5PublicKeyFromSpki : SecureContext -> Bytes -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PrivateKey RsaSsaPkcs1V1_5Key)
importRsaSsaPkcs1V1_5PublicKeyFromSpki _context bytes { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "public"
        "spki"
        bytes
        "RSASSA-PKCS1-v1_5"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "verify" ]


{-|-}
importRsaSsaPkcs1V1_5PrivateKeyFromJwk : SecureContext -> Json.Encode.Value -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PrivateKey RsaSsaPkcs1V1_5Key)
importRsaSsaPkcs1V1_5PrivateKeyFromJwk _context jwk { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "private"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "RSASSA-PKCS1-v1_5"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "sign" ]


{-|-}
importRsaSsaPkcs1V1_5PrivateKeyFromPkcs8 : SecureContext -> Bytes -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PrivateKey RsaSsaPkcs1V1_5Key)
importRsaSsaPkcs1V1_5PrivateKeyFromPkcs8 _context bytes { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "private"
        "pkcs8"
        bytes
        "RSASSA-PKCS1-v1_5"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "sign" ]


{-|-}
type ImportAesKeyError
    = ImportAesKeyError


{-|-}
importAesCtrKeyFromRaw : SecureContext -> Bytes -> Extractable -> Task ImportAesKeyError (Key AesCtrKey)
importAesCtrKeyFromRaw _context bytes extractable =
    Gren.Kernel.Crypto.importAesKey
        "raw"
        bytes
        "AES-CTR"
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-|-}
importAesCtrKeyFromJwk : SecureContext -> Json.Encode.Value -> Extractable -> Task ImportAesKeyError (Key AesCtrKey)
importAesCtrKeyFromJwk _context jwk extractable =
    Gren.Kernel.Crypto.importAesKey
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "AES-CTR"
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-|-}
importAesCbcKeyFromRaw : SecureContext -> Bytes -> Extractable -> Task ImportAesKeyError (Key AesCtrKey)
importAesCbcKeyFromRaw _context bytes extractable =
    Gren.Kernel.Crypto.importAesKey
        "raw"
        bytes
        "AES-CBC"
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-|-}
importAesCbcKeyFromJwk : SecureContext -> Json.Encode.Value -> Extractable -> Task ImportAesKeyError (Key AesCtrKey)
importAesCbcKeyFromJwk _context jwk extractable =
    Gren.Kernel.Crypto.importAesKey
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "AES-CBC"
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-|-}
importAesGcmKeyFromRaw : SecureContext -> Bytes -> Extractable -> Task ImportAesKeyError (Key AesCtrKey)
importAesGcmKeyFromRaw _context bytes extractable =
    Gren.Kernel.Crypto.importAesKey
        "raw"
        bytes
        "AES-GCM"
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-|-}
importAesGcmKeyFromJwk : SecureContext -> Json.Encode.Value -> Extractable -> Task ImportAesKeyError (Key AesCtrKey)
importAesGcmKeyFromJwk _context jwk extractable =
    Gren.Kernel.Crypto.importAesKey
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "AES-GCM"
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-|-}
type ImportEcKeyError
    = ImportEcKeyError


{-|-}
importEcdsaPublicKeyFromRaw _context =
    Debug.todo ""


{-|-}
importEcdsaPublicKeyFromSpki _context =
    Debug.todo ""


{-|-}
importEcdsaPublicKeyFromJwk _context =
    Debug.todo ""


{-|-}
importEcdhPublicKeyFromRaw _context =
    Debug.todo ""


{-|-}
importEcdhPublicKeyFromSpki _context =
    Debug.todo ""


{-|-}
importEcdhPublicKeyFromJwk _context =
    Debug.todo ""


{-|-}
importEcdsaPrivateKeyFromPkcs _context =
    Debug.todo ""


{-|-}
importEcdsaPrivateKeyFromSpki _context =
    Debug.todo ""


{-|-}
importEcdsaPrivateKeyFromJwk _context =
    Debug.todo ""


{-|-}
importEcdhPrivateKeyFromPkcs _context =
    Debug.todo ""


{-|-}
importEcdhPrivateKeyFromSpki _context =
    Debug.todo ""


{-|-}
importEcdhPrivateKeyFromJwk _context =
    Debug.todo ""


{-| Appears if there's an error when importing a key using the HMAC algorithm.

There are not specific error types for importing HMAC keys due to inconsistencies
in how errors are thrown across `browser` and `node` platforms.

There are three known reasons an error can happen when importing HMAC keys:

1. The passed key value (either `Json.Encode.Value` or `Bytes`) is not a valid key 
and cannot be imported.
1. The `length` passed to the function is not correct for the imported key. The
appearance of this error is inconsistent across `browser` and `node` platforms. It's
recommended to avoid passing a `length` and instead use `Nothing` for both HMAC key
generation and importing.
2. The `hash` passed to the function does not match the `hash` of the imported key.
This only happens when importing a JSON Web Key. It is recommended to _always_ match 
the hash of the imported key or you will get different results when using the imported 
key for cryptographic functions.
-}
type ImportHmacKeyError
    = ImportHmacKeyError


{-|-}
importHmacKeyFromJwk : SecureContext -> Json.Encode.Value -> DigestAlgorithm -> Maybe Int -> Extractable -> Task ImportHmacKeyError (PrivateKey EcdhKey)
importHmacKeyFromJwk _context jwk hash passedLength extractable =
    case passedLength of
        Just length ->
            Gren.Kernel.Crypto.importHmacKey
                "jwk"
                (Gren.Kernel.Json.unwrap jwk)
                "HMAC"
                (digestAlgorithmToString hash)
                length
                (extractableToBool extractable)
                [ "sign", "verify" ]

        Nothing ->
            Gren.Kernel.Crypto.importHmacKey
                "jwk"
                (Gren.Kernel.Json.unwrap jwk)
                "HMAC"
                (digestAlgorithmToString hash)
                ""
                (extractableToBool extractable)
                [ "sign", "verify" ]


{-|-}
importHmacKeyFromRaw : SecureContext -> Bytes -> DigestAlgorithm -> Maybe Int -> Extractable -> Task ImportHmacKeyError (PrivateKey EcdhKey)
importHmacKeyFromRaw _context bytes hash passedLength extractable =
    case passedLength of
        Just length ->
            Gren.Kernel.Crypto.importHmacKey
                "raw"
                bytes
                 "HMAC"
                (digestAlgorithmToString hash)
                length
                (extractableToBool extractable)
                [ "sign", "verify" ]

        Nothing ->
            Gren.Kernel.Crypto.importHmacKey
                "raw"
                bytes
                "HMAC"
                (digestAlgorithmToString hash)
                ""
                (extractableToBool extractable)
                [ "sign", "verify" ]



-- UTILITIES


{-|-}
clamp : Int -> Int -> Int -> Int
clamp min max number =
    if number < min then
        min

    else if number > max then
        max

    else
        number


{-|-}
ecNamedCurveToString : EcNamedCurve -> String
ecNamedCurveToString namedCurve =
    case namedCurve of
        P256 ->
            "P-256"

        P384 ->
            "P-384"

        P521 ->
            "P-521"


{-|-}
aesLengthToInt : AesLength -> Int
aesLengthToInt length =
    case length of
        AesLength128 ->
            128

        -- AesLength192 ->
        --     192

        AesLength256 ->
            256


{-|-}
extractableToBool : Extractable -> Bool
extractableToBool extractable =
    case extractable of
        CanBeExtracted ->
            True
            
        CannotBeExtracted ->
            False


{-|-}
digestAlgorithmToString : DigestAlgorithm -> String
digestAlgorithmToString digestAlgorithm =
    case digestAlgorithm of
        Sha256 ->
            "SHA-256"

        Sha384 ->
            "SHA-384"

        Sha512 ->
            "SHA-512"
