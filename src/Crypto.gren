module Crypto exposing 
    ( SecureContext
    , DigestAlgorithm(..)
    , Extractable(..)
    , Key, KeyPair, RsaOaepKey
    , encrypt, decrypt
    , randomUuid, getRandomValues, isSecureContext
    , generateRsaOaepKey
    )


{-| 

## Crypto

This module gives access to various cryptograhic functions provided by the Web 
Crypto API on both `browser` and `node` platforms.

-- todo: write docs!

-}


import Array exposing ( Array )
import Basics exposing ( Bool(..), Int, (<), (<=) )
import Gren.Kernel.Crypto
import String exposing ( String )
import Task exposing ( Task )
import Debug
import Bytes exposing ( Bytes )
import Maybe exposing ( Maybe(..) )
import Result exposing ( Result(..) )
import Set exposing ( Set )


-- TYPES


{-| Represents the platform being considered secure. This type can be generated 
using the `isSecureContext` function and is required for some functions to be 
run in this package.
-}
type SecureContext
    = SecureContext


{-| A generated key.
-}
type Key algorithm
    = Key 
        { key : algorithm
        , algorithm : String
        , keyType : String
        , extractable : Bool
        , usages : Array String 
        }


{-| A pair (public and private) of keys.
-}
type KeyPair a =
    KeyPair
        { publicKey : Key a
        , privateKey : Key a
        }


-- BASE FUNCTIONS


{-| Generate a random UUID using the UUID v4 algorithm.
-}
randomUuid : Task x String
randomUuid =
    Gren.Kernel.Crypto.randomUUID


{-| Get an `Array` of random values equal in length to the passed `Int`.

If the passed `Int` is `0` or less, the task will resolve into an empty `Array`. 
-}
getRandomValues : Int -> Task x (Array String)
getRandomValues int =
    if int <= 0 then
        Task.succeed []
    else
        Gren.Kernel.Crypto.getRandomValues int


-- ENVIRONMENT


{-| A `Task` that succeeds with `SecureContext` if the code is being run in a 
secure context. This value is a required parameter for some functions given they
will only run properly in a secure context.

When running this in `node`, it should always succeed as node is always considered 
a secure context. If that's not the case, please file a bug!
-}
isSecureContext : Task {} SecureContext
isSecureContext =
    Gren.Kernel.Crypto.getContext


-- KEYS


{-| Denotes if a key can be exported using the `exportKey` or `exportKeyPair`
functions. If a key is not marked as exportable when it is created, any attempts
to export the key will fail.
-}
type Extractable
    = CanBeExtracted
    | CannotBeExtracted


-- RSA KEYS


{-| Represents a key generated and for use with the RSA-OAEP algorithm used to 
encrypt and decrypt values.
-}
type RsaOaepKey
    = RsaOaepKey


{-| Represents a key generated and for use with the RSA-PSS algorithm used to 
sign and verify values.
-}
type RsaPssKey =
    RsaPssKey


{-| A key generated for and for use with the RSASSA-PKCS1-v1_5 algorithm. Used
to sign and verify values.
-}
type RsassaPkcs1V1_5Key
    = RsassaPkcs1V1_5Key


{-| Parameters required to generate a key with any RSA algorithm.

`modulusLength` must be at least 2048. If a lower number, it will be set to 
`2048` automatically.
-}
type alias RsaKeyParams =
    { modulusLength : Int
    , hash : DigestAlgorithm
    }


{-| Generate a new key pair using the RSA-OAEP algorithm.

This function does not currently allow editing the public exponent value. It's
instead always set to `655371`, a recommended value.

Produces a `KeyPair` consisting of a private and public key. This `KeyPair` can 
be used to encrypt and decrypt `Bytes`.
-}
generateRsaOaepKey : SecureContext -> RsaKeyParams -> Extractable -> Task x (KeyPair RsaOaepKey)
generateRsaOaepKey _context { modulusLength, hash } extractable =
    Gren.Kernel.Crypto.generateKey 
        { name = "RSA-OAEP"
        , modulusLength = if modulusLength < 2048 then 2048 else modulusLength
        , publicExponent = [ 1, 0, 1 ]
        , hash = digestAlgorithmToString hash
        }
        (extractableToBool extractable)
        [ "encrypt", "decrypt", "wrapKey", "unwrapKey" ]


{-|-}
generateRsaPssKey : SecureContext -> RsaKeyParams -> Extractable -> Task x (Key RsaPssKey)
generateRsaPssKey _context { modulusLength, hash } extractable =
    Gren.Kernel.Crypto.generateKey
        { name = "RSA-PSS"
        , modulusLength = if modulusLength < 2048 then 2048 else modulusLength
        , publicExponent = [ 1, 0, 1 ]
        , hash = digestAlgorithmToString hash
        }
        (extractableToBool extractable)
        [ "sign", "verify" ]


{-|-}
generateRsassaPkcs1V1_5Key : SecureContext -> RsaKeyParams -> Extractable -> Task x (Key RsassaPkcs1V1_5Key)
generateRsassaPkcs1V1_5Key _context { modulusLength, hash } extractable =
    Gren.Kernel.Crypto.generateKey
        { name = "RSASSA-PKCS1-v1_5"
        , modulusLength = if modulusLength < 2048 then 2048 else modulusLength
        , publicExponent = [ 1, 0, 1 ]
        , hash = digestAlgorithmToString hash
        }
        (extractableToBool extractable)
        [ "sign", "verify" ]


-- AES KEYS


{-| Represents a key generated and for use with the AES-CTR algorithm used to
encrypt and decrypt values.
-}
type AesCtrKey
    = AesCtrKey


{-| Represents a key generated and for use with the AES-CBC algorithm used to
encrypt and decrypt values.
-}
type AesCbcKey
    = AesCbcKey


{-| Represents a key generated and for use with the AES-GCM algorithm used to
encrypt and decrypt values.
-}
type AesGcmKey
    = AesGcmKey


{-| The length of bits of the key that is being generated using the AES 
algorithm. These are the only values that can be chosen.
-}
type AesLength
    = AesLength128
    | AesLength192
    | AesLength256


{-| Generate a new key using the AES-CTR algorithm.
-}
generateAesCtrKey : SecureContext -> AesLength -> Extractable -> Task x (Key AesCtrKey)
generateAesCtrKey _context length extractable =
    Gren.Kernel.Crypto.generateKey
        { name = "AES-CTR"
        , length = aesLengthToInt length
        }
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-| Generate a new key using the AES-CTR algorithm.
-}
generateAesCbcKey : SecureContext -> AesLength -> Extractable -> Task x (Key AesCbcKey)
generateAesCbcKey _context length extractable =
    Gren.Kernel.Crypto.generateKey
        { name = "AES-CBC"
        , length = aesLengthToInt length
        }
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-| Generate a new key using the AES-GCM algorithm.
-}
generateAesGcmKey : SecureContext -> AesLength -> Extractable -> Task x (Key AesGcmKey)
generateAesGcmKey _context length extractable =
    Gren.Kernel.Crypto.generateKey
        { name = "AES-GCM"
        , length = aesLengthToInt length
        }
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


-- EC KEYS


{-|-}
type EcNamedCurve
    = P256
    | P384
    | P521


{-|-}
type EcdsaKey
    = EcdsaKey


{-|-}
type EcdhKey
    = EcdhKey


{-|-}
generateEcdsaKey : SecureContext -> EcNamedCurve -> Extractable -> Task x (Key EcdsaKey)
generateEcdsaKey _context namedCurve extractable =
    Gren.Kernel.Crypto.generateKey
        { name = "ECDSA"
        , namedCurve = ecNamedCurveToString namedCurve
        }
        (extractableToBool extractable)
        [ "sign", "verify" ]


{-|-}
generateEcdhKey : SecureContext -> EcNamedCurve -> Extractable -> Task x (Key EcdhKey)
generateEcdhKey _context namedCurve extractable =
    Gren.Kernel.Crypto.generateKey
        { name = "ECDH"
        , namedCurve = ecNamedCurveToString namedCurve
        }
        (extractableToBool extractable)
        [ "deriveKey", "deriveBytes" ]


-- HMAC KEYS


{-|-}
type HmacKey =
    HmacKey


{-|-}
generateHmacKey : SecureContext -> DigestAlgorithm -> Maybe Int -> Extractable -> Task x (Key HmacKey)
generateHmacKey _context hash passedLength extractable =
    case passedLength of
        Just length ->
            Gren.Kernel.Crypto.generateKey
                { name = "HMAC"
                , hash = digestAlgorithmToString hash
                , length = length
                }
                (extractableToBool extractable)
                [ "deriveKey", "deriveBytes" ]

        Nothing ->
            Gren.Kernel.Crypto.generateKey
                { name = "HMAC"
                , hash = digestAlgorithmToString hash
                }
                (extractableToBool extractable)
                [ "deriveKey", "deriveBytes" ]


-- ENCRYPT / DECRYPT DATA


{-|-}
type EncryptionAlgorithm
    = RsaOaep (KeyPair RsaOaepKey)
        { label : Maybe Bytes
        }
    | AesCtr (Key AesCtrKey)
        { counter : Bytes
        , length : Int
        }
    -- The `iv` value _must_ be unique for each encryption operation with the same key
    | AesCbc (Key AesCbcKey)
        { iv : Bytes
        }
    | AesGcm (Key AesGcmKey) -- https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams
        { iv : Bytes
        , additionalData : Maybe Bytes -- The bit length of additionalData must be smaller than 2^64 - 1
        , tagLength : Maybe Int -- Must be one of: 96, 104, 112, 120 or 128 - fill in with type later
        }


{-|-}
type alias DecryptionAlgorithm =
    EncryptionAlgorithm


{-| Encrypt some `Bytes` with a provided algorithm.
-}
encrypt : SecureContext -> EncryptionAlgorithm -> Bytes -> Task {} Bytes
encrypt _context algorithm data =
    case algorithm of
        RsaOaep (KeyPair { publicKey = Key unwrappedPublicKey }) { label = Nothing } ->
            Gren.Kernel.Crypto.encrypt
                unwrappedPublicKey.key
                { name = unwrappedPublicKey.algorithm
                }
                data

        RsaOaep (KeyPair { publicKey = Key unwrappedPublicKey }) { label = Just label } ->
            Gren.Kernel.Crypto.encrypt
                unwrappedPublicKey.key
                { name = unwrappedPublicKey.algorithm
                , label = label
                }
                data

        AesCtr key { counter, length } ->
            Task.fail {}
        
        AesCbc key { iv } ->
            Task.fail {}

        AesGcm key { iv, additionalData = Just unwrappedAdditionalData, tagLength = Just unwrappedTagLength } ->
            Task.fail {}

        AesGcm key { iv, additionalData = Nothing, tagLength = Just unwrappedTagLength } ->
            Task.fail {}

        AesGcm key { iv, additionalData = Just unwrappedAdditionalData, tagLength = Nothing } ->
            Task.fail {}

        AesGcm key { iv, additionalData = Nothing, tagLength = Nothing } ->
            Task.fail {}


{-|-}
decrypt : SecureContext -> DecryptionAlgorithm -> Bytes -> Task {} Bytes
decrypt _context algorithm data =
    case algorithm of
        RsaOaep (KeyPair { publicKey = Key unwrappedPublicKey }) { label = Nothing } ->
            Gren.Kernel.Crypto.decrypt
                unwrappedPublicKey.key
                { name = unwrappedPublicKey.algorithm
                }
                data

        RsaOaep (KeyPair { publicKey = Key unwrappedPublicKey }) { label = Just label } ->
            Gren.Kernel.Crypto.decrypt
                unwrappedPublicKey.key
                { name = unwrappedPublicKey.algorithm
                , label = label
                }
                data

        AesCtr key { counter, length } ->
            Task.fail {}

        AesCbc key { iv } ->
            Task.fail {}

        AesGcm key { iv, additionalData = Just unwrappedAdditionalData, tagLength = Just unwrappedTagLength } ->
            Task.fail {}

        AesGcm key { iv, additionalData = Nothing, tagLength = Just unwrappedTagLength } ->
            Task.fail {}

        AesGcm key { iv, additionalData = Just unwrappedAdditionalData, tagLength = Nothing } ->
            Task.fail {}

        AesGcm key { iv, additionalData = Nothing, tagLength = Nothing } ->
            Task.fail {}


-- SIGN / VERIFY DATA


{-|-}
type SigningAlgorithm
    = RsassaPkcs1V1_5 (Key RsassaPkcs1V1_5Key)
    | RsaPss (Key RsaPssKey)
        { saltLength : Int -- longinteger
        }
    | Ecdsa (Key Ecdsa)
        { hash : DigestAlgorithm
        }
    | Hmac (Key Hmac)


{-|-}
type alias VerifyingAlgorithm
    = SigningAlgorithm


{-|-}
sign : SecureContext -> SigningAlgorithm -> Bytes -> Task {} Bytes
sign _context algorithm data =
    case algorithm of
        RsassaPkcs1V1_5 key ->
            Task.fail {}
        
        RsaPss key { saltLength } ->
            Task.fail {}
        
        Ecdsa key { hash } ->
            Task.fail {}

        Hmac key ->
            Task.fail {}


{-|-}
verify : SecureContext -> VerifyingAlgorithm -> Bytes -> Task {} Bytes
verify _context algorithm data =
    case algorithm of
        RsassaPkcs1V1_5 key ->
            Task.fail {}
        
        RsaPss key { saltLength } ->
            Task.fail {}
        
        Ecdsa key { hash } ->
            Task.fail {}

        Hmac key ->
            Task.fail {}


-- DIGEST


{-| Supported algorithms suitable for digesting data.

Note: The algorithm `SHA1` is supported by the WebCrypto API, but not available 
in this package due to known security vunerabilities.
-}
type DigestAlgorithm
    = Sha256
    | Sha384
    | Sha512


{-|-}
digest : SecureContext -> DigestAlgorithm -> Bytes -> Task {} Bytes
digest _context algorithm data =
    Gren.Kernel.Crypto.digest
        (digestAlgorithmToString algorithm)
        data


-- DERIVE


{-|-}
type DeriveAlgorithm
    = Ecdh (Key EcdhKey)
    | Hkdf
    | Pbkdf2


{-|-}
deriveBits =
    Debug.todo ""


{-|-}
deriveKey =
    Debug.todo ""


-- EXPORT / IMPORT KEYS


{-|-}
exportKeyPair : SecureContext -> KeyPair a -> Task x { publicKey : Bytes, privateKey : Bytes }
exportKeyPair context (KeyPair { privateKey, publicKey }) =
    Task.map2 (\exportedPublicKey exportedPrivateKey ->
            { publicKey = exportedPublicKey
            , privateKey = exportedPrivateKey
            }
        )
        (exportKeyHelper context "spki" publicKey)
        (exportKeyHelper context "pkcs8" privateKey)


{-|-}
exportKey : SecureContext -> Key a -> Task x Bytes
exportKey _context key =
    Debug.todo ""


{-|-}
importRsaOaepKeyPair : SecureContext -> { publicKey : Bytes, privateKey : Bytes } -> Task x (KeyPair RsaOaepKey)
importRsaOaepKeyPair _context =
    Debug.todo ""


{-|-}
importRsaPssKey : SecureContext -> RsaKeyParams -> Extractable -> Task x (Key RsaPssKey)
importRsaPssKey _context =
    Debug.todo ""


{-|-}
importRsassaPkcs1V1_5Key : SecureContext -> RsaKeyParams -> Extractable -> Task x (Key RsassaPkcs1V1_5Key)
importRsassaPkcs1V1_5Key _context =
    Debug.todo ""


{-|-}
importAesCtrKey : SecureContext -> AesLength -> Extractable -> Task x (Key AesCtrKey)
importAesCtrKey =
    Debug.todo ""


{-|-}
importAesCbcKey : SecureContext -> AesLength -> Extractable -> Task x (Key AesCbcKey)
importAesCbcKey =
    Debug.todo ""


{-|-}
importAesGcmKey : SecureContext -> AesLength -> Extractable -> Task x (Key AesGcmKey)
importAesGcmKey =
    Debug.todo ""


{-|-}
importEcdsaKey : SecureContext -> EcNamedCurve -> Extractable -> Task x (Key EcdsaKey)
importEcdsaKey _context =
    Debug.todo ""


{-|-}
importEcdhKey : SecureContext -> EcNamedCurve -> Extractable -> Task x (Key EcdhKey)
importEcdhKey _context =
    Debug.todo ""


{-|-}
importHmacKey =
    Debug.todo ""


-- UTILITIES


{-|-}
ecNamedCurveToString : EcNamedCurve -> String
ecNamedCurveToString namedCurve =
    case namedCurve of
        P256 ->
            "P-256"

        P384 ->
            "P-384"

        P521 ->
            "P-521"


{-|-}
aesLengthToInt : AesLength -> Int
aesLengthToInt length =
    case length of
        AesLength128 ->
            128

        AesLength192 ->
            192

        AesLength256 ->
            256


{-|-}
exportKeyHelper : SecureContext -> String -> Key a -> Task x Bytes
exportKeyHelper _context format (Key { key }) =
    Gren.Kernel.Crypto.exportKey format key


{-|-}
extractableToBool : Extractable -> Bool
extractableToBool extractable =
    case extractable of
        CanBeExtracted ->
            True
            
        CannotBeExtracted ->
            False


{-|-}
digestAlgorithmToString : DigestAlgorithm -> String
digestAlgorithmToString digestAlgorithm =
    case digestAlgorithm of
        Sha256 ->
            "SHA-256"

        Sha384 ->
            "SHA-384"

        Sha512 ->
            "SHA-512"
