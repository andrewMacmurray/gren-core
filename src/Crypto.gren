module Crypto exposing 
    ( getRandomInt8Values, getRandomUInt8Values
    , getRandomInt16Values, getRandomUInt16Values
    , getRandomInt32Values, getRandomUInt32Values
    , SecureContext, isSecureContext
    , randomUuid
    , Key, PublicKey, PrivateKey, KeyPair
    , Extractable(..)
    , RsaOaepKey, RsaPssKey, RsaSsaPkcs1V1_5Key, RsaKeyParams, RsaKeyGenerationError(..)
    , generateRsaOaepKeyPair, generateRsaPssKeyPair, generateRsaSsaPkcs1V1_5KeyPair
    , AesLength(..)
    , generateAesCtrKey, generateAesCbcKey, generateAesGcmKey
    , EcNamedCurve(..)
    , generateEcdsaKeyPair, generateEcdhKeyPair
    , HmacKeyParams, HmacKeyGenerationError(..)
    , generateHmacKey
    , ExportKeyError(..)
    , KeyPairV2
    , exportRsaOaepPublicKeyAsSpki, exportRsaOaepPublicKeyAsJwk
    , exportRsaOaepPrivateKeyAsPkcs8, exportRsaOaepPrivateKeyAsJwk
    , exportRsaPssPublicKeyAsSpki, exportRsaPssPublicKeyAsJwk
    , exportRsaPssPrivateKeyAsPkcs8, exportRsaPssPrivateKeyAsJwk
    , exportRsaSsaPkcs1V1_5PublicKeyAsSpki, exportRsaSsaPkcs1V1_5PublicKeyAsJwk
    , exportRsaSsaPkcs1V1_5PrivateKeyAsPkcs8, exportRsaSsaPkcs1V1_5PrivateKeyAsJwk
    , exportAesCtrKeyAsRaw, exportAesCtrKeyAsJwk
    , exportAesCbcKeyAsRaw, exportAesCbcKeyAsJwk
    , exportAesGcmKeyAsRaw, exportAesGcmKeyAsJwk
    , exportEcdsaPublicKeyAsRaw, exportEcdsaPublicKeyAsSpki, exportEcdsaPublicKeyAsJwk
    , exportEcdsaPrivateKeyAsPkcs8, exportEcdsaPrivateKeyAsJwk
    , exportEcdhPublicKeyAsRaw, exportEcdhPublicKeyAsSpki, exportEcdhPublicKeyAsJwk
    , exportEcdhPrivateKeyAsPkcs8, exportEcdhPrivateKeyAsJwk
    , exportHmacKeyAsRaw, exportHmacKeyAsJwk
    , ImportRsaKeyError(..)
    , importRsaOaepPublicKeyFromJwk, importRsaOaepPublicKeyFromSpki
    , importRsaOaepPrivateKeyFromJwk, importRsaOaepPrivateKeyFromPkcs8
    , importRsaPssPublicKeyFromJwk, importRsaPssPublicKeyFromSpki
    , importRsaPssPrivateKeyFromJwk, importRsaPssPrivateKeyFromPkcs8
    , importRsaSsaPkcs1V1_5PublicKeyFromJwk, importRsaSsaPkcs1V1_5PublicKeyFromSpki
    , importRsaSsaPkcs1V1_5PrivateKeyFromJwk, importRsaSsaPkcs1V1_5PrivateKeyFromPkcs8
    , ImportAesKeyError(..)
    , importAesCtrKeyFromRaw, importAesCtrKeyFromJwk
    , importAesCbcKeyFromRaw, importAesCbcKeyFromJwk
    , importAesGcmKeyFromRaw, importAesGcmKeyFromJwk
    , ImportEcKeyError(..)
    , importEcdsaPublicKeyFromRaw, importEcdsaPublicKeyFromSpki, importEcdsaPublicKeyFromJwk
    , importEcdhPublicKeyFromRaw, importEcdhPublicKeyFromSpki, importEcdhPublicKeyFromJwk
    , importEcdsaPrivateKeyFromPkcs8, importEcdsaPrivateKeyFromSpki, importEcdsaPrivateKeyFromJwk
    , importEcdhPrivateKeyFromPkcs8, importEcdhPrivateKeyFromSpki, importEcdhPrivateKeyFromJwk
    , ImportHmacKeyError(..)
    , importHmacKeyFromJwk, importHmacKeyFromRaw
    , DigestAlgorithm(..), digest
    , DecryptWithRsaOaepError(..)
    , encryptWithRsaOaep, decryptWithRsaOaep
    , AesCtrParams, AesCtrEncryptError(..), AesCtrDecryptError(..)
    , encryptWithAesCtr, decryptWithAesCtr
    , AesCbcParams, AesCbcEncryptionError(..), AesCbcDecryptionError(..)
    , encryptWithAesCbc, decryptWithAesCbc
    , AesGcmParams, AesGcmTagLength(..), AesGcmEncryptionError(..), AesGcmDecryptionError(..)
    , encryptWithAesGcm, decryptWithAesGcm
    , signWithRsaSsaPkcs1V1_5, verifyWithRsaSsaPkcs1V1_5
    , SignWithRsaPssError(..), signWithRsaPss, verifyWithRsaPss
    , signWithEcdsa, verifyWithEcdsa
    , signWithHmac, verifyWithHmac
    )


{-| 

This module gives access to various cryptograhic functions provided by the Web 
Crypto API on both `browser` and `node` platforms.

## Generate Random Values

Generate random values of 8, 16, or 32 bits long (signed and unsigned).

All functions for generating random values take an `Int` as the single parameter. 
This value is clamped to a minimum of `0` and a maximum of however many values can
be generated.

The maximum number of values that can be generated depends on the amount of bytes
the values you're generating are. 65536 is the maximum number of bytes that can be
generated. For example, when using `getRandomInt16Values`, each value is 16 bits 
(or 2 bytes), so the maximum number of values that `getRandomInt16Values` can generate
is 32768 values.

@docs getRandomInt8Values, getRandomUInt8Values

@docs getRandomInt16Values, getRandomUInt16Values

@docs getRandomInt32Values, getRandomUInt32Values

## Secure Context

Most functions in this module must be run in a secure context to operate safely
and correctly. Before you use any functions, it's likely you'll need to obtain
and store in your model the `SecureContext` value which can only be generated by
the successfull completion of a `Task` returned by the `isSecureContext` function.

@docs SecureContext, isSecureContext

## Generate Random UUIDs

@docs randomUuid

## Generate Keys

Generate, import, export, and derive keys for completing cryptographic operations. 
Each section covers a different sets of keys that use the same underlying algorithm. 
Each key can be only be used for specific cryptographic operations.

@docs Key, PublicKey, PrivateKey, KeyPair

@docs Extractable

### Generate RSA Keys

Generate keys to use with RSA (Rivest-Shamir-Adleman) algorithm.

@docs RsaOaepKey, RsaPssKey, RsaSsaPkcs1V1_5Key

@docs RsaKeyParams, RsaKeyGenerationError

@docs generateRsaOaepKeyPair, generateRsaPssKeyPair, generateRsaSsaPkcs1V1_5KeyPair

### Generate AES Keys

@docs AesLength

@docs generateAesCtrKey, generateAesCbcKey, generateAesGcmKey

### Generate ECD Keys

@docs EcNamedCurve

@docs generateEcdsaKeyPair, generateEcdhKeyPair

### Generate HMAC Keys 

@docs HmacKeyParams, HmacKeyGenerationError

@docs generateHmacKey

## Derive Keys

Create keys from other keys.

## Export Keys

Export keys in various formats. Available formats depend on the key being exported.

For more information on exporting keys, check out the [MDN web docs](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)
for the Web Crypto API.

@docs ExportKeyError

### Export RSA Keys

@docs exportRsaOaepPublicKeyAsSpki, exportRsaOaepPublicKeyAsJwk

@docs exportRsaOaepPrivateKeyAsPkcs8, exportRsaOaepPrivateKeyAsJwk

@docs exportRsaPssPublicKeyAsSpki, exportRsaPssPublicKeyAsJwk

@docs exportRsaPssPrivateKeyAsPkcs8, exportRsaPssPrivateKeyAsJwk

@docs exportRsaSsaPkcs1V1_5PublicKeyAsSpki, exportRsaSsaPkcs1V1_5PublicKeyAsJwk

@docs exportRsaSsaPkcs1V1_5PrivateKeyAsPkcs8, exportRsaSsaPkcs1V1_5PrivateKeyAsJwk

### Export AES Keys

@docs exportAesCtrKeyAsRaw, exportAesCtrKeyAsJwk

@docs exportAesCbcKeyAsRaw, exportAesCbcKeyAsJwk

@docs exportAesGcmKeyAsRaw, exportAesGcmKeyAsJwk

### Export EC Keys

@docs exportEcdsaPublicKeyAsRaw, exportEcdsaPublicKeyAsSpki, exportEcdsaPublicKeyAsJwk

@docs exportEcdsaPrivateKeyAsPkcs8, exportEcdsaPrivateKeyAsJwk

@docs exportEcdhPublicKeyAsRaw, exportEcdhPublicKeyAsSpki, exportEcdhPublicKeyAsJwk

@docs exportEcdhPrivateKeyAsPkcs8, exportEcdhPrivateKeyAsJwk

### Export HMAC Keys 

@docs exportHmacKeyAsRaw, exportHmacKeyAsJwk

## Import Keys

Import exported keys.

For more information on exporting keys, check out the [MDN web docs](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey)
for the Web Crypto API.

### Import RSA Keys

@docs ImportRsaKeyError

@docs importRsaOaepPublicKeyFromJwk, importRsaOaepPublicKeyFromSpki

@docs importRsaOaepPrivateKeyFromJwk, importRsaOaepPrivateKeyFromPkcs8

@docs importRsaPssPublicKeyFromJwk, importRsaPssPublicKeyFromSpki

@docs importRsaPssPrivateKeyFromJwk, importRsaPssPrivateKeyFromPkcs8

@docs importRsaSsaPkcs1V1_5PrivateKeyFromJwk, importRsaSsaPkcs1V1_5PrivateKeyFromPkcs8

@docs importRsaSsaPkcs1V1_5PublicKeyFromJwk, importRsaSsaPkcs1V1_5PublicKeyFromSpki

### Import AES Keys

@docs ImportAesKeyError

@docs importAesCbcKeyFromJwk, importAesCbcKeyFromRaw

@docs importAesCtrKeyFromJwk, importAesCtrKeyFromRaw

@docs importAesGcmKeyFromJwk, importAesGcmKeyFromRaw

### Import EC Keys

@docs ImportEcKeyError

@docs importEcdhPrivateKeyFromJwk, importEcdhPrivateKeyFromPkcs8, importEcdhPrivateKeyFromSpki

@docs importEcdhPublicKeyFromJwk, importEcdhPublicKeyFromRaw, importEcdhPublicKeyFromSpki

@docs importEcdsaPrivateKeyFromJwk, importEcdsaPrivateKeyFromPkcs8, importEcdsaPrivateKeyFromSpki

@docs importEcdsaPublicKeyFromJwk, importEcdsaPublicKeyFromRaw, importEcdsaPublicKeyFromSpki

### Import HMAC Keys 

@docs ImportHmacKeyError

@docs importHmacKeyFromJwk, importHmacKeyFromRaw

## Encryption

Encrypt some `Bytes`.

## Decryption

Decrypt some `Bytes`.

## Signing

Sign some `Bytes`.

## Verifying

Verify signed `Bytes`.

## Digest

@docs DigestAlgorithm, digest

# TODO

@docs DecryptWithRsaOaepError

@docs KeyV2

@docs encryptWithRsaOaep, decryptWithRsaOaep
@docs AesCtrParams, AesCtrEncryptError, AesCtrDecryptError
@docs encryptWithAesCtr, decryptWithAesCtr
@docs AesCbcParams, AesCbcEncryptionError, AesCbcDecryptionError
@docs encryptWithAesCbc, decryptWithAesCbc
@docs AesGcmParams, AesGcmTagLength, AesGcmEncryptionError, AesGcmDecryptionError
@docs encryptWithAesGcm, decryptWithAesGcm
@docs signWithRsaSsaPkcs1V1_5, verifyWithRsaSsaPkcs1V1_5
@docs SignWithRsaPssError, signWithRsaPss, verifyWithRsaPss
@docs signWithEcdsa, verifyWithEcdsa
@docs signWithHmac, verifyWithHmac

-}


import Array exposing ( Array )
import Basics exposing ( toFloat, Never, Bool(..), Int, (>), (<), (<=), (>=), (==), (*), (^), (/), (/=), (|>), (&&) )
import Gren.Kernel.Crypto
import String exposing ( String )
import Task exposing ( Task )
import Debug
import Bytes exposing ( Bytes )
import Bytes.Encode
import Maybe exposing ( Maybe(..) )
import Result exposing ( Result(..) )
import Set exposing ( Set )
import Bitwise
import Math
import Json.Encode
import Gren.Kernel.Json


-- RANDOM UUID


{-| Generate a random UUID using the UUID v4 algorithm.
-}
randomUuid : SecureContext -> Task x String
randomUuid _context =
    Gren.Kernel.Crypto.randomUUID


-- RANDOM VALUES


{-| Get a `Array` of random, signed, 8-bit values equal to the length of the passed `Int`
with a maximum of 65536 values.
-}
getRandomInt8Values : Int -> Task x (Array Int)
getRandomInt8Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 65536 int) "int8"


{-| Get a `Array` of random, unsigned, 8-bit values equal to the length of the passed `Int`
with a maximum of 65536 values.
-}
getRandomUInt8Values : Int -> Task x (Array Int)
getRandomUInt8Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 65536 int) "uint8"


{-| Get a `Array` of random, signed, 16-bit values equal to the length of the passed `Int`.
with a maximum of 32768 values.
-}
getRandomInt16Values : Int -> Task x (Array Int)
getRandomInt16Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 32768 int) "int16"


{-| Get a `Array` of random, unsigned, 16-bit values equal to the length of the passed `Int`.
with a maximum of 32768 values.
-}
getRandomUInt16Values : Int -> Task x (Array Int)
getRandomUInt16Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 32768 int) "uint16"


{-| Get a `Array` of random, signed, 32-bit values equal to the length of the passed `Int`
with a maximum of 16384 values.
-}
getRandomInt32Values : Int -> Task x (Array Int)
getRandomInt32Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 16384 int) "int32"


{-| Get a `Array` of random, unsigned, 32-bit values equal to the length of the passed `Int`
with a maximum of 16384 values.
-}
getRandomUInt32Values : Int -> Task x (Array Int)
getRandomUInt32Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 16384 int) "uint32"


-- ENVIRONMENT


{-| Represents the platform being considered secure. This type can be generated 
using the `isSecureContext` function and is required for some functions to be 
run in this package.
-}
type SecureContext
    = SecureContext


{-| A `Task` that succeeds with `SecureContext` if the code is being run in a 
secure context. If this `Task` fails, most of the functions within this module
will not be able to run.

While running this function on the `node` platform, it should always succeed.

While running this function on the `browser` platform, it will succeed if the
application being run is [considered as being in a secure context](https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts).
-}
isSecureContext : Task {} SecureContext
isSecureContext =
    Gren.Kernel.Crypto.getContext


-- KEYS


{-| Denotes if a key can be exported using the `exportKey` or `exportKeyPair`
functions. If a key is not marked as exportable when it is created or imported, 
any attempts to export the key will fail.
-}
type Extractable
    = CanBeExtracted
    | CannotBeExtracted


{-| A generated key. Can only be created by running a key generation function.
-}
type Key algorithm
    = Key 
        { key : algorithm
        , extractable : Bool
        }


{-|-}
type KeyV2 key keyData
    = KeyV2 key keyData


{-| Represents a public key which can only be used for specific actions.
-}
type PublicKey a
    = PublicKey (Key a)


{-|-}
type PublicKeyV2 a b
    = PublicKeyV2 (KeyV2 a b)


{-| Represents a private key which can only be used for specific actions.
-}
type PrivateKey a
    = PrivateKey (Key a)


{-|-}
type PrivateKeyV2 a b
    = PrivateKeyV2 (KeyV2 a b)


{-| A pair of public and private keys.
-}
type alias KeyPair a =
    { publicKey : PublicKey a
    , privateKey : PrivateKey a
    }


{-|-}
type alias KeyPairV2 a b =
    { publicKey : PublicKeyV2 a b
    , privateKey : PrivateKeyV2 a b
    }


-- RSA KEYS


{-| Represents a key generated and for use with the RSA-OAEP algorithm used to 
encrypt and decrypt values.
-}
type RsaOaepKey
    = RsaOaepKey


{-| A key generated for use with the RSA-PSS algorithm. Used to sign and verify 
values.
-}
type RsaPssKey =
    RsaPssKey


{-| A key generated for use with the RSASSA-PKCS1-v1_5 algorithm. Used to sign 
and verify values.
-}
type RsaSsaPkcs1V1_5Key
    = RsaSsaPkcs1V1_5Key


{-| Parameters required to generate a key for uses with the RSA algorithm.

`modulusLength` is clamped be at least 2048 and no greater than 4096. If the
`Int` used is outside of that range, it will be corrected.

The public exponent for RSA keys is always `[ 1, 0, 1 ]` or `65537`. This is
a recommended value and a value that works across the `browser` and `node` platforms.
-}
type alias RsaKeyParams =
    { modulusLength : Int
    , hash : DigestAlgorithm
    , extractable : Extractable
    }


{-| Errors that can happen when generating a key for use with the RSA algorithm.

- `ModulusLengthNotDivisibleByEight` happens when the passed `modulusLength` is
not divisible by 8, as is required by the algorithm.
-}
type RsaKeyGenerationError
    = ModulusLengthNotDivisibleByEight


{-| Generate a new key pair using the RSA-OAEP (Optimal Asymmetric Encryption 
Padding) algorithm.

Produces a `KeyPair` that can be used to encrypt and decrypt data.
-}
generateRsaOaepKeyPair : SecureContext -> RsaKeyParams -> Task RsaKeyGenerationError (KeyPairV2 RsaOaepKey RsaKeyParams)
generateRsaOaepKeyPair _context =
    generateRsaKeyHelper 
        "RSA-OAEP" 
        [ "encrypt", "decrypt" ]


{-| Generate a new key using the RSA-PSS algorithm.

Produces a `KeyPair` that can be used to sign and verify data.
-}
generateRsaPssKeyPair : SecureContext -> RsaKeyParams -> Task RsaKeyGenerationError (KeyPairV2 RsaPssKey RsaKeyParams)
generateRsaPssKeyPair _context =
    generateRsaKeyHelper 
        "RSA-PSS"
        [ "sign", "verify" ]


{-| Generate a new key using the RSASSA-PKCS1-v1_5 algorithm.

Produces a `KeyPair` that can be used to sign and verify data.
-}
generateRsaSsaPkcs1V1_5KeyPair : SecureContext -> RsaKeyParams -> Task RsaKeyGenerationError (KeyPairV2 RsaSsaPkcs1V1_5Key RsaKeyParams)
generateRsaSsaPkcs1V1_5KeyPair _context =
    generateRsaKeyHelper 
        "RSASSA-PKCS1-v1_5"
        [ "sign", "verify" ]


{-|-}
generateRsaKeyHelper : String -> Array String -> RsaKeyParams -> Task RsaKeyGenerationError a
generateRsaKeyHelper name permissions { modulusLength, hash, extractable } =
    let
        clampedModulusLength = 
            clamp 2048 4096 modulusLength
    in
    if Math.remainderBy 8 clampedModulusLength == 0 then
        Gren.Kernel.Crypto.generateRsaKey 
            name
            clampedModulusLength
            [ 1, 0, 1 ] -- Public exponent
            (digestAlgorithmToString hash)
            (extractableToBool extractable)
            permissions
    else
        Task.fail ModulusLengthNotDivisibleByEight


-- AES KEYS


{-| Represents a key generated and for use with the AES-CTR algorithm used to
encrypt and decrypt values.
-}
type AesCtrKey
    = AesCtrKey


{-| Represents a key generated and for use with the AES-CBC algorithm used to
encrypt and decrypt values.
-}
type AesCbcKey
    = AesCbcKey


{-| Represents a key generated and for use with the AES-GCM algorithm used to
encrypt and decrypt values.
-}
type AesGcmKey
    = AesGcmKey


{-| The length of bits of the key that is being generated using the AES 
algorithm. These are the only values that can be chosen.

The Web Crypto API supports a length of 192, but some browsers do not implement
this. To keep compatability across browser, the option is not provided.
-}
type AesLength
    = AesLength128
    -- | AesLength192
    | AesLength256


{-| Generate a new key using the AES-CTR algorithm.
-}
generateAesCtrKey : SecureContext -> AesLength -> Extractable -> Task {} (Key AesCtrKey)
generateAesCtrKey _context length extractable =
    Gren.Kernel.Crypto.generateAesKey
        "AES-CTR"
        (aesLengthToInt length)
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-| Generate a new key using the AES-CTR algorithm.
-}
generateAesCbcKey : SecureContext -> AesLength -> Extractable -> Task {} (Key AesCbcKey)
generateAesCbcKey _context length extractable =
    Gren.Kernel.Crypto.generateAesKey
        "AES-CBC"
        (aesLengthToInt length)
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-| Generate a new key using the AES-GCM algorithm.
-}
generateAesGcmKey : SecureContext -> AesLength -> Extractable -> Task {} (Key AesGcmKey)
generateAesGcmKey _context length extractable =
    Gren.Kernel.Crypto.generateAesKey
        "AES-GCM"
        (aesLengthToInt length)
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


-- ECD KEYS


{-| Represents a key generated and for use with the ECDSA algorithm used to
sign and verify values.
-}
type EcdsaKey
    = EcdsaKey


{-| Represents a key generated and for use with the ECDH algorithm used to
derive keys and bits.
-}
type EcdhKey
    = EcdhKey


{-| The name of the elliptic curve to use for the generated key.
-}
type EcNamedCurve
    = P256
    | P384
    | P521


{-| Generate a new key using the ECDSA algorithm.
-}
generateEcdsaKeyPair : SecureContext -> EcNamedCurve -> Extractable -> Task x (KeyPair EcdsaKey)
generateEcdsaKeyPair _context namedCurve extractable =
    Gren.Kernel.Crypto.generateEcKey
        "ECDSA"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        [ "sign", "verify" ]


{-| Generate a new key using the ECDH algorithm.
-}
generateEcdhKeyPair : SecureContext -> EcNamedCurve -> Extractable -> Task x (KeyPair EcdhKey)
generateEcdhKeyPair _context namedCurve extractable =
    Gren.Kernel.Crypto.generateEcKey
        "ECDH"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        [ "deriveKey", "deriveBits" ]


-- HMAC KEYS


{-| Represents a key generated and for use with the HMAC algorithm used to
sign and verify values.
-}
type HmacKey =
    HmacKey


{-| Errors that can happen when generating a key for use with the RSA algorithm.

- `ModulusLengthNotDivisibleByEight` happens when the passed `modulusLength` is
not divisible by 8, as is required by the algorithm.
-}
type HmacKeyGenerationError
    = LengthNotDivisibleByEight


{-| Parameters required to generate a key for uses with the HMAC algorithm.

The passed `length` will be the length of the resulting key in bits. If
`Nothing`, the key will be equal in bits to the passed `DigestAlgorithm`. 
It's recommended to pass `Nothing` and let the length of the key be equal 
to the hash function (`DigestAlgorithm`).

If passed, the `length` is clamped be at least 8 and no greater than 2048. 
If the `Int` used is outside of that range, it will be corrected.
-}
type alias HmacKeyParams =
    { length : Maybe Int
    , hash : DigestAlgorithm
    , extractable : Extractable
    }


{-| Generate a new key using the HMAC algorithm.
-}
generateHmacKey : SecureContext -> HmacKeyParams -> Task HmacKeyGenerationError (KeyV2 HmacKey HmacKeyParams)
generateHmacKey _context { hash, length, extractable } =
    case length of
        Just passedLength ->
            let
                clampedLength =
                    clamp 8 2048 passedLength
            in
            if Math.remainderBy 8 clampedLength == 0 then
                Gren.Kernel.Crypto.generateHmacKey
                    "HMAC"
                    (digestAlgorithmToString hash)
                    clampedLength
                    (extractableToBool extractable)
                    [ "sign", "verify" ]
            
            else
                Task.fail LengthNotDivisibleByEight

        Nothing ->
            Gren.Kernel.Crypto.generateHmacKey
                "HMAC"
                (digestAlgorithmToString hash)
                ""
                (extractableToBool extractable)
                [ "sign", "verify" ]



-- EXPORT KEYS


{-| Errors that can arise when exporting keys.

- `NotExportable` happens when trying to export a key that was not made
`Extractable` during creation or import.
-}
type ExportKeyError
    = KeyNotExportable


{-| Export a `RsaOaepKey` as a [SubjectPublicKeyInfo](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#subjectpublickeyinfo).

The result `Bytes` can be imported again using the `importRsaOaepPublicKey` function.
-}
exportRsaOaepPublicKeyAsSpki : SecureContext -> PublicKeyV2 RsaOaepKey RsaKeyParams -> Task ExportKeyError Bytes
exportRsaOaepPublicKeyAsSpki _context (PublicKeyV2 key) =
    exportKeyAsSpkiV2 key


{-| Export a `RsaOaepKey` as a [JSON Web Key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#json_web_key).

The resulting `Json.Encode.Value` can be imported again using the `importRsaOaepPublicKey` function.
-}
exportRsaOaepPublicKeyAsJwk : SecureContext -> PublicKeyV2 RsaOaepKey RsaKeyParams -> Task ExportKeyError Json.Encode.Value
exportRsaOaepPublicKeyAsJwk _context (PublicKeyV2 key) =
    exportKeyAsJwkV2 key


{-| Export a `RsaOaepKey` as [PKCS #8](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#pkcs_8)
-}
exportRsaOaepPrivateKeyAsPkcs8 : SecureContext -> PrivateKeyV2 RsaOaepKey RsaKeyParams -> Task ExportKeyError Bytes
exportRsaOaepPrivateKeyAsPkcs8 _context (PrivateKeyV2 key) =
    exportKeyAsPkcs8V2 key


{-| Export a private `RsaOaepKey` as a [JSON Web Key]() 
-}
exportRsaOaepPrivateKeyAsJwk : SecureContext -> PrivateKeyV2 RsaOaepKey RsaKeyParams -> Task ExportKeyError Json.Encode.Value
exportRsaOaepPrivateKeyAsJwk _context (PrivateKeyV2 key) =
    exportKeyAsJwkV2 key


{-|-}
exportRsaPssPublicKeyAsSpki : SecureContext -> PublicKeyV2 RsaPssKey RsaKeyParams -> Task ExportKeyError Bytes
exportRsaPssPublicKeyAsSpki _context (PublicKeyV2 key)=
    exportKeyAsSpkiV2 key


{-|-}
exportRsaPssPublicKeyAsJwk : SecureContext -> PublicKeyV2 RsaPssKey RsaKeyParams -> Task ExportKeyError Json.Encode.Value
exportRsaPssPublicKeyAsJwk _context (PublicKeyV2 key) =
    exportKeyAsJwkV2 key


{-|-}
exportRsaPssPrivateKeyAsPkcs8 : SecureContext -> PrivateKeyV2 RsaPssKey RsaKeyParams-> Task ExportKeyError Bytes
exportRsaPssPrivateKeyAsPkcs8 _context (PrivateKeyV2 key) =
    exportKeyAsPkcs8V2 key


{-|-}
exportRsaPssPrivateKeyAsJwk : SecureContext -> PrivateKeyV2 RsaPssKey RsaKeyParams -> Task ExportKeyError Json.Encode.Value
exportRsaPssPrivateKeyAsJwk _context (PrivateKeyV2 key) =
    exportKeyAsJwkV2 key


{-|-}
exportRsaSsaPkcs1V1_5PublicKeyAsSpki : SecureContext -> PublicKeyV2 RsaSsaPkcs1V1_5Key RsaKeyParams -> Task ExportKeyError Bytes
exportRsaSsaPkcs1V1_5PublicKeyAsSpki _context (PublicKeyV2 key) =
    exportKeyAsSpkiV2 key


{-|-}
exportRsaSsaPkcs1V1_5PublicKeyAsJwk : SecureContext -> PublicKeyV2 RsaSsaPkcs1V1_5Key RsaKeyParams -> Task ExportKeyError Json.Encode.Value
exportRsaSsaPkcs1V1_5PublicKeyAsJwk _context (PublicKeyV2 key) =
    exportKeyAsJwkV2 key


{-|-}
exportRsaSsaPkcs1V1_5PrivateKeyAsPkcs8 : SecureContext -> PrivateKeyV2 RsaSsaPkcs1V1_5Key RsaKeyParams -> Task ExportKeyError Bytes
exportRsaSsaPkcs1V1_5PrivateKeyAsPkcs8 _context (PrivateKeyV2 key)=
    exportKeyAsPkcs8V2 key


{-|-}
exportRsaSsaPkcs1V1_5PrivateKeyAsJwk : SecureContext -> PrivateKeyV2 RsaSsaPkcs1V1_5Key RsaKeyParams -> Task ExportKeyError Json.Encode.Value
exportRsaSsaPkcs1V1_5PrivateKeyAsJwk _context (PrivateKeyV2 key) =
    exportKeyAsJwkV2 key


{-|-}
exportAesCtrKeyAsRaw : SecureContext -> Key AesCtrKey -> Task ExportKeyError Bytes
exportAesCtrKeyAsRaw _context =
    exportKeyAsRaw


{-|-}
exportAesCtrKeyAsJwk : SecureContext -> Key AesCtrKey -> Task ExportKeyError Json.Encode.Value
exportAesCtrKeyAsJwk _context =
    exportKeyAsJwk


{-|-}
exportAesCbcKeyAsRaw : SecureContext -> Key AesCbcKey -> Task ExportKeyError Bytes
exportAesCbcKeyAsRaw _context =
    exportKeyAsRaw


{-|-}
exportAesCbcKeyAsJwk : SecureContext -> Key AesCbcKey -> Task ExportKeyError Json.Encode.Value
exportAesCbcKeyAsJwk _context =
    exportKeyAsJwk


{-|-}
exportAesGcmKeyAsRaw : SecureContext -> Key AesGcmKey -> Task ExportKeyError Bytes
exportAesGcmKeyAsRaw _context =
    exportKeyAsRaw


{-|-}
exportAesGcmKeyAsJwk : SecureContext -> Key AesGcmKey -> Task ExportKeyError Json.Encode.Value
exportAesGcmKeyAsJwk _context =
    exportKeyAsJwk


{-|-}
exportEcdsaPublicKeyAsRaw : SecureContext -> PublicKey EcdsaKey -> Task ExportKeyError Bytes
exportEcdsaPublicKeyAsRaw _context (PublicKey key) =
    exportKeyAsRaw key


{-|-}
exportEcdsaPublicKeyAsSpki : SecureContext -> PublicKey EcdsaKey -> Task ExportKeyError Bytes
exportEcdsaPublicKeyAsSpki _context (PublicKey key) =
    exportKeyAsSpki key


{-|-}
exportEcdsaPublicKeyAsJwk : SecureContext -> PublicKey EcdsaKey -> Task ExportKeyError Json.Encode.Value
exportEcdsaPublicKeyAsJwk _context (PublicKey key) =
    exportKeyAsJwk key


{-|-}
exportEcdsaPrivateKeyAsPkcs8 : SecureContext -> PrivateKey EcdsaKey -> Task ExportKeyError Bytes
exportEcdsaPrivateKeyAsPkcs8 _context (PrivateKey key) =
    exportKeyAsPkcs8 key


{-|-}
exportEcdsaPrivateKeyAsJwk : SecureContext -> PrivateKey EcdsaKey -> Task ExportKeyError Json.Encode.Value
exportEcdsaPrivateKeyAsJwk _context (PrivateKey key)=
    exportKeyAsJwk key


{-|-}
exportEcdhPublicKeyAsRaw : SecureContext -> PublicKey EcdhKey -> Task ExportKeyError Bytes
exportEcdhPublicKeyAsRaw _context (PublicKey key) =
    exportKeyAsRaw key


{-|-}
exportEcdhPublicKeyAsSpki : SecureContext -> PublicKey EcdhKey -> Task ExportKeyError Bytes
exportEcdhPublicKeyAsSpki _context (PublicKey key) =
    exportKeyAsSpki key


{-|-}
exportEcdhPublicKeyAsJwk : SecureContext -> PublicKey EcdhKey -> Task ExportKeyError Json.Encode.Value
exportEcdhPublicKeyAsJwk _context (PublicKey key) =
    exportKeyAsJwk key


{-|-}
exportEcdhPrivateKeyAsPkcs8 : SecureContext -> PrivateKey EcdhKey -> Task ExportKeyError Bytes
exportEcdhPrivateKeyAsPkcs8 _context (PrivateKey key) =
    exportKeyAsPkcs8 key


{-|-}
exportEcdhPrivateKeyAsJwk : SecureContext -> PrivateKey EcdhKey -> Task ExportKeyError Json.Encode.Value
exportEcdhPrivateKeyAsJwk _context (PrivateKey key) =
    exportKeyAsJwk key


{-|-}
exportHmacKeyAsRaw : SecureContext -> KeyV2 HmacKey HmacKeyParams -> Task ExportKeyError Bytes
exportHmacKeyAsRaw _context =
    exportKeyAsRawV2


{-|-}
exportHmacKeyAsJwk : SecureContext -> KeyV2 HmacKey HmacKeyParams -> Task ExportKeyError Json.Encode.Value
exportHmacKeyAsJwk _context =
    exportKeyAsJwkV2


{-|-}
exportKeyHelper : String -> Key a -> Task ExportKeyError b
exportKeyHelper keyType (Key { extractable, key }) =
    if extractable then
        Gren.Kernel.Crypto.exportKey keyType key

    else
        Task.fail KeyNotExportable


{-|-}
exportKeyHelperV2 : String -> KeyV2 a b -> Task ExportKeyError c
exportKeyHelperV2 keyType (KeyV2 key _) =
    Gren.Kernel.Crypto.exportKey keyType key


{-|-}
exportKeyAsRawV2 : KeyV2 a b -> Task ExportKeyError Bytes
exportKeyAsRawV2 =
    exportKeyHelperV2 "raw"


{-|-}
exportKeyAsRaw : Key a -> Task ExportKeyError Bytes
exportKeyAsRaw =
    exportKeyHelper "raw"


{-|-}
exportKeyAsPkcs8 : Key a -> Task ExportKeyError Bytes
exportKeyAsPkcs8 =
    exportKeyHelper "pkcs8"


{-|-}
exportKeyAsPkcs8V2 : KeyV2 a b -> Task ExportKeyError Bytes
exportKeyAsPkcs8V2 =
    exportKeyHelperV2 "pkcs8"


{-|-}
exportKeyAsSpki : Key a -> Task ExportKeyError Bytes
exportKeyAsSpki =
    exportKeyHelper "spki"


{-|-}
exportKeyAsSpkiV2 : KeyV2 a b -> Task ExportKeyError Bytes
exportKeyAsSpkiV2 =
    exportKeyHelperV2 "spki"


{-|-}
exportKeyAsJwk : Key a -> Task ExportKeyError Json.Encode.Value
exportKeyAsJwk key =
    Task.map Gren.Kernel.Json.wrap (exportKeyHelper "jwk" key)


{-|-}
exportKeyAsJwkV2 : KeyV2 a b -> Task ExportKeyError Json.Encode.Value
exportKeyAsJwkV2 key =
    Task.map Gren.Kernel.Json.wrap (exportKeyHelperV2 "jwk" key)


-- IMPORT KEYS


{-| Parameters required for importing a key using an RSA algorithm.
-}
type alias ImportRsaKeyParams =
    { hash : DigestAlgorithm
    }


{-| Appears if there's an error when importing a key using an RSA algorithm.

There are two possible reasons this error happens:

1. The passed key value (either `Json.Encode.Value` or `Bytes`) is not 
a valid key and cannot be imported.
2. The `hash` passed to the function does not match the `hash` of the imported key. This only 
happens when importing a JSON Web Key. It is recommended to _always_ match the hash of the 
imported key or you will get different results when using the imported key.
-}
type ImportRsaKeyError
    = ImportRsaKeyError


{-|-}
importRsaOaepPublicKeyFromJwk : SecureContext -> Json.Encode.Value -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PublicKeyV2 RsaOaepKey RsaKeyParams)
importRsaOaepPublicKeyFromJwk _context jwk { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "public"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "RSA-OAEP"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "encrypt" ]


{-|-}
importRsaOaepPublicKeyFromSpki : SecureContext -> Bytes -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PublicKeyV2 RsaOaepKey RsaKeyParams)
importRsaOaepPublicKeyFromSpki _context bytes { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "public"
        "spki"
        bytes
        "RSA-OAEP"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "encrypt" ]


{-|-}
importRsaPssPublicKeyFromJwk : SecureContext -> Json.Encode.Value -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PublicKeyV2 RsaPssKey RsaKeyParams)
importRsaPssPublicKeyFromJwk _context jwk { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "public"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "RSA-PSS"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "verify" ]


{-|-}
importRsaPssPublicKeyFromSpki : SecureContext -> Bytes -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PublicKeyV2 RsaPssKey RsaKeyParams)
importRsaPssPublicKeyFromSpki _context bytes { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "public"
        "spki"
        bytes
        "RSA-PSS"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "verify" ]


{-|-}
importRsaOaepPrivateKeyFromJwk : SecureContext -> Json.Encode.Value -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PrivateKeyV2 RsaOaepKey RsaKeyParams)
importRsaOaepPrivateKeyFromJwk _context jwk { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "private"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "RSA-OAEP"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "decrypt" ]


{-|-}
importRsaOaepPrivateKeyFromPkcs8 : SecureContext -> Bytes -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PrivateKeyV2 RsaOaepKey RsaKeyParams)
importRsaOaepPrivateKeyFromPkcs8 _context bytes { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "private"
        "pkcs8"
        bytes
        "RSA-OAEP"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "decrypt" ]


{-|-}
importRsaPssPrivateKeyFromJwk : SecureContext -> Json.Encode.Value -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PrivateKeyV2 RsaPssKey RsaKeyParams)
importRsaPssPrivateKeyFromJwk _context jwk { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "private"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "RSA-PSS"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "sign" ]


{-|-}
importRsaPssPrivateKeyFromPkcs8 : SecureContext -> Bytes -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PrivateKeyV2 RsaPssKey RsaKeyParams)
importRsaPssPrivateKeyFromPkcs8 _context bytes { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "private"
        "pkcs8"
        bytes
        "RSA-PSS"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "sign" ]


{-|-}
importRsaSsaPkcs1V1_5PublicKeyFromJwk : SecureContext -> Json.Encode.Value -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PrivateKeyV2 RsaSsaPkcs1V1_5Key RsaKeyParams)
importRsaSsaPkcs1V1_5PublicKeyFromJwk _context jwk { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "public"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "RSASSA-PKCS1-v1_5"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "sign" ]


{-|-}
importRsaSsaPkcs1V1_5PublicKeyFromSpki : SecureContext -> Bytes -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PrivateKeyV2 RsaSsaPkcs1V1_5Key RsaKeyParams)
importRsaSsaPkcs1V1_5PublicKeyFromSpki _context bytes { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "public"
        "spki"
        bytes
        "RSASSA-PKCS1-v1_5"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "verify" ]


{-|-}
importRsaSsaPkcs1V1_5PrivateKeyFromJwk : SecureContext -> Json.Encode.Value -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PrivateKeyV2 RsaSsaPkcs1V1_5Key RsaKeyParams)
importRsaSsaPkcs1V1_5PrivateKeyFromJwk _context jwk { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "private"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "RSASSA-PKCS1-v1_5"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "sign" ]


{-|-}
importRsaSsaPkcs1V1_5PrivateKeyFromPkcs8 : SecureContext -> Bytes -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PrivateKeyV2 RsaSsaPkcs1V1_5Key RsaKeyParams)
importRsaSsaPkcs1V1_5PrivateKeyFromPkcs8 _context bytes { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "private"
        "pkcs8"
        bytes
        "RSASSA-PKCS1-v1_5"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "sign" ]


{-|-}
type ImportAesKeyError
    = ImportAesKeyError


{-|-}
importAesCtrKeyFromRaw : SecureContext -> Bytes -> Extractable -> Task ImportAesKeyError (Key AesCtrKey)
importAesCtrKeyFromRaw _context bytes extractable =
    Gren.Kernel.Crypto.importAesKey
        "raw"
        bytes
        "AES-CTR"
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-|-}
importAesCtrKeyFromJwk : SecureContext -> Json.Encode.Value -> Extractable -> Task ImportAesKeyError (Key AesCtrKey)
importAesCtrKeyFromJwk _context jwk extractable =
    Gren.Kernel.Crypto.importAesKey
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "AES-CTR"
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-|-}
importAesCbcKeyFromRaw : SecureContext -> Bytes -> Extractable -> Task ImportAesKeyError (Key AesCtrKey)
importAesCbcKeyFromRaw _context bytes extractable =
    Gren.Kernel.Crypto.importAesKey
        "raw"
        bytes
        "AES-CBC"
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-|-}
importAesCbcKeyFromJwk : SecureContext -> Json.Encode.Value -> Extractable -> Task ImportAesKeyError (Key AesCtrKey)
importAesCbcKeyFromJwk _context jwk extractable =
    Gren.Kernel.Crypto.importAesKey
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "AES-CBC"
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-|-}
importAesGcmKeyFromRaw : SecureContext -> Bytes -> Extractable -> Task ImportAesKeyError (Key AesCtrKey)
importAesGcmKeyFromRaw _context bytes extractable =
    Gren.Kernel.Crypto.importAesKey
        "raw"
        bytes
        "AES-GCM"
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-|-}
importAesGcmKeyFromJwk : SecureContext -> Json.Encode.Value -> Extractable -> Task ImportAesKeyError (Key AesCtrKey)
importAesGcmKeyFromJwk _context jwk extractable =
    Gren.Kernel.Crypto.importAesKey
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "AES-GCM"
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-| Appears if there's an error when importing a key using an EC (ellipical-curve)
algorithm.

There are two possible reasons this error happens:

1. The passed key value (either `Json.Encode.Value` or `Bytes`) is not a valid key 
and cannot be imported.
2. The `EcNamedCurve` passed to the function does not match the `EcNamedCurve` of 
the imported key.
-}
type ImportEcKeyError
    = ImportEcKeyError


{-|-}
importEcdsaPublicKeyFromRaw : SecureContext -> EcNamedCurve -> Bytes -> Extractable -> Task ImportEcKeyError (PublicKey EcdsaKey)
importEcdsaPublicKeyFromRaw _context namedCurve bytes extractable =
    Gren.Kernel.Crypto.importEcKey
        "public"
        "raw"
        bytes
        "ECDSA"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        [ "verify" ]


{-|-}
importEcdsaPublicKeyFromSpki : SecureContext -> EcNamedCurve -> Bytes -> Extractable -> Task ImportEcKeyError (PublicKey EcdsaKey)
importEcdsaPublicKeyFromSpki _context namedCurve bytes extractable =
    Gren.Kernel.Crypto.importEcKey
        "public"
        "spki"
        bytes
        "ECDSA"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        [ "verify" ]


{-|-}
importEcdsaPublicKeyFromJwk : SecureContext -> EcNamedCurve -> Json.Encode.Value -> Extractable -> Task ImportEcKeyError (PublicKey EcdsaKey)
importEcdsaPublicKeyFromJwk _context namedCurve jwk extractable =
    Gren.Kernel.Crypto.importEcKey
        "public"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "ECDSA"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        [ "verify" ]


{-|-}
importEcdhPublicKeyFromRaw : SecureContext -> EcNamedCurve -> Bytes -> Extractable -> Task ImportEcKeyError (PublicKey EcdhKey)
importEcdhPublicKeyFromRaw _context namedCurve bytes extractable =
    Gren.Kernel.Crypto.importEcKey
        "public"
        "raw"
        bytes
        "ECDH"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        []


{-|-}
importEcdhPublicKeyFromSpki : SecureContext -> EcNamedCurve -> Bytes -> Extractable -> Task ImportEcKeyError (PublicKey EcdhKey)
importEcdhPublicKeyFromSpki _context namedCurve bytes extractable =
    Gren.Kernel.Crypto.importEcKey
        "public"
        "spki"
        bytes
        "ECDH"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        []


{-|-}
importEcdhPublicKeyFromJwk : SecureContext -> EcNamedCurve -> Json.Encode.Value -> Extractable -> Task ImportEcKeyError (PublicKey EcdhKey)
importEcdhPublicKeyFromJwk _context namedCurve jwk extractable =
    Gren.Kernel.Crypto.importEcKey
        "public"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "ECDH"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        []


{-|-}
importEcdsaPrivateKeyFromPkcs8 : SecureContext -> EcNamedCurve -> Bytes -> Extractable -> Task ImportEcKeyError (PrivateKey EcdsaKey)
importEcdsaPrivateKeyFromPkcs8 _context namedCurve bytes extractable =
    Gren.Kernel.Crypto.importEcKey
        "private"
        "pkcs8"
        bytes
        "ECDSA"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        [ "sign" ]


{-|-}
importEcdsaPrivateKeyFromSpki : SecureContext -> EcNamedCurve -> Bytes -> Extractable -> Task ImportEcKeyError (PrivateKey EcdsaKey)
importEcdsaPrivateKeyFromSpki _context namedCurve bytes extractable =
    Gren.Kernel.Crypto.importEcKey
        "private"
        "spki"
        bytes
        "ECDSA"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        [ "sign" ]


{-|-}
importEcdsaPrivateKeyFromJwk : SecureContext -> EcNamedCurve -> Json.Encode.Value -> Extractable -> Task ImportEcKeyError (PrivateKey EcdsaKey)
importEcdsaPrivateKeyFromJwk _context namedCurve jwk extractable =
    Gren.Kernel.Crypto.importEcKey
        "private"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "ECDSA"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        [ "sign" ]


{-|-}
importEcdhPrivateKeyFromPkcs8 : SecureContext -> EcNamedCurve -> Bytes -> Extractable -> Task ImportEcKeyError (PrivateKey EcdhKey)
importEcdhPrivateKeyFromPkcs8 _context namedCurve bytes extractable =
    Gren.Kernel.Crypto.importEcKey
        "private"
        "pkcs8"
        bytes
        "ECDH"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        [ "deriveKey", "deriveBits" ]


{-|-}
importEcdhPrivateKeyFromSpki : SecureContext -> EcNamedCurve -> Bytes -> Extractable -> Task ImportEcKeyError (PrivateKey EcdhKey)
importEcdhPrivateKeyFromSpki _context namedCurve bytes extractable =
    Gren.Kernel.Crypto.importEcKey
        "private"
        "spki"
        bytes
        "ECDH"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        [ "deriveKey", "deriveBits" ]


{-|-}
importEcdhPrivateKeyFromJwk : SecureContext -> EcNamedCurve -> Json.Encode.Value -> Extractable -> Task ImportEcKeyError (PrivateKey EcdhKey)
importEcdhPrivateKeyFromJwk  _context namedCurve jwk extractable =
    Gren.Kernel.Crypto.importEcKey
        "private"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "ECDH"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        [ "deriveKey", "deriveBits" ]


{-| Appears if there's an error when importing a key using the HMAC algorithm.

There are not specific error types for importing HMAC keys due to inconsistencies
in how errors are thrown across `browser` and `node` platforms.

There are three known reasons an error can happen when importing HMAC keys:

1. The passed key value (either `Json.Encode.Value` or `Bytes`) is not a valid key 
and cannot be imported.
1. The `length` passed to the function is not correct for the imported key. The
appearance of this error is inconsistent across `browser` and `node` platforms. It's
recommended to avoid passing a `length` and instead use `Nothing` for both HMAC key
generation and importing.
2. The `hash` passed to the function does not match the `hash` of the imported key.
This only happens when importing a JSON Web Key. It is recommended to _always_ match 
the hash of the imported key or you will get different results when using the imported 
key for cryptographic functions.
-}
type ImportHmacKeyError
    = ImportHmacKeyError


{-|-}
importHmacKeyFromJwk : SecureContext -> Json.Encode.Value -> DigestAlgorithm -> Maybe Int -> Extractable -> Task ImportHmacKeyError (KeyV2 HmacKey HmacKeyParams)
importHmacKeyFromJwk _context jwk hash passedLength extractable =
    case passedLength of
        Just length ->
            Gren.Kernel.Crypto.importHmacKey
                "jwk"
                (Gren.Kernel.Json.unwrap jwk)
                "HMAC"
                (digestAlgorithmToString hash)
                length
                (extractableToBool extractable)
                [ "sign", "verify" ]

        Nothing ->
            Gren.Kernel.Crypto.importHmacKey
                "jwk"
                (Gren.Kernel.Json.unwrap jwk)
                "HMAC"
                (digestAlgorithmToString hash)
                ""
                (extractableToBool extractable)
                [ "sign", "verify" ]


{-|-}
importHmacKeyFromRaw : SecureContext -> Bytes -> DigestAlgorithm -> Maybe Int -> Extractable -> Task ImportHmacKeyError (KeyV2 HmacKey HmacKeyParams)
importHmacKeyFromRaw _context bytes hash passedLength extractable =
    case passedLength of
        Just length ->
            Gren.Kernel.Crypto.importHmacKey
                "raw"
                bytes
                 "HMAC"
                (digestAlgorithmToString hash)
                length
                (extractableToBool extractable)
                [ "sign", "verify" ]

        Nothing ->
            Gren.Kernel.Crypto.importHmacKey
                "raw"
                bytes
                "HMAC"
                (digestAlgorithmToString hash)
                ""
                (extractableToBool extractable)
                [ "sign", "verify" ]



-- DERIVE KEYS


{-|-}
type alias HkdfParams =
    { hash : DigestAlgorithm
    , salt : Bytes
    , info : Bytes
    }


{-|-}
type alias Pbkdf2Params =
    { hash : DigestAlgorithm
    , salt : Bytes
    , itterations : Int
    }


{-| Errors that can happen when deriving an HMAC key.
-}
type DeriveHmacKeyError
    = DeriveHmacKeyUnknownError
    | DeriveHmacKeyLengthNotDivisibleByEight


{-| Derive an HMAC key using the ECDH algorithm.

This function can procduce errors if:

1. The curve of the passed `PublicKey EcdhKey` and `PrivateKey EcdhKey` do not match
3. The passed `length` of `HmacKeyParams`, if not `Nothing`, is not divisible by eight
4. The passed `hash` of `HmacKeyParams`, if `length` is not provided, if not equal 
to or greater than the curves of the `PublicKey EcdhKey` and `PrivateKey EcdhKey`.
-}
deriveHmacKeyUsingEcdh : HmacKeyParams -> PublicKey EcdhKey -> PrivateKey EcdhKey -> Task DeriveHmacKeyError (Key HmacKey)
deriveHmacKeyUsingEcdh { hash, length, extractable } (PublicKey (Key publicKey)) (PrivateKey (Key privateKey)) =
    case length of
        Just val ->
            let
                clampedLength =
                    clamp 8 2048 val
            in
            if Math.remainderBy 8 clampedLength == 0 then
                Gren.Kernel.Crypto.deriveHmacKeyUsingEcdh
                    publicKey.key
                    privateKey.key
                    (digestAlgorithmToString hash)
                    clampedLength
                    (extractableToBool extractable)
                    [ "sign", "verify" ]
            
            else
                Task.fail DeriveHmacKeyLengthNotDivisibleByEight

        Nothing ->
            Gren.Kernel.Crypto.deriveHmacKeyUsingEcdh
                publicKey.key
                privateKey.key
                (digestAlgorithmToString hash)
                ""
                (extractableToBool extractable)
                [ "sign", "verify" ]


{-|-}
deriveHmacKeyUsingHkdf : HmacKeyParams -> Key a -> HkdfParams -> Extractable -> Task DeriveHmacKeyError (Key HmacKey)
deriveHmacKeyUsingHkdf { hash, length } (Key key) hkdfParams extractable =
    Debug.todo ""


{-|-}
deriveHmacKeyUsingPbkdf2 : HmacKeyParams -> Key a -> Pbkdf2Params -> Extractable -> Task DeriveHmacKeyError (Key HmacKey)
deriveHmacKeyUsingPbkdf2 { hash, length } (Key key) pbkdb2Params extractable =
    Debug.todo ""


-- ENCRYPT


{-| Encrypt some values with a `PublicKey RsaOaepKey`. The optional `label` parameter is ...

This operation should always succeed.
-}
encryptWithRsaOaep : SecureContext -> Maybe Bytes -> PublicKeyV2 RsaOaepKey RsaKeyParams -> Bytes -> Task {} Bytes
encryptWithRsaOaep _context passedLabel (PublicKeyV2 (KeyV2 key _)) bytes =
    case passedLabel of
        Nothing ->
            Gren.Kernel.Crypto.encryptWithRsaOaep
                ""
                key
                bytes
        
        Just label ->
            Gren.Kernel.Crypto.encryptWithRsaOaep
                label
                key
                bytes


{-|-}
type AesCtrEncryptError =
    AesCtrEncryptError


{-| Required paramaters (along with a key) to encrypy and decrypt values with 
the AES-CTR algorithm.

`length` must be between 1 and 128 (it's clamped)
`counter` must be exactly 16 bytes
-}
type alias AesCtrParams =
    { counter : Bytes
    , length : Int
    }


{-| Encrypt some values using a AES-CTR key.
-}
encryptWithAesCtr : SecureContext -> AesCtrParams -> Key AesCtrKey -> Bytes -> Task AesCtrEncryptError Bytes
encryptWithAesCtr _context { counter, length } (Key { key }) bytes =
    -- The counter must be exactly 16 bytes long
    if Bytes.width counter == 16 then
        Gren.Kernel.Crypto.encryptWithAesCtr
            counter
            (clamp 1 128 length)
            key
            bytes

    else
        Task.fail AesCtrEncryptError


{-|-}
type AesCbcEncryptionError =
    AesCbcEncryptionError


{-|-}
type alias AesCbcParams =
    { iv : Bytes
    }


{-|-}
encryptWithAesCbc : SecureContext -> AesCbcParams -> Key AesCbcKey -> Bytes -> Task AesCbcEncryptionError Bytes
encryptWithAesCbc _context { iv } (Key { key }) bytes =
    if Bytes.width iv == 16 then
        Gren.Kernel.Crypto.encryptWithAesCbc
            iv
            key
            bytes

    else
        Task.fail AesCbcEncryptionError


{-| The set of allowed tag lengths for the AES-GCM algorithm.
-}
type AesGcmTagLength
    = AesGcmTagLength96
    | AesGcmTagLength104
    | AesGcmTagLength112
    | AesGcmTagLength120
    | AesGcmTagLength128


{-|-}
type alias AesGcmParams =
    { iv : Bytes
    , additionalData : Maybe Bytes
    , tagLength : Maybe AesGcmTagLength
    }


{-|-}
type AesGcmEncryptionError =
    AesGcmEncryptionError


{-|-}
encryptWithAesGcm : SecureContext -> AesGcmParams -> Key AesGcmKey -> Bytes -> Task AesGcmEncryptionError Bytes
encryptWithAesGcm _context { iv, additionalData, tagLength } (Key { key }) bytes =
    let
        byteWidth =
            Bytes.width iv
    in
    if byteWidth <= 128 && byteWidth >= 12 then
        case { ad = additionalData, tl = tagLength } of
            { ad = Nothing, tl = Nothing } ->
                Gren.Kernel.Crypto.encryptWithAesGcm
                    iv
                    ""
                    ""
                    key
                    bytes
            
            { ad = Just ad, tl = Nothing} ->
                Gren.Kernel.Crypto.encryptWithAesGcm
                    iv
                    ad
                    ""
                    key
                    bytes

            { ad = Nothing, tl = Just tl } ->
                Gren.Kernel.Crypto.encryptWithAesGcm
                    iv
                    ""
                    (aesTagLengthToInt tl)
                    key
                    bytes

            { ad = Just ad, tl = Just tl } ->
                Gren.Kernel.Crypto.encryptWithAesGcm
                    iv
                    ad
                    (aesTagLengthToInt tl)
                    key
                    bytes

    else
        Task.fail AesGcmEncryptionError



-- DECRYPT


{-|-}
type DecryptWithRsaOaepError =
    DecryptWithRsaOaepError


{-| Decryption can fail when either:

- The label used to encrypt the data does not match the label used when encryption the data
- The passed `Bytes`, for whatever reason, cannot be decrypted
-}
decryptWithRsaOaep : Maybe Bytes -> PrivateKeyV2 RsaOaepKey RsaKeyParams -> Bytes -> Task DecryptWithRsaOaepError Bytes
decryptWithRsaOaep passedLabel (PrivateKeyV2 (KeyV2 privateKey _)) bytes =
    case passedLabel of
        Nothing ->
            Gren.Kernel.Crypto.decryptWithRsaOaep
                ""
                privateKey
                bytes
        
        Just label ->
            Gren.Kernel.Crypto.decryptWithRsaOaep
                label
                privateKey
                bytes


{-|-}
type AesCtrDecryptError =
    AesCtrDecryptError


{-|-}
decryptWithAesCtr : AesCtrParams -> Key AesCtrKey -> Bytes -> Task AesCtrDecryptError Bytes
decryptWithAesCtr { counter, length } (Key { key }) bytes =
    if Bytes.width counter == 16 then
        Gren.Kernel.Crypto.decryptWithAesCtr
            counter
            (clamp 1 128 length)
            key
            bytes

    else
        Task.fail AesCtrDecryptError


{-|-}
type AesCbcDecryptionError
    = AesCbcDecryptionError


{-| Decrypt some `Bytes` with the AES-CBC algorithm.

Errors can happen when:
- The passed `iv` value does not equal 16 bytes
- The passsed `iv` value does not equal the `iv` value that was used to encrypt the passed `Bytes`
- The passed `Bytes` cannot be decrypted

-}
decryptWithAesCbc : SecureContext -> AesCbcParams -> Key AesCbcKey -> Bytes -> Task AesCbcDecryptionError Bytes
decryptWithAesCbc _context { iv } (Key { key }) bytes = 
    if Bytes.width iv == 16 then
        Gren.Kernel.Crypto.decryptWithAesCbc
            iv
            key
            bytes

    else
        Task.fail AesCbcDecryptionError


{-|-}
type AesGcmDecryptionError =
    AesGcmDecryptionError


{-|-}
decryptWithAesGcm : SecureContext -> AesGcmParams -> Key AesGcmKey -> Bytes -> Task AesGcmDecryptionError Bytes
decryptWithAesGcm _context { iv, additionalData, tagLength } (Key { key }) bytes =
    let
        byteWidth =
            Bytes.width iv
    in
    if byteWidth <= 128 && byteWidth >= 12 then
        case { ad = additionalData, tl = tagLength } of
            { ad = Nothing, tl = Nothing } ->
                Gren.Kernel.Crypto.decryptWithAesGcm
                    iv
                    ""
                    ""
                    key
                    bytes
            
            { ad = Just ad, tl = Nothing} ->
                Gren.Kernel.Crypto.decryptWithAesGcm
                    iv
                    ad
                    ""
                    key
                    bytes

            { ad = Nothing, tl = Just tl } ->
                Gren.Kernel.Crypto.decryptWithAesGcm
                    iv
                    ""
                    (aesTagLengthToInt tl)
                    key
                    bytes

            { ad = Just ad, tl = Just tl } ->
                Gren.Kernel.Crypto.decryptWithAesGcm
                    iv
                    ad
                    (aesTagLengthToInt tl)
                    key
                    bytes

    else
        Task.fail AesGcmDecryptionError



-- SIGN & VERIFY TYPES


{-|-}
type alias Signature
    = Bytes



-- SIGN


{-| Sign some `Bytes` with the RSA-SSAPKCS1v1.5 algorithm. This operation should always succeed.
-}
signWithRsaSsaPkcs1V1_5 : SecureContext -> PrivateKeyV2 RsaSsaPkcs1V1_5Key RsaKeyParams -> Bytes -> Task {} Signature
signWithRsaSsaPkcs1V1_5 _context (PrivateKeyV2 (KeyV2 key _)) bytes =
    Gren.Kernel.Crypto.signWithRsaSsaPkcs1V1_5 
        key 
        bytes


{-| An error that can appear when signing using the RSA-PSS algorithm.
-}
type SignWithRsaPssError
    = SignWithRsaPssError


{-| Sign some `Bytes` with the RSA-PSS algorithm.

When run, the returned `Task` can fail if the passed `salt` is not equal to or less then the
amount of bytes than the `DigestAlgorithm` that was used to generate the key. For example, if 
the `RsaPssKey` was generated with SHA-256, the maximum number for the `salt` value must be 
32 or less. Note that some platforms may succeed even when the `salt` is not as expected.
-}
signWithRsaPss : SecureContext -> Int -> PrivateKeyV2 RsaPssKey RsaKeyParams -> Bytes -> Task SignWithRsaPssError Signature
signWithRsaPss _context salt (PrivateKeyV2 (KeyV2 key _)) bytes =
    let
        clampedSaltBytes =
            clamp 0 2147483647 salt
    in
    Gren.Kernel.Crypto.signWithRsaPss 
        clampedSaltBytes
        key
        bytes


{-|-}
signWithEcdsa : SecureContext -> DigestAlgorithm -> PrivateKey EcdsaKey -> Bytes -> Task {} Signature
signWithEcdsa _context hash (PrivateKey (Key { key })) bytes =
    Gren.Kernel.Crypto.signWithEcdsa
        (digestAlgorithmToString hash)
        key 
        bytes


{-|-}
signWithHmac : SecureContext -> KeyV2 HmacKey HmacKeyParams -> Bytes -> Task {} Signature
signWithHmac _context (KeyV2 key _) bytes =
    Gren.Kernel.Crypto.signWithHmac 
        key 
        bytes



-- VERIFY


{-|-}
verifyWithRsaSsaPkcs1V1_5 : SecureContext -> PublicKeyV2 RsaSsaPkcs1V1_5Key RsaKeyParams -> Signature -> Bytes -> Task {} {}
verifyWithRsaSsaPkcs1V1_5 _context (PublicKeyV2 (KeyV2 key _)) signature bytes =
    Gren.Kernel.Crypto.verifyWithRsaSsaPkcs1V1_5
        key
        signature
        bytes


{-|-}
verifyWithRsaPss : SecureContext -> Int -> PublicKeyV2 RsaPssKey RsaKeyParams -> Signature -> Bytes -> Task {} Bytes
verifyWithRsaPss _context salt (PublicKeyV2 (KeyV2 key _)) signature bytes =
    Gren.Kernel.Crypto.verifyWithRsaPss
        salt
        key
        signature
        bytes


{-|-}
verifyWithEcdsa : SecureContext -> DigestAlgorithm -> PublicKey EcdsaKey -> Signature -> Bytes -> Task {} Bytes
verifyWithEcdsa _context hash (PublicKey (Key { key })) signature bytes =
    Gren.Kernel.Crypto.verifyWithEcdsa
        (digestAlgorithmToString hash)
        key
        signature
        bytes


{-|-}
verifyWithHmac : SecureContext -> KeyV2 HmacKey HmacKeyParams -> Signature -> Bytes -> Task {} Bytes
verifyWithHmac _context (KeyV2 key _) signature bytes =
    Gren.Kernel.Crypto.verifyWithHmac
        key
        signature
        bytes



-- DIGEST


{-| Supported algorithms suitable for digesting data.

Note: The algorithm `SHA1` is supported by the WebCrypto API, but not available 
in this package due to known security vunerabilities.
-}
type DigestAlgorithm
    = Sha256
    | Sha384
    | Sha512


{-|-}
digest : SecureContext -> DigestAlgorithm -> Bytes -> Task {} Bytes
digest _context algorithm data =
    Gren.Kernel.Crypto.digest
        (digestAlgorithmToString algorithm)
        data



-- UTILITIES


{-|-}
clamp : Int -> Int -> Int -> Int
clamp min max number =
    if number < min then
        min

    else if number > max then
        max

    else
        number


{-|-}
ecNamedCurveToString : EcNamedCurve -> String
ecNamedCurveToString namedCurve =
    case namedCurve of
        P256 ->
            "P-256"

        P384 ->
            "P-384"

        P521 ->
            "P-521"


{-|-}
aesLengthToInt : AesLength -> Int
aesLengthToInt length =
    case length of
        AesLength128 ->
            128

        -- AesLength192 ->
        --     192

        AesLength256 ->
            256


{-|-}
aesTagLengthToInt aesTagLength =
    case aesTagLength of
        AesGcmTagLength96 ->
            96

        AesGcmTagLength104 ->
            104

        AesGcmTagLength112 ->
            112
    
        AesGcmTagLength120 ->
            120

        AesGcmTagLength128 ->
            128


{-|-}
extractableToBool : Extractable -> Bool
extractableToBool extractable =
    case extractable of
        CanBeExtracted ->
            True
            
        CannotBeExtracted ->
            False


{-|-}
digestAlgorithmToString : DigestAlgorithm -> String
digestAlgorithmToString digestAlgorithm =
    case digestAlgorithm of
        Sha256 ->
            "SHA-256"

        Sha384 ->
            "SHA-384"

        Sha512 ->
            "SHA-512"


{-|-}
digestAlgorithmToBytes : DigestAlgorithm -> Int
digestAlgorithmToBytes digestAlgorithm =
    case digestAlgorithm of
        Sha256 ->
            32
        
        Sha384 ->
            48
        
        Sha512 ->
            64
