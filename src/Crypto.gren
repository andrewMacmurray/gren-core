module Crypto exposing 
    ( getRandomInt8Values, getRandomUInt8Values
    , getRandomInt16Values, getRandomUInt16Values
    , getRandomInt32Values, getRandomUInt32Values
    , SecureContext, getSecureContext
    , randomUuid
    , AesKeyParams
    , Key, PublicKey, PrivateKey, KeyPair
    , Extractable(..)
    , RsaOaepKey, RsaPssKey, RsaSsaPkcs1V1_5Key, RsaKeyParams, RsaKeyGenerationError(..)
    , generateRsaOaepKeyPair, generateRsaPssKeyPair, generateRsaSsaPkcs1V1_5KeyPair
    , AesLength(..)
    , RsaOaepParams, RsaOaepEncryptionError(..)
    , generateAesCtrKey, generateAesCbcKey, generateAesGcmKey
    , EcNamedCurve(..)
    , generateEcdsaKeyPair, generateEcdhKeyPair
    , HmacKeyParams, HmacKeyGenerationError(..)
    , generateHmacKey
    , ExportKeyError(..)
    , exportRsaOaepPublicKeyAsSpki, exportRsaOaepPublicKeyAsJwk
    , exportRsaOaepPrivateKeyAsPkcs8, exportRsaOaepPrivateKeyAsJwk
    , exportRsaPssPublicKeyAsSpki, exportRsaPssPublicKeyAsJwk
    , exportRsaPssPrivateKeyAsPkcs8, exportRsaPssPrivateKeyAsJwk
    , exportRsaSsaPkcs1V1_5PublicKeyAsSpki, exportRsaSsaPkcs1V1_5PublicKeyAsJwk
    , exportRsaSsaPkcs1V1_5PrivateKeyAsPkcs8, exportRsaSsaPkcs1V1_5PrivateKeyAsJwk
    , exportAesCtrKeyAsRaw, exportAesCtrKeyAsJwk
    , exportAesCbcKeyAsRaw, exportAesCbcKeyAsJwk
    , exportAesGcmKeyAsRaw, exportAesGcmKeyAsJwk
    , exportEcdsaPublicKeyAsRaw, exportEcdsaPublicKeyAsSpki, exportEcdsaPublicKeyAsJwk
    , exportEcdsaPrivateKeyAsPkcs8, exportEcdsaPrivateKeyAsJwk
    , exportEcdhPublicKeyAsRaw, exportEcdhPublicKeyAsSpki, exportEcdhPublicKeyAsJwk
    , exportEcdhPrivateKeyAsPkcs8, exportEcdhPrivateKeyAsJwk
    , exportHmacKeyAsRaw, exportHmacKeyAsJwk
    , ImportRsaKeyError(..)
    , importRsaOaepPublicKeyFromJwk, importRsaOaepPublicKeyFromSpki
    , importRsaOaepPrivateKeyFromJwk, importRsaOaepPrivateKeyFromPkcs8
    , importRsaPssPublicKeyFromJwk, importRsaPssPublicKeyFromSpki
    , importRsaPssPrivateKeyFromJwk, importRsaPssPrivateKeyFromPkcs8
    , importRsaSsaPkcs1V1_5PublicKeyFromJwk, importRsaSsaPkcs1V1_5PublicKeyFromSpki
    , importRsaSsaPkcs1V1_5PrivateKeyFromJwk, importRsaSsaPkcs1V1_5PrivateKeyFromPkcs8
    , ImportAesKeyError(..)
    , importAesCtrKeyFromRaw, importAesCtrKeyFromJwk
    , importAesCbcKeyFromRaw, importAesCbcKeyFromJwk
    , importAesGcmKeyFromRaw, importAesGcmKeyFromJwk
    , ImportEcKeyError(..)
    , importEcdsaPublicKeyFromRaw, importEcdsaPublicKeyFromSpki, importEcdsaPublicKeyFromJwk
    , importEcdhPublicKeyFromRaw, importEcdhPublicKeyFromSpki, importEcdhPublicKeyFromJwk
    , importEcdsaPrivateKeyFromPkcs8, importEcdsaPrivateKeyFromSpki, importEcdsaPrivateKeyFromJwk
    , importEcdhPrivateKeyFromPkcs8, importEcdhPrivateKeyFromSpki, importEcdhPrivateKeyFromJwk
    , ImportHmacKeyError(..)
    , importHmacKeyFromJwk, importHmacKeyFromRaw
    , DigestAlgorithm(..), digest
    , RsaOaepDecryptionError(..)
    , encryptWithRsaOaep, decryptWithRsaOaep
    , AesCtrParams, AesCtrEncryptionError(..), AesCtrDecryptError(..)
    , encryptWithAesCtr, decryptWithAesCtr
    , AesCbcParams, AesCbcEncryptionError(..), AesCbcDecryptionError(..)
    , encryptWithAesCbc, decryptWithAesCbc
    , AesGcmParams, AesGcmTagLength(..), AesGcmEncryptionError(..), AesGcmDecryptionError(..)
    , encryptWithAesGcm, decryptWithAesGcm
    , signWithRsaSsaPkcs1V1_5, verifyWithRsaSsaPkcs1V1_5
    , SignWithRsaPssError(..), signWithRsaPss, verifyWithRsaPss
    , signWithEcdsa, verifyWithEcdsa
    , signWithHmac, verifyWithHmac
    )


{-| 

This module gives access to various cryptograhic functions provided by the Web 
Crypto API on both `browser` and `node` platforms.

## Generate Random Values

Generate random values of 8, 16, or 32 bits long (signed and unsigned).

All functions for generating random values take an `Int` as the single parameter. 
This value is clamped to a minimum of `0` and a maximum of however many values can
be generated.

The maximum number of values that can be generated depends on the amount of bytes
the values you're generating are. 65536 is the maximum number of bytes that can be
generated. For example, when using `getRandomInt16Values`, each value is 16 bits 
(or 2 bytes), so the maximum number of values that `getRandomInt16Values` can generate
is 32768 values.

@docs getRandomInt8Values, getRandomUInt8Values

@docs getRandomInt16Values, getRandomUInt16Values

@docs getRandomInt32Values, getRandomUInt32Values

## Secure Context

Most functions in this module must be run in a secure context to operate safely
and correctly. Before you use any functions, it's likely you'll need to obtain
and store in your model the `SecureContext` value which can only be generated by
the successfull completion of a `Task` returned by the `getSecureContext` function.

@docs SecureContext, getSecureContext

## Generate Random UUIDs

@docs randomUuid

## Encryption & Decryption

Encrypt and decrypt values. Each operation requires a specific key for the algorithm
being used. You can learn more about key generation in the "Key Generation" section of
this module.

### Encrypt & decrypt with RSA-OAEP algorithm

Encrypt and decrypt `Bytes` with the RSA-OAEP (Rivest-Shamir-Adleman Optimal Asymmetric 
Encryption Padding) algorithm. These functions require an RSA-OAEP key pair. You can 
generate one with the [`generateRsaOaepKeyPair`](#generateRsaOaepKeyPair) function.

@docs RsaOaepParams

@docs RsaOaepEncryptionError, encryptWithRsaOaep

@docs RsaOaepDecryptionError, decryptWithRsaOaep

### Encrypt & decrypt with AES-CTR algorithm

Encrypt and decrypt `Bytes` with the AES-CTR (Advanced Encryption Standard - Counter Mode) 
algorithm. These functions require an AES-CTR key. You can generate one with the 
[`generateAesCtrKey`](#generateAesCtrKey) function.

@docs AesCtrParams

@docs AesCtrEncryptionError, encryptWithAesCtr

@docs AesCtrDecryptError, decryptWithAesCtr

### Encrypt & decrypt with AES-CBC algorithm

@docs AesCbcParams
@docs AesCbcEncryptionError, encryptWithAesCbc
@docs AesCbcDecryptionError, decryptWithAesCbc

### Encrypt & decrypt with AES-GCM algorithm

@docs AesGcmParams, AesGcmTagLength
@docs AesGcmEncryptionError, encryptWithAesGcm
@docs AesGcmDecryptionError, decryptWithAesGcm

## Signing & Verifying

### Sign & vefify with the RSASSA-PKCS1-v1_5 algorithm

@docs signWithRsaSsaPkcs1V1_5, verifyWithRsaSsaPkcs1V1_5
@docs SignWithRsaPssError, signWithRsaPss, verifyWithRsaPss

### Sign & vefify with the ECDSA algorithm

@docs signWithEcdsa, verifyWithEcdsa

### Sign & vefify with the HMAC algorithm

@docs signWithHmac, verifyWithHmac

## Digest

@docs DigestAlgorithm, digest

## Generate Keys

Generate, import, and export keys for completing cryptographic operations. 
Each section covers a different sets of keys that use the same underlying algorithm. 
Each key can be only be used for specific set of cryptographic operations.

@docs Key, PublicKey, PrivateKey, KeyPair

@docs Extractable

### Generate RSA Keys

Generate keys to use with RSA (Rivest-Shamir-Adleman) algorithm.

@docs RsaOaepKey, RsaPssKey, RsaSsaPkcs1V1_5Key

@docs RsaKeyParams, RsaKeyGenerationError

@docs generateRsaOaepKeyPair, generateRsaPssKeyPair, generateRsaSsaPkcs1V1_5KeyPair

### Generate AES Keys

@docs AesKeyParams, AesLength

@docs generateAesCtrKey, generateAesCbcKey, generateAesGcmKey

### Generate ECD Keys

@docs EcNamedCurve

@docs generateEcdsaKeyPair, generateEcdhKeyPair

### Generate HMAC Keys 

@docs HmacKeyParams, HmacKeyGenerationError

@docs generateHmacKey

## Export Keys

Export keys in various formats. Available formats depend on the key being exported.

For more information on exporting keys, check out the [MDN web docs](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)
for the Web Crypto API.

@docs ExportKeyError

### Export RSA Keys

@docs exportRsaOaepPublicKeyAsSpki, exportRsaOaepPublicKeyAsJwk

@docs exportRsaOaepPrivateKeyAsPkcs8, exportRsaOaepPrivateKeyAsJwk

@docs exportRsaPssPublicKeyAsSpki, exportRsaPssPublicKeyAsJwk

@docs exportRsaPssPrivateKeyAsPkcs8, exportRsaPssPrivateKeyAsJwk

@docs exportRsaSsaPkcs1V1_5PublicKeyAsSpki, exportRsaSsaPkcs1V1_5PublicKeyAsJwk

@docs exportRsaSsaPkcs1V1_5PrivateKeyAsPkcs8, exportRsaSsaPkcs1V1_5PrivateKeyAsJwk

### Export AES Keys

@docs exportAesCtrKeyAsRaw, exportAesCtrKeyAsJwk

@docs exportAesCbcKeyAsRaw, exportAesCbcKeyAsJwk

@docs exportAesGcmKeyAsRaw, exportAesGcmKeyAsJwk

### Export EC Keys

@docs exportEcdsaPublicKeyAsRaw, exportEcdsaPublicKeyAsSpki, exportEcdsaPublicKeyAsJwk

@docs exportEcdsaPrivateKeyAsPkcs8, exportEcdsaPrivateKeyAsJwk

@docs exportEcdhPublicKeyAsRaw, exportEcdhPublicKeyAsSpki, exportEcdhPublicKeyAsJwk

@docs exportEcdhPrivateKeyAsPkcs8, exportEcdhPrivateKeyAsJwk

### Export HMAC Keys 

@docs exportHmacKeyAsRaw, exportHmacKeyAsJwk

## Import Keys

Import exported keys.

For more information on exporting keys, check out the [MDN web docs](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey)
for the Web Crypto API.

### Import RSA Keys

@docs ImportRsaKeyError

@docs importRsaOaepPublicKeyFromJwk, importRsaOaepPublicKeyFromSpki

@docs importRsaOaepPrivateKeyFromJwk, importRsaOaepPrivateKeyFromPkcs8

@docs importRsaPssPublicKeyFromJwk, importRsaPssPublicKeyFromSpki

@docs importRsaPssPrivateKeyFromJwk, importRsaPssPrivateKeyFromPkcs8

@docs importRsaSsaPkcs1V1_5PrivateKeyFromJwk, importRsaSsaPkcs1V1_5PrivateKeyFromPkcs8

@docs importRsaSsaPkcs1V1_5PublicKeyFromJwk, importRsaSsaPkcs1V1_5PublicKeyFromSpki

### Import AES Keys

@docs ImportAesKeyError

@docs importAesCbcKeyFromJwk, importAesCbcKeyFromRaw

@docs importAesCtrKeyFromJwk, importAesCtrKeyFromRaw

@docs importAesGcmKeyFromJwk, importAesGcmKeyFromRaw

### Import EC Keys

@docs ImportEcKeyError

@docs importEcdhPrivateKeyFromJwk, importEcdhPrivateKeyFromPkcs8, importEcdhPrivateKeyFromSpki

@docs importEcdhPublicKeyFromJwk, importEcdhPublicKeyFromRaw, importEcdhPublicKeyFromSpki

@docs importEcdsaPrivateKeyFromJwk, importEcdsaPrivateKeyFromPkcs8, importEcdsaPrivateKeyFromSpki

@docs importEcdsaPublicKeyFromJwk, importEcdsaPublicKeyFromRaw, importEcdsaPublicKeyFromSpki

### Import HMAC Keys 

@docs ImportHmacKeyError

@docs importHmacKeyFromJwk, importHmacKeyFromRaw

-}


import Array exposing ( Array )
import Basics exposing ( toFloat, Never, Bool(..), Int, (>), (<), (<=), (>=), (==), (*), (^), (/), (/=), (|>), (&&) )
import Gren.Kernel.Crypto
import String exposing ( String )
import Task exposing ( Task )
import Debug
import Bytes exposing ( Bytes )
import Bytes.Encode
import Maybe exposing ( Maybe(..) )
import Result exposing ( Result(..) )
import Set exposing ( Set )
import Bitwise
import Math
import Json.Encode
import Gren.Kernel.Json


-- RANDOM UUID


{-| Generate a random UUID using the UUID v4 algorithm.
-}
randomUuid : SecureContext -> Task x String
randomUuid _context =
    Gren.Kernel.Crypto.randomUUID


-- RANDOM VALUES


{-| Get some `Bytes` of random, signed, 8-bit values equal to the length of the passed `Int`
with a maximum of 65536 values.
-}
getRandomInt8Values : Int -> Task x Bytes
getRandomInt8Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 65536 int) "int8"


{-| Get some `Bytes` of random, unsigned, 8-bit values equal to the length of the passed `Int`
with a maximum of 65536 values.
-}
getRandomUInt8Values : Int -> Task x Bytes
getRandomUInt8Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 65536 int) "uint8"

 
{-| Get some `Bytes` of random, signed, 16-bit values equal to the length of the passed `Int`.
with a maximum of 32768 values.
-}
getRandomInt16Values : Int -> Task x Bytes
getRandomInt16Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 32768 int) "int16"


{-| Get some `Bytes` of random, unsigned, 16-bit values equal to the length of the passed `Int`.
with a maximum of 32768 values.
-}
getRandomUInt16Values : Int -> Task x Bytes
getRandomUInt16Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 32768 int) "uint16"


{-|Get some `Bytes` of random, signed, 32-bit values equal to the length of the passed `Int`
with a maximum of 16384 values.
-}
getRandomInt32Values : Int -> Task x Bytes
getRandomInt32Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 16384 int) "int32"


{-| Get some `Bytes` of random, unsigned, 32-bit values equal to the length of the passed `Int`
with a maximum of 16384 values.
-}
getRandomUInt32Values : Int -> Task x Bytes
getRandomUInt32Values int =
    Gren.Kernel.Crypto.getRandomValues (clamp 0 16384 int) "uint32"


-- ENVIRONMENT


{-| Represents the platform being considered secure. This type can be generated 
using the `getSecureContext` function and is required for some functions to be 
run in this package.
-}
type SecureContext
    = SecureContext


{-| A `Task` that succeeds with `SecureContext` if the code is being run in a 
secure context. If this `Task` fails, most of the functions within this module
will not be able to run.

While running this function on the `node` platform, it should succeed unless you
are running a version of `node` that does not support the Web Crypto APIs.

While running this function on the `browser` platform, it will succeed if the
application being run is [considered as being in a secure context](https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts).
-}
getSecureContext : Task x SecureContext
getSecureContext =
    Gren.Kernel.Crypto.getContext


-- KEYS


{-| Denotes if a key can be exported using the `exportKey` or `exportKeyPair`
functions. If a key is not marked as exportable when it is created or imported, 
any attempts to export the key will fail.
-}
type Extractable
    = CanBeExtracted
    | CannotBeExtracted


{-| A generated key.
-}
type Key key keyData
    = Key key keyData


{-| A public key that is used for some operations. This key type, as the name
suggests, can be exposed publically and is safe to transport across the network.
-}
type PublicKey a b
    = PublicKey (Key a b)


{-| A private key that is used for some specific cryptographic operations. This
key should be protected and not revealed to any system outside of your application.
-}
type PrivateKey a b
    = PrivateKey (Key a b)


{-| A set of public and private keys created by some key generation algorithms.
-}
type alias KeyPair a b =
    { publicKey : PublicKey a b
    , privateKey : PrivateKey a b
    }


-- RSA KEYS


{-| Represents a key generated and for use with the RSA-OAEP algorithm used to 
encrypt and decrypt values.
-}
type RsaOaepKey
    = RsaOaepKey


{-| A key generated for use with the RSA-PSS algorithm. Used to sign and verify 
values.
-}
type RsaPssKey =
    RsaPssKey


{-| A key generated for use with the RSASSA-PKCS1-v1_5 algorithm. Used to sign 
and verify values.
-}
type RsaSsaPkcs1V1_5Key
    = RsaSsaPkcs1V1_5Key


{-| Parameters required to generate a key for uses with the RSA algorithm.

`modulusLength` is clamped be at least 2048 and no greater than 4096. If the
`Int` used is outside of that range, it will be corrected.

The public exponent for RSA keys is always `[ 1, 0, 1 ]` or `65537`. This is
a recommended value and a value that works across the `browser` and `node` platforms.
-}
type alias RsaKeyParams =
    { modulusLength : Int
    , hash : DigestAlgorithm
    , extractable : Extractable
    }


{-| Errors that can happen when generating a key for use with the RSA algorithm.

- `ModulusLengthNotDivisibleByEight` happens when the passed `modulusLength` is
not divisible by 8, as is required by the algorithm.
-}
type RsaKeyGenerationError
    = ModulusLengthNotDivisibleByEight


{-| Generate a new key pair using the RSA-OAEP (Optimal Asymmetric Encryption 
Padding) algorithm.

Produces a `KeyPair` that can be used to encrypt and decrypt data.
-}
generateRsaOaepKeyPair : SecureContext -> RsaKeyParams -> Task RsaKeyGenerationError (KeyPair RsaOaepKey RsaKeyParams)
generateRsaOaepKeyPair _context =
    generateRsaKeyHelper 
        "RSA-OAEP" 
        [ "encrypt", "decrypt" ]


{-| Generate a new key using the RSA-PSS algorithm.

Produces a `KeyPair` that can be used to sign and verify data.
-}
generateRsaPssKeyPair : SecureContext -> RsaKeyParams -> Task RsaKeyGenerationError (KeyPair RsaPssKey RsaKeyParams)
generateRsaPssKeyPair _context =
    generateRsaKeyHelper 
        "RSA-PSS"
        [ "sign", "verify" ]


{-| Generate a new key using the RSASSA-PKCS1-v1_5 algorithm.

Produces a `KeyPair` that can be used to sign and verify data.
-}
generateRsaSsaPkcs1V1_5KeyPair : SecureContext -> RsaKeyParams -> Task RsaKeyGenerationError (KeyPair RsaSsaPkcs1V1_5Key RsaKeyParams)
generateRsaSsaPkcs1V1_5KeyPair _context =
    generateRsaKeyHelper 
        "RSASSA-PKCS1-v1_5"
        [ "sign", "verify" ]


{-|-}
generateRsaKeyHelper : String -> Array String -> RsaKeyParams -> Task RsaKeyGenerationError a
generateRsaKeyHelper name permissions { modulusLength, hash, extractable } =
    let
        clampedModulusLength = 
            clamp 2048 4096 modulusLength
    in
    if Math.remainderBy 8 clampedModulusLength == 0 then
        Gren.Kernel.Crypto.generateRsaKey 
            name
            clampedModulusLength
            [ 1, 0, 1 ] -- Public exponent
            (digestAlgorithmToString hash)
            (extractableToBool extractable)
            permissions
    else
        Task.fail ModulusLengthNotDivisibleByEight


-- AES KEYS


{-| Represents a key generated and for use with the AES-CTR algorithm used to
encrypt and decrypt values.
-}
type AesCtrKey
    = AesCtrKey


{-| Represents a key generated and for use with the AES-CBC algorithm used to
encrypt and decrypt values.
-}
type AesCbcKey
    = AesCbcKey


{-| Represents a key generated and for use with the AES-GCM algorithm used to
encrypt and decrypt values.
-}
type AesGcmKey
    = AesGcmKey


{-| The required parameters to generates an AES key.
-}
type alias AesKeyParams =
    { length : AesLength
    , extractable : Extractable
    }


{-| The length of bits of the key that is being generated using the AES 
algorithm. These are the only values that can be chosen.

The Web Crypto API supports a length of 192, but some browsers do not implement
this. To keep compatability across browser, the option is not provided.
-}
type AesLength
    = AesLength128
    | AesLength192
    | AesLength256


{-| Generate a new key using the AES-CTR algorithm.
-}
generateAesCtrKey : SecureContext -> AesKeyParams -> Task x (Key AesCtrKey AesKeyParams)
generateAesCtrKey _context { length, extractable }=
    Gren.Kernel.Crypto.generateAesKey
        "AES-CTR"
        (aesLengthToInt length)
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-| Generate a new key using the AES-CBC algorithm.
-}
generateAesCbcKey : SecureContext -> AesKeyParams -> Task x (Key AesCbcKey AesKeyParams)
generateAesCbcKey _context { length, extractable } =
    Gren.Kernel.Crypto.generateAesKey
        "AES-CBC"
        (aesLengthToInt length)
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-| Generate a new key using the AES-GCM algorithm.
-}
generateAesGcmKey : SecureContext -> AesKeyParams -> Task x (Key AesGcmKey AesKeyParams)
generateAesGcmKey _context { length, extractable } =
    Gren.Kernel.Crypto.generateAesKey
        "AES-GCM"
        (aesLengthToInt length)
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


-- ECD KEYS


{-| Represents a key generated and for use with the ECDSA algorithm used to
sign and verify values.
-}
type EcdsaKey
    = EcdsaKey


{-| Represents a key generated and for use with the ECDH algorithm used to
derive keys and bits.
-}
type EcdhKey
    = EcdhKey


{-|-}
type alias EcKeyParams =
    { namedCurve : EcNamedCurve
    , extractable : Extractable
    }


{-| The name of the elliptic curve to use for the generated key.
-}
type EcNamedCurve
    = P256
    | P384
    | P521


{-| Generate a new key using the ECDSA algorithm.
-}
generateEcdsaKeyPair : SecureContext -> EcKeyParams-> Task x (KeyPair EcdsaKey EcKeyParams)
generateEcdsaKeyPair _context { namedCurve, extractable } =
    Gren.Kernel.Crypto.generateEcKey
        "ECDSA"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        [ "sign", "verify" ]


{-| Generate a new key using the ECDH algorithm.
-}
generateEcdhKeyPair : SecureContext -> EcKeyParams -> Task x (KeyPair EcdhKey EcKeyParams)
generateEcdhKeyPair _context { namedCurve, extractable } =
    Gren.Kernel.Crypto.generateEcKey
        "ECDH"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        [ "deriveKey", "deriveBits" ]


-- HMAC KEYS


{-| Represents a key generated and for use with the HMAC algorithm used to
sign and verify values.
-}
type HmacKey =
    HmacKey


{-| Errors that can happen when generating a key for use with the RSA algorithm.

- `ModulusLengthNotDivisibleByEight` happens when the passed `modulusLength` is
not divisible by 8, as is required by the algorithm.
-}
type HmacKeyGenerationError
    = LengthNotDivisibleByEight


{-| Parameters required to generate a key for uses with the HMAC algorithm.

The passed `length` will be the length of the resulting key in bits. If
`Nothing`, the key will be equal in bits to the passed `DigestAlgorithm`. 
It's recommended to pass `Nothing` and let the length of the key be equal 
to the hash function (`DigestAlgorithm`).

If passed, the `length` is clamped be at least 8 and no greater than 2048. 
If the `Int` used is outside of that range, it will be corrected.
-}
type alias HmacKeyParams =
    { length : Maybe Int
    , hash : DigestAlgorithm
    , extractable : Extractable
    }


{-| Generate a new key using the HMAC algorithm.
-}
generateHmacKey : SecureContext -> HmacKeyParams -> Task HmacKeyGenerationError (Key HmacKey HmacKeyParams)
generateHmacKey _context { hash, length, extractable } =
    case length of
        Just passedLength ->
            let
                clampedLength =
                    clamp 8 2048 passedLength
            in
            if Math.remainderBy 8 clampedLength == 0 then
                Gren.Kernel.Crypto.generateHmacKey
                    "HMAC"
                    (digestAlgorithmToString hash)
                    clampedLength
                    (extractableToBool extractable)
                    [ "sign", "verify" ]
            
            else
                Task.fail LengthNotDivisibleByEight

        Nothing ->
            Gren.Kernel.Crypto.generateHmacKey
                "HMAC"
                (digestAlgorithmToString hash)
                ""
                (extractableToBool extractable)
                [ "sign", "verify" ]



-- EXPORT KEYS


{-| Errors that can arise when exporting keys.

- `NotExportable` happens when trying to export a key that was not made
`Extractable` during creation or import.
-}
type ExportKeyError
    = KeyNotExportable


{-| Export a `RsaOaepKey` as a [SubjectPublicKeyInfo](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#subjectpublickeyinfo).

The result `Bytes` can be imported again using the `importRsaOaepPublicKey` function.
-}
exportRsaOaepPublicKeyAsSpki : SecureContext -> PublicKey RsaOaepKey RsaKeyParams -> Task ExportKeyError Bytes
exportRsaOaepPublicKeyAsSpki _context (PublicKey key) =
    exportKeyAsSpki key


{-| Export a `RsaOaepKey` as a [JSON Web Key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#json_web_key).

The resulting `Json.Encode.Value` can be imported again using the `importRsaOaepPublicKey` function.
-}
exportRsaOaepPublicKeyAsJwk : SecureContext -> PublicKey RsaOaepKey RsaKeyParams -> Task ExportKeyError Json.Encode.Value
exportRsaOaepPublicKeyAsJwk _context (PublicKey key) =
    exportKeyAsJwk key


{-| Export a `RsaOaepKey` as [PKCS #8](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#pkcs_8)
-}
exportRsaOaepPrivateKeyAsPkcs8 : SecureContext -> PrivateKey RsaOaepKey RsaKeyParams -> Task ExportKeyError Bytes
exportRsaOaepPrivateKeyAsPkcs8 _context (PrivateKey key) =
    exportKeyAsPkcs8 key


{-| Export a private `RsaOaepKey` as a [JSON Web Key]() 
-}
exportRsaOaepPrivateKeyAsJwk : SecureContext -> PrivateKey RsaOaepKey RsaKeyParams -> Task ExportKeyError Json.Encode.Value
exportRsaOaepPrivateKeyAsJwk _context (PrivateKey key) =
    exportKeyAsJwk key


{-|-}
exportRsaPssPublicKeyAsSpki : SecureContext -> PublicKey RsaPssKey RsaKeyParams -> Task ExportKeyError Bytes
exportRsaPssPublicKeyAsSpki _context (PublicKey key)=
    exportKeyAsSpki key


{-|-}
exportRsaPssPublicKeyAsJwk : SecureContext -> PublicKey RsaPssKey RsaKeyParams -> Task ExportKeyError Json.Encode.Value
exportRsaPssPublicKeyAsJwk _context (PublicKey key) =
    exportKeyAsJwk key


{-|-}
exportRsaPssPrivateKeyAsPkcs8 : SecureContext -> PrivateKey RsaPssKey RsaKeyParams-> Task ExportKeyError Bytes
exportRsaPssPrivateKeyAsPkcs8 _context (PrivateKey key) =
    exportKeyAsPkcs8 key


{-|-}
exportRsaPssPrivateKeyAsJwk : SecureContext -> PrivateKey RsaPssKey RsaKeyParams -> Task ExportKeyError Json.Encode.Value
exportRsaPssPrivateKeyAsJwk _context (PrivateKey key) =
    exportKeyAsJwk key


{-|-}
exportRsaSsaPkcs1V1_5PublicKeyAsSpki : SecureContext -> PublicKey RsaSsaPkcs1V1_5Key RsaKeyParams -> Task ExportKeyError Bytes
exportRsaSsaPkcs1V1_5PublicKeyAsSpki _context (PublicKey key) =
    exportKeyAsSpki key


{-|-}
exportRsaSsaPkcs1V1_5PublicKeyAsJwk : SecureContext -> PublicKey RsaSsaPkcs1V1_5Key RsaKeyParams -> Task ExportKeyError Json.Encode.Value
exportRsaSsaPkcs1V1_5PublicKeyAsJwk _context (PublicKey key) =
    exportKeyAsJwk key


{-|-}
exportRsaSsaPkcs1V1_5PrivateKeyAsPkcs8 : SecureContext -> PrivateKey RsaSsaPkcs1V1_5Key RsaKeyParams -> Task ExportKeyError Bytes
exportRsaSsaPkcs1V1_5PrivateKeyAsPkcs8 _context (PrivateKey key)=
    exportKeyAsPkcs8 key


{-|-}
exportRsaSsaPkcs1V1_5PrivateKeyAsJwk : SecureContext -> PrivateKey RsaSsaPkcs1V1_5Key RsaKeyParams -> Task ExportKeyError Json.Encode.Value
exportRsaSsaPkcs1V1_5PrivateKeyAsJwk _context (PrivateKey key) =
    exportKeyAsJwk key


{-|-}
exportAesCtrKeyAsRaw : SecureContext -> Key AesCtrKey AesKeyParams -> Task ExportKeyError Bytes
exportAesCtrKeyAsRaw _context =
    exportKeyAsRaw


{-|-}
exportAesCtrKeyAsJwk : SecureContext -> Key AesCtrKey AesKeyParams -> Task ExportKeyError Json.Encode.Value
exportAesCtrKeyAsJwk _context =
    exportKeyAsJwk


{-|-}
exportAesCbcKeyAsRaw : SecureContext -> Key AesCbcKey AesKeyParams -> Task ExportKeyError Bytes
exportAesCbcKeyAsRaw _context =
    exportKeyAsRaw


{-|-}
exportAesCbcKeyAsJwk : SecureContext -> Key AesCbcKey AesKeyParams -> Task ExportKeyError Json.Encode.Value
exportAesCbcKeyAsJwk _context =
    exportKeyAsJwk


{-|-}
exportAesGcmKeyAsRaw : SecureContext -> Key AesGcmKey AesKeyParams -> Task ExportKeyError Bytes
exportAesGcmKeyAsRaw _context =
    exportKeyAsRaw


{-|-}
exportAesGcmKeyAsJwk : SecureContext -> Key AesGcmKey AesKeyParams -> Task ExportKeyError Json.Encode.Value
exportAesGcmKeyAsJwk _context =
    exportKeyAsJwk


{-|-}
exportEcdsaPublicKeyAsRaw : SecureContext -> PublicKey EcdsaKey EcKeyParams -> Task ExportKeyError Bytes
exportEcdsaPublicKeyAsRaw _context (PublicKey key) =
    exportKeyAsRaw key


{-|-}
exportEcdsaPublicKeyAsSpki : SecureContext -> PublicKey EcdsaKey EcKeyParams -> Task ExportKeyError Bytes
exportEcdsaPublicKeyAsSpki _context (PublicKey key) =
    exportKeyAsSpki key


{-|-}
exportEcdsaPublicKeyAsJwk : SecureContext -> PublicKey EcdsaKey EcKeyParams -> Task ExportKeyError Json.Encode.Value
exportEcdsaPublicKeyAsJwk _context (PublicKey key) =
    exportKeyAsJwk key


{-|-}
exportEcdsaPrivateKeyAsPkcs8 : SecureContext -> PrivateKey EcdsaKey EcKeyParams -> Task ExportKeyError Bytes
exportEcdsaPrivateKeyAsPkcs8 _context (PrivateKey key) =
    exportKeyAsPkcs8 key


{-|-}
exportEcdsaPrivateKeyAsJwk : SecureContext -> PrivateKey EcdsaKey EcKeyParams -> Task ExportKeyError Json.Encode.Value
exportEcdsaPrivateKeyAsJwk _context (PrivateKey key)=
    exportKeyAsJwk key


{-|-}
exportEcdhPublicKeyAsRaw : SecureContext -> PublicKey EcdhKey EcKeyParams -> Task ExportKeyError Bytes
exportEcdhPublicKeyAsRaw _context (PublicKey key) =
    exportKeyAsRaw key


{-|-}
exportEcdhPublicKeyAsSpki : SecureContext -> PublicKey EcdhKey EcKeyParams -> Task ExportKeyError Bytes
exportEcdhPublicKeyAsSpki _context (PublicKey key) =
    exportKeyAsSpki key


{-|-}
exportEcdhPublicKeyAsJwk : SecureContext -> PublicKey EcdhKey EcKeyParams -> Task ExportKeyError Json.Encode.Value
exportEcdhPublicKeyAsJwk _context (PublicKey key) =
    exportKeyAsJwk key


{-|-}
exportEcdhPrivateKeyAsPkcs8 : SecureContext -> PrivateKey EcdhKey EcKeyParams -> Task ExportKeyError Bytes
exportEcdhPrivateKeyAsPkcs8 _context (PrivateKey key) =
    exportKeyAsPkcs8 key


{-|-}
exportEcdhPrivateKeyAsJwk : SecureContext -> PrivateKey EcdhKey EcKeyParams -> Task ExportKeyError Json.Encode.Value
exportEcdhPrivateKeyAsJwk _context (PrivateKey key) =
    exportKeyAsJwk key


{-|-}
exportHmacKeyAsRaw : SecureContext -> Key HmacKey HmacKeyParams -> Task ExportKeyError Bytes
exportHmacKeyAsRaw _context =
    exportKeyAsRaw


{-|-}
exportHmacKeyAsJwk : SecureContext -> Key HmacKey HmacKeyParams -> Task ExportKeyError Json.Encode.Value
exportHmacKeyAsJwk _context =
    exportKeyAsJwk


{-|-}
exportKeyHelperV2 : String -> Key a b -> Task ExportKeyError c
exportKeyHelperV2 keyType (Key key _) =
    Gren.Kernel.Crypto.exportKey keyType key


{-|-}
exportKeyAsRaw : Key a b -> Task ExportKeyError Bytes
exportKeyAsRaw =
    exportKeyHelperV2 "raw"


{-|-}
exportKeyAsPkcs8 : Key a b -> Task ExportKeyError Bytes
exportKeyAsPkcs8 =
    exportKeyHelperV2 "pkcs8"


{-|-}
exportKeyAsSpki : Key a b -> Task ExportKeyError Bytes
exportKeyAsSpki =
    exportKeyHelperV2 "spki"


{-|-}
exportKeyAsJwk : Key a b -> Task ExportKeyError Json.Encode.Value
exportKeyAsJwk key =
    Task.map Gren.Kernel.Json.wrap (exportKeyHelperV2 "jwk" key)


-- IMPORT KEYS


{-| Parameters required for importing a key using an RSA algorithm.
-}
type alias ImportRsaKeyParams =
    { hash : DigestAlgorithm
    }


{-| Appears if there's an error when importing a key using an RSA algorithm.

There are two possible reasons this error happens:

1. The passed key value (either `Json.Encode.Value` or `Bytes`) is not 
a valid key and cannot be imported.
2. The `hash` passed to the function does not match the `hash` of the imported key. This only 
happens when importing a JSON Web Key. It is recommended to _always_ match the hash of the 
imported key or you will get different results when using the imported key.
-}
type ImportRsaKeyError
    = ImportRsaKeyError


{-|-}
importRsaOaepPublicKeyFromJwk : SecureContext -> Json.Encode.Value -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PublicKey RsaOaepKey RsaKeyParams)
importRsaOaepPublicKeyFromJwk _context jwk { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "public"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "RSA-OAEP"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "encrypt" ]


{-|-}
importRsaOaepPublicKeyFromSpki : SecureContext -> Bytes -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PublicKey RsaOaepKey RsaKeyParams)
importRsaOaepPublicKeyFromSpki _context bytes { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "public"
        "spki"
        bytes
        "RSA-OAEP"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "encrypt" ]


{-|-}
importRsaPssPublicKeyFromJwk : SecureContext -> Json.Encode.Value -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PublicKey RsaPssKey RsaKeyParams)
importRsaPssPublicKeyFromJwk _context jwk { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "public"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "RSA-PSS"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "verify" ]


{-|-}
importRsaPssPublicKeyFromSpki : SecureContext -> Bytes -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PublicKey RsaPssKey RsaKeyParams)
importRsaPssPublicKeyFromSpki _context bytes { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "public"
        "spki"
        bytes
        "RSA-PSS"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "verify" ]


{-|-}
importRsaOaepPrivateKeyFromJwk : SecureContext -> Json.Encode.Value -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PrivateKey RsaOaepKey RsaKeyParams)
importRsaOaepPrivateKeyFromJwk _context jwk { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "private"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "RSA-OAEP"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "decrypt" ]


{-|-}
importRsaOaepPrivateKeyFromPkcs8 : SecureContext -> Bytes -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PrivateKey RsaOaepKey RsaKeyParams)
importRsaOaepPrivateKeyFromPkcs8 _context bytes { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "private"
        "pkcs8"
        bytes
        "RSA-OAEP"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "decrypt" ]


{-|-}
importRsaPssPrivateKeyFromJwk : SecureContext -> Json.Encode.Value -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PrivateKey RsaPssKey RsaKeyParams)
importRsaPssPrivateKeyFromJwk _context jwk { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "private"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "RSA-PSS"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "sign" ]


{-|-}
importRsaPssPrivateKeyFromPkcs8 : SecureContext -> Bytes -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PrivateKey RsaPssKey RsaKeyParams)
importRsaPssPrivateKeyFromPkcs8 _context bytes { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "private"
        "pkcs8"
        bytes
        "RSA-PSS"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "sign" ]


{-|-}
importRsaSsaPkcs1V1_5PublicKeyFromJwk : SecureContext -> Json.Encode.Value -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PrivateKey RsaSsaPkcs1V1_5Key RsaKeyParams)
importRsaSsaPkcs1V1_5PublicKeyFromJwk _context jwk { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "public"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "RSASSA-PKCS1-v1_5"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "sign" ]


{-|-}
importRsaSsaPkcs1V1_5PublicKeyFromSpki : SecureContext -> Bytes -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PrivateKey RsaSsaPkcs1V1_5Key RsaKeyParams)
importRsaSsaPkcs1V1_5PublicKeyFromSpki _context bytes { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "public"
        "spki"
        bytes
        "RSASSA-PKCS1-v1_5"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "verify" ]


{-|-}
importRsaSsaPkcs1V1_5PrivateKeyFromJwk : SecureContext -> Json.Encode.Value -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PrivateKey RsaSsaPkcs1V1_5Key RsaKeyParams)
importRsaSsaPkcs1V1_5PrivateKeyFromJwk _context jwk { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "private"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "RSASSA-PKCS1-v1_5"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "sign" ]


{-|-}
importRsaSsaPkcs1V1_5PrivateKeyFromPkcs8 : SecureContext -> Bytes -> ImportRsaKeyParams -> Extractable -> Task ImportRsaKeyError (PrivateKey RsaSsaPkcs1V1_5Key RsaKeyParams)
importRsaSsaPkcs1V1_5PrivateKeyFromPkcs8 _context bytes { hash } extractable =
    Gren.Kernel.Crypto.importRsaKey
        "private"
        "pkcs8"
        bytes
        "RSASSA-PKCS1-v1_5"
        (digestAlgorithmToString hash)
        (extractableToBool extractable)
        [ "sign" ]


{-|-}
type ImportAesKeyError
    = ImportAesKeyError


{-|-}
importAesCtrKeyFromRaw : SecureContext -> Bytes -> Extractable -> Task ImportAesKeyError (Key AesCtrKey AesKeyParams)
importAesCtrKeyFromRaw _context bytes extractable =
    Gren.Kernel.Crypto.importAesKey
        "raw"
        bytes
        "AES-CTR"
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-|-}
importAesCtrKeyFromJwk : SecureContext -> Json.Encode.Value -> Extractable -> Task ImportAesKeyError (Key AesCtrKey AesKeyParams)
importAesCtrKeyFromJwk _context jwk extractable =
    Gren.Kernel.Crypto.importAesKey
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "AES-CTR"
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-|-}
importAesCbcKeyFromRaw : SecureContext -> Bytes -> Extractable -> Task ImportAesKeyError (Key AesCtrKey AesKeyParams)
importAesCbcKeyFromRaw _context bytes extractable =
    Gren.Kernel.Crypto.importAesKey
        "raw"
        bytes
        "AES-CBC"
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-|-}
importAesCbcKeyFromJwk : SecureContext -> Json.Encode.Value -> Extractable -> Task ImportAesKeyError (Key AesCtrKey AesKeyParams)
importAesCbcKeyFromJwk _context jwk extractable =
    Gren.Kernel.Crypto.importAesKey
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "AES-CBC"
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-|-}
importAesGcmKeyFromRaw : SecureContext -> Bytes -> Extractable -> Task ImportAesKeyError (Key AesCtrKey AesKeyParams)
importAesGcmKeyFromRaw _context bytes extractable =
    Gren.Kernel.Crypto.importAesKey
        "raw"
        bytes
        "AES-GCM"
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-|-}
importAesGcmKeyFromJwk : SecureContext -> Json.Encode.Value -> Extractable -> Task ImportAesKeyError (Key AesCtrKey AesKeyParams)
importAesGcmKeyFromJwk _context jwk extractable =
    Gren.Kernel.Crypto.importAesKey
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "AES-GCM"
        (extractableToBool extractable)
        [ "encrypt", "decrypt" ]


{-| Appears if there's an error when importing a key using an EC (ellipical-curve)
algorithm.

There are two possible reasons this error happens:

1. The passed key value (either `Json.Encode.Value` or `Bytes`) is not a valid key 
and cannot be imported.
2. The `EcNamedCurve` passed to the function does not match the `EcNamedCurve` of 
the imported key.
-}
type ImportEcKeyError
    = ImportEcKeyError


{-|-}
importEcdsaPublicKeyFromRaw : SecureContext -> EcNamedCurve -> Bytes -> Extractable -> Task ImportEcKeyError (PublicKey EcdsaKey EcKeyParams)
importEcdsaPublicKeyFromRaw _context namedCurve bytes extractable =
    Gren.Kernel.Crypto.importEcKey
        "public"
        "raw"
        bytes
        "ECDSA"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        [ "verify" ]


{-|-}
importEcdsaPublicKeyFromSpki : SecureContext -> EcNamedCurve -> Bytes -> Extractable -> Task ImportEcKeyError (PublicKey EcdsaKey EcKeyParams)
importEcdsaPublicKeyFromSpki _context namedCurve bytes extractable =
    Gren.Kernel.Crypto.importEcKey
        "public"
        "spki"
        bytes
        "ECDSA"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        [ "verify" ]


{-|-}
importEcdsaPublicKeyFromJwk : SecureContext -> EcNamedCurve -> Json.Encode.Value -> Extractable -> Task ImportEcKeyError (PublicKey EcdsaKey EcKeyParams)
importEcdsaPublicKeyFromJwk _context namedCurve jwk extractable =
    Gren.Kernel.Crypto.importEcKey
        "public"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "ECDSA"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        [ "verify" ]


{-|-}
importEcdhPublicKeyFromRaw : SecureContext -> EcNamedCurve -> Bytes -> Extractable -> Task ImportEcKeyError (PublicKey EcdhKey EcKeyParams)
importEcdhPublicKeyFromRaw _context namedCurve bytes extractable =
    Gren.Kernel.Crypto.importEcKey
        "public"
        "raw"
        bytes
        "ECDH"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        []


{-|-}
importEcdhPublicKeyFromSpki : SecureContext -> EcNamedCurve -> Bytes -> Extractable -> Task ImportEcKeyError (PublicKey EcdhKey EcKeyParams)
importEcdhPublicKeyFromSpki _context namedCurve bytes extractable =
    Gren.Kernel.Crypto.importEcKey
        "public"
        "spki"
        bytes
        "ECDH"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        []


{-|-}
importEcdhPublicKeyFromJwk : SecureContext -> EcNamedCurve -> Json.Encode.Value -> Extractable -> Task ImportEcKeyError (PublicKey EcdhKey EcKeyParams)
importEcdhPublicKeyFromJwk _context namedCurve jwk extractable =
    Gren.Kernel.Crypto.importEcKey
        "public"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "ECDH"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        []


{-|-}
importEcdsaPrivateKeyFromPkcs8 : SecureContext -> EcNamedCurve -> Bytes -> Extractable -> Task ImportEcKeyError (PrivateKey EcdsaKey EcKeyParams)
importEcdsaPrivateKeyFromPkcs8 _context namedCurve bytes extractable =
    Gren.Kernel.Crypto.importEcKey
        "private"
        "pkcs8"
        bytes
        "ECDSA"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        [ "sign" ]


{-|-}
importEcdsaPrivateKeyFromSpki : SecureContext -> EcNamedCurve -> Bytes -> Extractable -> Task ImportEcKeyError (PrivateKey EcdsaKey EcKeyParams)
importEcdsaPrivateKeyFromSpki _context namedCurve bytes extractable =
    Gren.Kernel.Crypto.importEcKey
        "private"
        "spki"
        bytes
        "ECDSA"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        [ "sign" ]


{-|-}
importEcdsaPrivateKeyFromJwk : SecureContext -> EcNamedCurve -> Json.Encode.Value -> Extractable -> Task ImportEcKeyError (PrivateKey EcdsaKey EcKeyParams)
importEcdsaPrivateKeyFromJwk _context namedCurve jwk extractable =
    Gren.Kernel.Crypto.importEcKey
        "private"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "ECDSA"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        [ "sign" ]


{-|-}
importEcdhPrivateKeyFromPkcs8 : SecureContext -> EcNamedCurve -> Bytes -> Extractable -> Task ImportEcKeyError (PrivateKey EcdhKey EcKeyParams)
importEcdhPrivateKeyFromPkcs8 _context namedCurve bytes extractable =
    Gren.Kernel.Crypto.importEcKey
        "private"
        "pkcs8"
        bytes
        "ECDH"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        [ "deriveKey", "deriveBits" ]


{-|-}
importEcdhPrivateKeyFromSpki : SecureContext -> EcNamedCurve -> Bytes -> Extractable -> Task ImportEcKeyError (PrivateKey EcdhKey EcKeyParams)
importEcdhPrivateKeyFromSpki _context namedCurve bytes extractable =
    Gren.Kernel.Crypto.importEcKey
        "private"
        "spki"
        bytes
        "ECDH"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        [ "deriveKey", "deriveBits" ]


{-|-}
importEcdhPrivateKeyFromJwk : SecureContext -> EcNamedCurve -> Json.Encode.Value -> Extractable -> Task ImportEcKeyError (PrivateKey EcdhKey EcKeyParams)
importEcdhPrivateKeyFromJwk  _context namedCurve jwk extractable =
    Gren.Kernel.Crypto.importEcKey
        "private"
        "jwk"
        (Gren.Kernel.Json.unwrap jwk)
        "ECDH"
        (ecNamedCurveToString namedCurve)
        (extractableToBool extractable)
        [ "deriveKey", "deriveBits" ]


{-| Appears if there's an error when importing a key using the HMAC algorithm.

There are not specific error types for importing HMAC keys due to inconsistencies
in how errors are thrown across `browser` and `node` platforms.

There are three known reasons an error can happen when importing HMAC keys:

1. The passed key value (either `Json.Encode.Value` or `Bytes`) is not a valid key 
and cannot be imported.
1. The `length` passed to the function is not correct for the imported key. The
appearance of this error is inconsistent across `browser` and `node` platforms. It's
recommended to avoid passing a `length` and instead use `Nothing` for both HMAC key
generation and importing.
2. The `hash` passed to the function does not match the `hash` of the imported key.
This only happens when importing a JSON Web Key. It is recommended to _always_ match 
the hash of the imported key or you will get different results when using the imported 
key for cryptographic functions.
-}
type ImportHmacKeyError
    = ImportHmacKeyError


{-|-}
importHmacKeyFromJwk : SecureContext -> Json.Encode.Value -> DigestAlgorithm -> Maybe Int -> Extractable -> Task ImportHmacKeyError (Key HmacKey HmacKeyParams)
importHmacKeyFromJwk _context jwk hash passedLength extractable =
    case passedLength of
        Just length ->
            Gren.Kernel.Crypto.importHmacKey
                "jwk"
                (Gren.Kernel.Json.unwrap jwk)
                "HMAC"
                (digestAlgorithmToString hash)
                length
                (extractableToBool extractable)
                [ "sign", "verify" ]

        Nothing ->
            Gren.Kernel.Crypto.importHmacKey
                "jwk"
                (Gren.Kernel.Json.unwrap jwk)
                "HMAC"
                (digestAlgorithmToString hash)
                ""
                (extractableToBool extractable)
                [ "sign", "verify" ]


{-|-}
importHmacKeyFromRaw : SecureContext -> Bytes -> DigestAlgorithm -> Maybe Int -> Extractable -> Task ImportHmacKeyError (Key HmacKey HmacKeyParams)
importHmacKeyFromRaw _context bytes hash passedLength extractable =
    case passedLength of
        Just length ->
            Gren.Kernel.Crypto.importHmacKey
                "raw"
                bytes
                 "HMAC"
                (digestAlgorithmToString hash)
                length
                (extractableToBool extractable)
                [ "sign", "verify" ]

        Nothing ->
            Gren.Kernel.Crypto.importHmacKey
                "raw"
                bytes
                "HMAC"
                (digestAlgorithmToString hash)
                ""
                (extractableToBool extractable)
                [ "sign", "verify" ]



-- ENCRYPT


{-| The parameters needs to encrypt or decrypt with the RSA-OAEP algorithm. There's only
one parameter: a `label` consisting of some `Bytes`. The label is completely optional and 
passing `Nothing` will not make the operation less secure.
-}
type alias RsaOaepParams =
    { label : Maybe Bytes
    }


{-| Errors that can happen when encrypting using the [`encryptWithRsaOaep`](#encryptWithRsaOaep) 
function.

This error should only appear if there are problems in kernel code. If you run into it, please 
file a ticket!
-}
type RsaOaepEncryptionError
    = RsaOaepEncryptionError


{-| Encrypt some `Bytes` with a `PublicKey RsaOaepKey`. You can generate the apporpriate
key with the [`generateRsaOaepKeyPair`](#generateRsaOaepKeyPair) function.
-}
encryptWithRsaOaep : SecureContext -> RsaOaepParams  -> PublicKey RsaOaepKey RsaKeyParams -> Bytes -> Task RsaOaepEncryptionError Bytes
encryptWithRsaOaep _context { label } (PublicKey (Key key _)) bytes =
    case label of
        Nothing ->
            Gren.Kernel.Crypto.encryptWithRsaOaep
                ""
                key
                bytes
        
        Just actualLabel ->
            Gren.Kernel.Crypto.encryptWithRsaOaep
                actualLabel
                key
                bytes


{-| Errors that can happen when encrypting using the [`encryptWithAesCtr`](#encryptWithAesCtr) 
function.

Any unknown or unexpected errors are captured with `AesCtrEncryptionError`. The `AesCtrEncryptionErrorCounterTooLong`
variant comes up when the 
-}
type AesCtrEncryptionError 
    = AesCtrEncryptionErrorCounterTooLong
    | AesCtrEncryptionError


{-| Required paramaters to encrypt and decrypt values with the AES-CTR algorithm.

- `counter` must be exactly 16 `Bytes`, or else encryption and decryption will fail.
- `length` must be between 1 and 128. If provided an `Int` that is below or above that
range, it will be clamped to prevent the operation from failing.
-}
type alias AesCtrParams =
    { counter : Bytes
    , length : Int
    }


{-| Encrypt some Bytes with a `Key AesCtrKey`. You can generate the apporpriate key 
with the [`generateAesCtrKey`](#generateAesCtrKey) function.
-}
encryptWithAesCtr : SecureContext -> AesCtrParams -> Key AesCtrKey AesKeyParams -> Bytes -> Task AesCtrEncryptionError Bytes
encryptWithAesCtr _context { counter, length } (Key key _) bytes =
    -- The counter must be exactly 16 bytes long
    if Bytes.width counter == 16 then
        Gren.Kernel.Crypto.encryptWithAesCtr
            counter
            (clamp 1 128 length)
            key
            bytes

    else
        Task.fail AesCtrEncryptionErrorCounterTooLong


{-|-}
type AesCbcEncryptionError =
    AesCbcEncryptionError


{-|-}
type alias AesCbcParams =
    { iv : Bytes
    }


{-|-}
encryptWithAesCbc : SecureContext -> AesCbcParams -> Key AesCbcKey AesKeyParams -> Bytes -> Task AesCbcEncryptionError Bytes
encryptWithAesCbc _context { iv } (Key key _) bytes =
    if Bytes.width iv == 16 then
        Gren.Kernel.Crypto.encryptWithAesCbc
            iv
            key
            bytes

    else
        Task.fail AesCbcEncryptionError


{-| The set of allowed tag lengths for the AES-GCM algorithm.
-}
type AesGcmTagLength
    = AesGcmTagLength96
    | AesGcmTagLength104
    | AesGcmTagLength112
    | AesGcmTagLength120
    | AesGcmTagLength128


{-|-}
type alias AesGcmParams =
    { iv : Bytes
    , additionalData : Maybe Bytes
    , tagLength : Maybe AesGcmTagLength
    }


{-|-}
type AesGcmEncryptionError =
    AesGcmEncryptionError


{-|-}
encryptWithAesGcm : SecureContext -> AesGcmParams -> Key AesGcmKey AesKeyParams -> Bytes -> Task AesGcmEncryptionError Bytes
encryptWithAesGcm _context { iv, additionalData, tagLength } (Key key _) bytes =
    let
        byteWidth =
            Bytes.width iv
    in
    if byteWidth <= 128 && byteWidth >= 12 then
        case { ad = additionalData, tl = tagLength } of
            { ad = Nothing, tl = Nothing } ->
                Gren.Kernel.Crypto.encryptWithAesGcm
                    iv
                    ""
                    ""
                    key
                    bytes
            
            { ad = Just ad, tl = Nothing} ->
                Gren.Kernel.Crypto.encryptWithAesGcm
                    iv
                    ad
                    ""
                    key
                    bytes

            { ad = Nothing, tl = Just tl } ->
                Gren.Kernel.Crypto.encryptWithAesGcm
                    iv
                    ""
                    (aesTagLengthToInt tl)
                    key
                    bytes

            { ad = Just ad, tl = Just tl } ->
                Gren.Kernel.Crypto.encryptWithAesGcm
                    iv
                    ad
                    (aesTagLengthToInt tl)
                    key
                    bytes

    else
        Task.fail AesGcmEncryptionError



-- DECRYPT


{-| Errors that can happen when decrypting `Bytes` using the [`decryptWithRsaOaep`](#decryptWithRsaOaep) function.
There are two cases where the functionc can fail:

- The `label` used to encrypt the data does not match the label used when decrypting the data
- The decryption algorithm fails due to the passed `Bytes` not being suitable for decryption (for whatever reason)
-}
type RsaOaepDecryptionError =
    RsaOaepDecryptionError


{-| Decrypt some `Bytes` with a `PrivateKey RsaOaepKey`. You can generate the apporpriate key with the 
[`generateRsaOaepKeyPair`](#generateRsaOaepKeyPair) function.
-}
decryptWithRsaOaep : SecureContext -> RsaOaepParams -> PrivateKey RsaOaepKey RsaKeyParams -> Bytes -> Task RsaOaepDecryptionError Bytes
decryptWithRsaOaep _context { label } (PrivateKey (Key privateKey _)) bytes =
    case label of
        Nothing ->
            Gren.Kernel.Crypto.decryptWithRsaOaep
                ""
                privateKey
                bytes
        
        Just actualLabel ->
            Gren.Kernel.Crypto.decryptWithRsaOaep
                actualLabel
                privateKey
                bytes


{-|-}
type AesCtrDecryptError =
    AesCtrDecryptError


{-|-}
decryptWithAesCtr : SecureContext -> AesCtrParams -> Key AesCtrKey AesKeyParams -> Bytes -> Task AesCtrDecryptError Bytes
decryptWithAesCtr _context { counter, length } (Key key _) bytes =
    if Bytes.width counter == 16 then
        Gren.Kernel.Crypto.decryptWithAesCtr
            counter
            (clamp 1 128 length)
            key
            bytes

    else
        Task.fail AesCtrDecryptError


{-|-}
type AesCbcDecryptionError
    = AesCbcDecryptionError


{-| Decrypt some `Bytes` with the AES-CBC algorithm.

Errors can happen when:
- The passed `iv` value does not equal 16 bytes
- The passsed `iv` value does not equal the `iv` value that was used to encrypt the passed `Bytes`
- The passed `Bytes` cannot be decrypted

-}
decryptWithAesCbc : SecureContext -> AesCbcParams -> Key AesCbcKey AesKeyParams -> Bytes -> Task AesCbcDecryptionError Bytes
decryptWithAesCbc _context { iv } (Key key _) bytes = 
    if Bytes.width iv == 16 then
        Gren.Kernel.Crypto.decryptWithAesCbc
            iv
            key
            bytes

    else
        Task.fail AesCbcDecryptionError


{-|-}
type AesGcmDecryptionError =
    AesGcmDecryptionError


{-|-}
decryptWithAesGcm : SecureContext -> AesGcmParams -> Key AesGcmKey AesKeyParams -> Bytes -> Task AesGcmDecryptionError Bytes
decryptWithAesGcm _context { iv, additionalData, tagLength } (Key key _) bytes =
    let
        byteWidth =
            Bytes.width iv
    in
    if byteWidth <= 128 && byteWidth >= 12 then
        case { ad = additionalData, tl = tagLength } of
            { ad = Nothing, tl = Nothing } ->
                Gren.Kernel.Crypto.decryptWithAesGcm
                    iv
                    ""
                    ""
                    key
                    bytes
            
            { ad = Just ad, tl = Nothing} ->
                Gren.Kernel.Crypto.decryptWithAesGcm
                    iv
                    ad
                    ""
                    key
                    bytes

            { ad = Nothing, tl = Just tl } ->
                Gren.Kernel.Crypto.decryptWithAesGcm
                    iv
                    ""
                    (aesTagLengthToInt tl)
                    key
                    bytes

            { ad = Just ad, tl = Just tl } ->
                Gren.Kernel.Crypto.decryptWithAesGcm
                    iv
                    ad
                    (aesTagLengthToInt tl)
                    key
                    bytes

    else
        Task.fail AesGcmDecryptionError



-- SIGN & VERIFY TYPES


{-|-}
type alias Signature
    = Bytes



-- SIGN


{-| Sign some `Bytes` with the RSA-SSAPKCS1v1.5 algorithm. This operation should always succeed.
-}
signWithRsaSsaPkcs1V1_5 : SecureContext -> PrivateKey RsaSsaPkcs1V1_5Key RsaKeyParams -> Bytes -> Task {} Signature
signWithRsaSsaPkcs1V1_5 _context (PrivateKey (Key key _)) bytes =
    Gren.Kernel.Crypto.signWithRsaSsaPkcs1V1_5 
        key 
        bytes


{-| An error that can appear when signing using the RSA-PSS algorithm.
-}
type SignWithRsaPssError
    = SignWithRsaPssError


{-| Sign some `Bytes` with the RSA-PSS algorithm.

When run, the returned `Task` can fail if the passed `salt` is not equal to or less then the
amount of bytes than the `DigestAlgorithm` that was used to generate the key. For example, if 
the `RsaPssKey` was generated with SHA-256, the maximum number for the `salt` value must be 
32 or less.
-}
signWithRsaPss : SecureContext -> Int -> PrivateKey RsaPssKey RsaKeyParams -> Bytes -> Task SignWithRsaPssError Signature
signWithRsaPss _context salt (PrivateKey (Key key { modulusLength, hash, extractable })) bytes =
    let
        clampedSaltBytes =
            clamp 0 2147483647 salt

        {- Safari (Webkit) will error if the `salt` length is greater than the `hash` of the 
        created key. The `maxSalt` values ensures consistent behavior across platforms.
        -}
        maxSalt =
            case hash of
                Sha256 ->
                    32
                
                Sha384 ->
                    48

                Sha512 ->
                    64
    in
    if clampedSaltBytes > maxSalt then
        Task.fail SignWithRsaPssError

    else
        Gren.Kernel.Crypto.signWithRsaPss 
            clampedSaltBytes
            key
            bytes


{-|-}
signWithEcdsa : SecureContext -> DigestAlgorithm -> PrivateKey EcdsaKey EcKeyParams -> Bytes -> Task {} Signature
signWithEcdsa _context hash (PrivateKey (Key key _)) bytes =
    Gren.Kernel.Crypto.signWithEcdsa
        (digestAlgorithmToString hash)
        key 
        bytes


{-|-}
signWithHmac : SecureContext -> Key HmacKey HmacKeyParams -> Bytes -> Task {} Signature
signWithHmac _context (Key key _) bytes =
    Gren.Kernel.Crypto.signWithHmac 
        key 
        bytes



-- VERIFY


{-|-}
verifyWithRsaSsaPkcs1V1_5 : SecureContext -> PublicKey RsaSsaPkcs1V1_5Key RsaKeyParams -> Signature -> Bytes -> Task {} {}
verifyWithRsaSsaPkcs1V1_5 _context (PublicKey (Key key _)) signature bytes =
    Gren.Kernel.Crypto.verifyWithRsaSsaPkcs1V1_5
        key
        signature
        bytes


{-|-}
verifyWithRsaPss : SecureContext -> Int -> PublicKey RsaPssKey RsaKeyParams -> Signature -> Bytes -> Task {} Bytes
verifyWithRsaPss _context salt (PublicKey (Key key _)) signature bytes =
    Gren.Kernel.Crypto.verifyWithRsaPss
        salt
        key
        signature
        bytes


{-|-}
verifyWithEcdsa : SecureContext -> DigestAlgorithm -> PublicKey EcdsaKey EcKeyParams -> Signature -> Bytes -> Task {} Bytes
verifyWithEcdsa _context hash (PublicKey (Key key _)) signature bytes =
    Gren.Kernel.Crypto.verifyWithEcdsa
        (digestAlgorithmToString hash)
        key
        signature
        bytes


{-|-}
verifyWithHmac : SecureContext -> Key HmacKey HmacKeyParams -> Signature -> Bytes -> Task {} Bytes
verifyWithHmac _context (Key key _) signature bytes =
    Gren.Kernel.Crypto.verifyWithHmac
        key
        signature
        bytes



-- DIGEST


{-| Supported algorithms suitable for digesting data.

Note: The algorithm `SHA1` is supported by the WebCrypto API, but not available 
in this package due to known security vunerabilities.
-}
type DigestAlgorithm
    = Sha256
    | Sha384
    | Sha512


{-| Take some `Bytes` and create a hash from them using the passed `DigestAlgorithm`.
This operation should always succeed.
-}
digest : SecureContext -> DigestAlgorithm -> Bytes -> Task x Bytes
digest _context algorithm data =
    Gren.Kernel.Crypto.digest
        (digestAlgorithmToString algorithm)
        data



-- UTILITIES


{-|-}
clamp : Int -> Int -> Int -> Int
clamp min max number =
    if number < min then
        min

    else if number > max then
        max

    else
        number


{-|-}
ecNamedCurveToString : EcNamedCurve -> String
ecNamedCurveToString namedCurve =
    case namedCurve of
        P256 ->
            "P-256"

        P384 ->
            "P-384"

        P521 ->
            "P-521"


{-|-}
aesLengthToInt : AesLength -> Int
aesLengthToInt length =
    case length of
        AesLength128 ->
            128

        AesLength192 ->
            192

        AesLength256 ->
            256


{-|-}
aesTagLengthToInt aesTagLength =
    case aesTagLength of
        AesGcmTagLength96 ->
            96

        AesGcmTagLength104 ->
            104

        AesGcmTagLength112 ->
            112
    
        AesGcmTagLength120 ->
            120

        AesGcmTagLength128 ->
            128


{-|-}
extractableToBool : Extractable -> Bool
extractableToBool extractable =
    case extractable of
        CanBeExtracted ->
            True
            
        CannotBeExtracted ->
            False


{-|-}
digestAlgorithmToString : DigestAlgorithm -> String
digestAlgorithmToString digestAlgorithm =
    case digestAlgorithm of
        Sha256 ->
            "SHA-256"

        Sha384 ->
            "SHA-384"

        Sha512 ->
            "SHA-512"


{-|-}
digestAlgorithmToBytes : DigestAlgorithm -> Int
digestAlgorithmToBytes digestAlgorithm =
    case digestAlgorithm of
        Sha256 ->
            32
        
        Sha384 ->
            48
        
        Sha512 ->
            64
