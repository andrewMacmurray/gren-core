module Stream exposing 
    ( Readable
    , Error(..)
    , read
    , readBytesAsString
    , closeReadable
    , cancelReadable
    -- Writable
    , Writable
    , write
    , writeStringAsBytes
    , writeLineAsBytes
    , closeWritable
    , cancelWritable
    -- Transform
    , Transformation
    , identityTransformation
    , identityTransformationWithOptions
    , CustomTransformationAction(..)
    , customTransformation
    , customTransformationWithOptions
    , readable
    , writable
    , pipeThrough
    , awaitAndPipeThrough
    , pipeTo
    -- Custom streams
    , textEncoder
    , textDecoder
    , gzipCompression
    , deflateCompression
    , deflateRawCompression
    , gzipDecompression
    , deflateDecompression
    , deflateRawDecompression
    )

{-| Streams

## Readable Streams

@docs Readable, Error, read, readBytesAsString, closeReadable, cancelReadable

## Writable Streams

@docs Writable, write, writeStringAsBytes, writeLineAsBytes, closeWritable, cancelWritable

## Transformation Streams

@docs Transformation, identityTransformation, identityTransformationWithOptions, CustomTransformationAction, customTransformation, customTransformationWithOptions, readable, writable, pipeThrough, awaitAndPipeThrough, pipeTo

## Custom Transformation Streams

@docs textEncoder, textDecoder, gzipCompression, deflateCompression, deflateRawCompression, gzipDecompression, deflateDecompression, deflateRawDecompression

-}

import Array exposing (Array)
import Basics exposing (Bool, Int, (<|), (|>), (++), max)
import Bytes exposing (Bytes)
import Maybe
import String exposing (String)
import Task exposing (Task)
import Gren.Kernel.Stream


{-|-}
type Readable value
    = Readable


{-|-}
type Writable value
    = Writable


{-|-}
type Error
    = Closed
    | Cancelled String
    | Locked


-- Readable


{-|-}
read : Readable value -> Task Error { streamClosed : Bool, value : value }
read =
    Gren.Kernel.Stream.read


{-|-}
readBytesAsString : Readable Bytes -> Task Error { streamClosed : Bool, value : String }
readBytesAsString stream =
    read stream
        |> Task.map (\input ->
            { streamClosed = input.streamClosed
            , value = Maybe.withDefault "" <| Bytes.toString input.value
            }
        )


{-|-}
closeReadable : Readable value -> Task Error {}
closeReadable =
    Gren.Kernel.Stream.closeReadable


{-|-}
cancelReadable : String -> Readable value -> Task Error {}
cancelReadable =
    Gren.Kernel.Stream.cancel


-- Writable


{-|-}
write : value -> Writable value -> Task Error {}
write =
    Gren.Kernel.Stream.write


{-|-}
writeStringAsBytes : String -> Writable Bytes -> Task Error {}
writeStringAsBytes str stream =
    write (Bytes.fromString str) stream


{-|-}
writeLineAsBytes : String -> Writable Bytes -> Task Error {}
writeLineAsBytes str stream =
    write (Bytes.fromString <| str ++ "\n") stream


{-|-}
closeWritable : Writable value -> Task Error {}
closeWritable =
    Gren.Kernel.Stream.closeWritable


{-|-}
cancelWritable : String -> Writable value -> Task Error {}
cancelWritable =
    Gren.Kernel.Stream.cancel


-- Transformation


{-|-}
type Transformation read write =
    -- Note: Implementation in kernel code
    Transformation read write


{-|-}
identityTransformation : Task x (Transformation data data)
identityTransformation =
    identityTransformationWithOptions { readCapacity = 0, writeCapacity = 0 }


{-|-}
identityTransformationWithOptions : { readCapacity : Int, writeCapacity : Int } -> Task x (Transformation data data)
identityTransformationWithOptions { readCapacity, writeCapacity } =
    Gren.Kernel.Stream.identityTransformation (max 0 readCapacity) (max 0 writeCapacity)


{-|-}
type CustomTransformationAction state value
    = UpdateState state
    | Send
        { state : state
        , send : Array value
        }
    | Close
    | Cancel String


{-|-}
customTransformation
    : (state -> input -> CustomTransformationAction state output)
    -> state
    -> Task x (Transformation input output)
customTransformation fn initialState =
    customTransformationWithOptions fn
        { initialState = initialState
        , readCapacity = 0
        , writeCapacity = 0
        }


{-|-}
customTransformationWithOptions
    : (state -> input -> CustomTransformationAction state output)
    -> { initialState : state
       , readCapacity : Int
       , writeCapacity : Int
       }
    -> Task x (Transformation input output)
customTransformationWithOptions fn { initialState, readCapacity, writeCapacity } =
    Gren.Kernel.Stream.customTransformation
        (customTransformationActionWrapper fn)
        initialState
        (max 0 readCapacity)
        (max 0 writeCapacity)


customTransformationActionWrapper toAction =
    \state input ->
        case toAction state input of
            UpdateState newState ->
                { ctor = "UpdateState"
                , state = newState
                , send = []
                , cancelReason = ""
                }
            
            Send { state = newState, send = sendValues } ->
                { ctor = "Send"
                , state = newState
                , send = sendValues
                , cancelReason = ""
                }
            
            Close ->
                { ctor = "Close"
                , state = state
                , send = []
                , cancelReason = ""
                }
            
            Cancel reason ->
                { ctor = "Cancel"
                , state = state
                , send = []
                , cancelReason = reason
                }

{-|-}
readable : Transformation read write -> Readable read
readable =
    Gren.Kernel.Stream.readable


{-|-}
writable : Transformation read write -> Writable write
writable =
    Gren.Kernel.Stream.writable


{-|-}
pipeThrough : Transformation input output -> Readable input -> Task Error (Readable output)
pipeThrough =
    Gren.Kernel.Stream.pipeThrough


{-|-}
awaitAndPipeThrough : Task Error (Transformation input output) -> Readable input -> Task Error (Readable output)
awaitAndPipeThrough builder source =
    Task.andThen (\transformation -> pipeThrough transformation source) builder


{-|-}
pipeTo : Writable data -> Readable data -> Task Error {}
pipeTo =
    Gren.Kernel.Stream.pipeTo


-- Built-in transformations


{-|-}
textEncoder : Task x (Transformation String Bytes)
textEncoder =
    Gren.Kernel.Stream.textEncoder


{-|-}
textDecoder : Task x (Transformation Bytes String)
textDecoder =
    Gren.Kernel.Stream.textDecoder


{-|-}
gzipCompression : Task x (Transformation Bytes Bytes)
gzipCompression =
    Gren.Kernel.Stream.compressor "gzip"


{-|-}
deflateCompression : Task x (Transformation Bytes Bytes)
deflateCompression =
    Gren.Kernel.Stream.compressor "deflate"


{-|-}
deflateRawCompression : Task x (Transformation Bytes Bytes)
deflateRawCompression =
    Gren.Kernel.Stream.compressor "deflate-raw"


{-|-}
gzipDecompression : Task x (Transformation Bytes Bytes)
gzipDecompression =
    Gren.Kernel.Stream.decompressor "gzip"


{-|-}
deflateDecompression : Task x (Transformation Bytes Bytes)
deflateDecompression =
    Gren.Kernel.Stream.decompressor "deflate"


{-|-}
deflateRawDecompression : Task x (Transformation Bytes Bytes)
deflateRawDecompression =
    Gren.Kernel.Stream.decompressor "deflate-raw"
